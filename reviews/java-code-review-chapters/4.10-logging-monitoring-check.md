### 4.10 日志监控检查

#### 4.10.1 日志规范 🔴

##### 4.10.1.1 日志框架配置检查

**1. 检测目标**

a. 必须使用统一的日志框架（SLF4J + Logback）
b. 日志级别使用必须合理（DEBUG/INFO/WARN/ERROR）
c. 日志格式必须结构化，支持检索和分析
d. 敏感信息不能出现在日志中
e. 必须包含链路追踪信息（traceId）
f. 日志文件必须支持滚动和归档

**2. 检测方法**

a. 配置审查：检查日志配置文件
b. 代码审查：检查日志使用规范
c. 安全检查：确认敏感信息不泄露
d. 性能测试：验证日志对性能的影响

**3. 错误示例**

```java
// ❌ 错误：使用System.out输出日志
public class UserService {
    public User createUser(UserRequest request) {
        System.out.println("Creating user: " + request.getUsername()); // 错误
        
        User user = new User();
        user.setUsername(request.getUsername());
        user.setPassword(request.getPassword()); // 敏感信息
        
        System.out.println("User created: " + user); // 可能包含敏感信息
        return userRepository.save(user);
    }
}

// ❌ 错误：日志级别使用不当
@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);
    
    public void processOrder(Order order) {
        log.error("Processing order: {}", order.getId()); // 正常流程不应该用ERROR
        
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            log.info("Invalid order amount"); // 错误情况应该用WARN或ERROR
        }
        
        log.debug("Order processed successfully"); // 重要信息应该用INFO
    }
}

// ❌ 错误：字符串拼接和性能问题
public class PaymentService {
    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);
    
    public void processPayment(PaymentRequest request) {
        // 字符串拼接，性能差
        log.info("Processing payment for order: " + request.getOrderId() + 
                 ", amount: " + request.getAmount());
        
        // 没有检查日志级别，可能有性能问题
        log.debug("Payment details: " + expensiveToStringMethod(request));
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：规范的日志使用
@Service
public class UserService {
    private static final Logger log = LoggerFactory.getLogger(UserService.class);
    
    public User createUser(UserRequest request) {
        String traceId = MDC.get("traceId");
        
        log.info("Creating user: username={}, traceId={}", 
            request.getUsername(), traceId);
        
        try {
            User user = new User();
            user.setUsername(request.getUsername());
            user.setPasswordHash(passwordEncoder.encode(request.getPassword()));
            
            User savedUser = userRepository.save(user);
            
            // 正确：不记录敏感信息，使用结构化日志
            log.info("User created successfully: userId={}, username={}, traceId={}", 
                savedUser.getId(), savedUser.getUsername(), traceId);
                
            return savedUser;
            
        } catch (DataIntegrityViolationException e) {
            log.warn("User creation failed - duplicate username: username={}, traceId={}", 
                request.getUsername(), traceId);
            throw new BusinessException("USERNAME_EXISTS", "用户名已存在");
            
        } catch (Exception e) {
            log.error("System error creating user: username={}, traceId={}", 
                request.getUsername(), traceId, e);
            throw new SystemException("USER_CREATION_ERROR", 
                "用户创建失败", "System error creating user", e);
        }
    }
}

// ✅ 正确：合理的日志级别使用
@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);
    
    public OrderResult processOrder(Order order) {
        String traceId = MDC.get("traceId");
        
        // INFO：重要的业务流程
        log.info("Processing order: orderId={}, amount={}, traceId={}", 
            order.getId(), order.getAmount(), traceId);
        
        // 参数验证
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            // WARN：业务规则违反
            log.warn("Invalid order amount: orderId={}, amount={}, traceId={}", 
                order.getId(), order.getAmount(), traceId);
            throw new BusinessException("INVALID_AMOUNT", "订单金额必须大于0");
        }
        
        try {
            // DEBUG：详细的处理步骤（仅在需要时启用）
            if (log.isDebugEnabled()) {
                log.debug("Validating order details: orderId={}, traceId={}", 
                    order.getId(), traceId);
            }
            
            OrderResult result = doProcessOrder(order);
            
            // INFO：成功完成的重要操作
            log.info("Order processed successfully: orderId={}, resultId={}, traceId={}", 
                order.getId(), result.getId(), traceId);
                
            return result;
            
        } catch (InsufficientInventoryException e) {
            // WARN：预期的业务异常
            log.warn("Order processing failed - insufficient inventory: orderId={}, productId={}, traceId={}", 
                order.getId(), e.getProductId(), traceId);
            throw e;
            
        } catch (Exception e) {
            // ERROR：意外的系统异常
            log.error("System error processing order: orderId={}, traceId={}", 
                order.getId(), traceId, e);
            throw new SystemException("ORDER_PROCESSING_ERROR", 
                "订单处理失败", "System error processing order", e);
        }
    }
}

// ✅ 正确：性能优化的日志记录
@Service
public class PaymentService {
    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);
    
    public PaymentResult processPayment(PaymentRequest request) {
        String traceId = MDC.get("traceId");
        
        // 正确：使用参数化日志，避免字符串拼接
        log.info("Processing payment: orderId={}, amount={}, gateway={}, traceId={}", 
            request.getOrderId(), request.getAmount(), request.getGateway(), traceId);
        
        // 正确：检查日志级别，避免不必要的计算
        if (log.isDebugEnabled()) {
            log.debug("Payment request details: {}, traceId={}", 
                toSafeString(request), traceId);
        }
        
        try {
            PaymentResult result = paymentGateway.charge(request);
            
            log.info("Payment processed successfully: orderId={}, transactionId={}, traceId={}", 
                request.getOrderId(), result.getTransactionId(), traceId);
                
            return result;
            
        } catch (PaymentGatewayException e) {
            log.warn("Payment failed: orderId={}, errorCode={}, message={}, traceId={}", 
                request.getOrderId(), e.getErrorCode(), e.getMessage(), traceId);
            throw e;
            
        } catch (Exception e) {
            log.error("System error during payment: orderId={}, traceId={}", 
                request.getOrderId(), traceId, e);
            throw new SystemException("PAYMENT_SYSTEM_ERROR", 
                "支付系统异常", "Payment system error", e);
        }
    }
    
    private String toSafeString(PaymentRequest request) {
        // 安全的字符串表示，不包含敏感信息
        return String.format("PaymentRequest{orderId=%s, amount=%s, gateway=%s}", 
            request.getOrderId(), request.getAmount(), request.getGateway());
    }
}
```

##### 4.10.1.2 日志内容规范检查

**1. 检测目标**

a. 必须使用结构化日志格式
b. 敏感信息不能出现在日志中
c. 必须包含链路追踪信息
d. 日志内容要有明确的业务含义
e. 异常日志要包含完整上下文

**2. 检测方法**

a. 代码审查：检查日志内容格式
b. 安全审查：确认敏感信息过滤
c. 链路追踪验证：确认traceId存在
d. 日志分析：验证日志可读性和有用性

**3. 错误示例**

```java
// ❌ 错误：日志内容不规范
@Service
public class UserService {
    private static final Logger log = LoggerFactory.getLogger(UserService.class);
    
    public User createUser(CreateUserRequest request) {
        // 错误：包含敏感信息
        log.info("Creating user with password: {}", request.getPassword());
        
        // 错误：没有traceId，信息不完整
        log.info("User created");
        
        // 错误：异常日志缺少上下文
        try {
            return userRepository.save(user);
        } catch (Exception e) {
            log.error("Error: {}", e.getMessage());
            throw e;
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：规范的日志内容
@Service
public class UserService {
    private static final Logger log = LoggerFactory.getLogger(UserService.class);
    
    public User createUser(CreateUserRequest request) {
        String traceId = MDC.get("traceId");
        
        // 正确：结构化日志，不包含敏感信息
        log.info("Creating user: username={}, email={}, traceId={}", 
            request.getUsername(), 
            maskEmail(request.getEmail()), 
            traceId);
        
        try {
            User user = buildUser(request);
            User savedUser = userRepository.save(user);
            
            // 正确：包含业务关键信息和traceId
            log.info("User created successfully: userId={}, username={}, traceId={}", 
                savedUser.getId(), savedUser.getUsername(), traceId);
                
            return savedUser;
            
        } catch (DataIntegrityViolationException e) {
            // 正确：业务异常，包含完整上下文
            log.warn("User creation failed - duplicate username: username={}, traceId={}", 
                request.getUsername(), traceId);
            throw new BusinessException("USERNAME_EXISTS", "用户名已存在");
            
        } catch (Exception e) {
            // 正确：系统异常，包含完整上下文和异常堆栈
            log.error("System error creating user: username={}, traceId={}", 
                request.getUsername(), traceId, e);
            throw new SystemException("USER_CREATION_ERROR", 
                "用户创建失败", "System error creating user", e);
        }
    }
    
    private String maskEmail(String email) {
        if (email == null || !email.contains("@")) {
            return "***";
        }
        String[] parts = email.split("@");
        return parts[0].substring(0, 1) + "***@" + parts[1];
    }
}
```

##### 4.10.1.3 日志级别使用检查

**1. 检测目标**

a. 必须合理使用不同日志级别
b. 避免日志级别滥用影响性能
c. 生产环境日志级别配置合理
d. 调试日志要有级别检查
e. 日志输出要考虑性能影响

**2. 检测方法**

a. 代码审查：检查日志级别使用
b. 性能测试：验证日志对性能影响
c. 配置检查：确认生产环境配置
d. 静态分析：检查日志级别判断

**3. 错误示例**

```java
// ❌ 错误：日志级别使用不当
@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);
    
    public OrderResult processOrder(Order order) {
        // 错误：普通业务流程使用ERROR级别
        log.error("Processing order: {}", order.getId());
        
        // 错误：DEBUG信息使用INFO级别，生产环境会产生大量日志
        log.info("Order validation step 1: checking amount");
        log.info("Order validation step 2: checking inventory");
        log.info("Order validation step 3: checking user status");
        
        // 错误：没有级别检查，字符串拼接影响性能
        log.debug("Order details: " + order.toString() + ", complex calculation: " + 
            complexCalculation(order));
        
        // 错误：业务异常使用ERROR级别
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            log.error("Invalid order amount: {}", order.getAmount());
        }
        
        return processOrderInternal(order);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：合理的日志级别使用
@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);
    
    public OrderResult processOrder(Order order) {
        String traceId = MDC.get("traceId");
        
        // 正确：重要业务流程使用INFO级别
        log.info("Processing order: orderId={}, amount={}, traceId={}", 
            order.getId(), order.getAmount(), traceId);
        
        // 正确：详细调试信息使用DEBUG级别，并检查级别
        if (log.isDebugEnabled()) {
            log.debug("Order validation details: orderId={}, traceId={}", 
                order.getId(), traceId);
        }
        
        // 正确：参数验证失败使用WARN级别
        if (order.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            log.warn("Invalid order amount: orderId={}, amount={}, traceId={}", 
                order.getId(), order.getAmount(), traceId);
            throw new BusinessException("INVALID_AMOUNT", "订单金额必须大于0");
        }
        
        try {
            // 正确：性能敏感的调试日志要检查级别
            if (log.isDebugEnabled()) {
                log.debug("Starting order processing: orderId={}, details={}, traceId={}", 
                    order.getId(), toSafeString(order), traceId);
            }
            
            OrderResult result = processOrderInternal(order);
            
            // 正确：成功完成的重要操作使用INFO级别
            log.info("Order processed successfully: orderId={}, resultId={}, traceId={}", 
                order.getId(), result.getId(), traceId);
                
            return result;
            
        } catch (InsufficientInventoryException e) {
            // 正确：预期的业务异常使用WARN级别
            log.warn("Order processing failed - insufficient inventory: orderId={}, productId={}, traceId={}", 
                order.getId(), e.getProductId(), traceId);
            throw e;
            
        } catch (Exception e) {
            // 正确：意外的系统异常使用ERROR级别
            log.error("System error processing order: orderId={}, traceId={}", 
                order.getId(), traceId, e);
            throw new SystemException("ORDER_PROCESSING_ERROR", 
                "订单处理失败", "System error processing order", e);
        }
    }
    
    private String toSafeString(Order order) {
        // 安全的字符串表示，避免敏感信息
        return String.format("Order{id=%s, amount=%s, status=%s}", 
            order.getId(), order.getAmount(), order.getStatus());
    }
}

// ✅ 正确：日志配置优化
// logback-spring.xml
<configuration>
    <springProfile name="prod">
        <!-- 生产环境：只记录INFO及以上级别 -->
        <root level="INFO">
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
    
    <springProfile name="dev">
        <!-- 开发环境：记录DEBUG及以上级别 -->
        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>
    
    <!-- 异步日志配置，提高性能 -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
        <queueSize>1024</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>
</configuration>
```

#### 4.10.2 监控指标设置 🟡

##### 4.10.2.1 应用性能监控检查

**1. 检测目标**

a. 必须监控接口响应时间和吞吐量
b. 必须监控应用错误率和异常统计
c. 必须集成APM工具进行链路追踪
d. 关键业务流程必须有性能埋点
e. 必须监控JVM性能指标

**2. 检测方法**

a. 性能测试：验证监控指标准确性
b. 压力测试：验证高负载下监控有效性
c. 链路追踪：检查分布式调用链完整性
d. 指标验证：确认关键指标正常收集

**3. 错误示例**

```java
// ❌ 错误：没有性能监控
@RestController
public class OrderController {
    @PostMapping("/orders")
    public OrderResult createOrder(@RequestBody OrderRequest request) {
        // 没有任何性能监控指标
        return orderService.createOrder(request);
    }
}

// ❌ 错误：没有异常统计
@Service
public class PaymentService {
    public PaymentResult processPayment(PaymentRequest request) {
        try {
            return paymentGateway.charge(request);
        } catch (Exception e) {
            // 没有异常监控统计
            throw e;
        }
    }
}

// ❌ 错误：没有JVM监控
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        // 没有配置JVM监控
        SpringApplication.run(Application.class, args);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的应用性能监控
@RestController
public class OrderController {
    private final MeterRegistry meterRegistry;
    private final Counter orderCreateCounter;
    private final Timer orderCreateTimer;
    private final Counter errorCounter;
    
    public OrderController(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.orderCreateCounter = Counter.builder("order.create.total")
            .description("Total order creation attempts")
            .register(meterRegistry);
        this.orderCreateTimer = Timer.builder("order.create.duration")
            .description("Order creation duration")
            .register(meterRegistry);
        this.errorCounter = Counter.builder("order.create.errors")
            .description("Order creation errors")
            .register(meterRegistry);
    }
    
    @PostMapping("/orders")
    @Timed(value = "order.create", description = "Order creation time")
    public ResponseEntity<OrderResult> createOrder(@RequestBody OrderRequest request) {
        Timer.Sample sample = Timer.Sample.start(meterRegistry);
        
        try {
            OrderResult result = orderService.createOrder(request);
            
            // 记录成功指标
            orderCreateCounter.increment(Tags.of("status", "success"));
            meterRegistry.gauge("order.amount", result.getAmount().doubleValue());
            
            // 记录响应时间
            sample.stop(orderCreateTimer);
            
            return ResponseEntity.ok(result);
            
        } catch (BusinessException e) {
            // 记录业务异常
            orderCreateCounter.increment(Tags.of(
                "status", "business_error",
                "error_code", e.getErrorCode()
            ));
            errorCounter.increment(Tags.of(
                "type", "business",
                "code", e.getErrorCode()
            ));
            sample.stop(orderCreateTimer);
            throw e;
            
        } catch (Exception e) {
            // 记录系统异常
            orderCreateCounter.increment(Tags.of(
                "status", "system_error",
                "exception", e.getClass().getSimpleName()
            ));
            errorCounter.increment(Tags.of(
                "type", "system",
                "exception", e.getClass().getSimpleName()
            ));
            sample.stop(orderCreateTimer);
            throw e;
        }
    }
    
    @GetMapping("/orders/{id}")
    @Timed(value = "order.query", description = "Order query time")
    public ResponseEntity<Order> getOrder(@PathVariable Long id) {
        Timer.Sample sample = Timer.Sample.start(meterRegistry);
        
        try {
            Order order = orderService.getOrder(id);
            
            // 记录查询成功
            meterRegistry.counter("order.query.total", 
                "status", "success").increment();
            sample.stop(meterRegistry.timer("order.query.duration"));
            
            return ResponseEntity.ok(order);
            
        } catch (Exception e) {
            // 记录查询失败
            meterRegistry.counter("order.query.total", 
                "status", "error",
                "exception", e.getClass().getSimpleName()).increment();
            sample.stop(meterRegistry.timer("order.query.duration"));
            throw e;
        }
    }
}

// ✅ 正确：JVM和应用监控配置
@Configuration
@EnableConfigurationProperties
public class MonitoringConfiguration {
    
    @Bean
    public MeterRegistry meterRegistry() {
        return new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
    }
    
    @Bean
    public JvmMetrics jvmMetrics() {
        return new JvmMetrics();
    }
    
    @Bean
    public ProcessorMetrics processorMetrics() {
        return new ProcessorMetrics();
    }
    
    @Bean
    public UptimeMetrics uptimeMetrics() {
        return new UptimeMetrics();
    }
    
    @Bean
    @ConditionalOnMissingBean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
    
    @EventListener
    public void bindMetrics(ApplicationReadyEvent event) {
        MeterRegistry registry = event.getApplicationContext()
            .getBean(MeterRegistry.class);
            
        // 绑定JVM指标
        new JvmGcMetrics().bindTo(registry);
        new JvmMemoryMetrics().bindTo(registry);
        new JvmThreadMetrics().bindTo(registry);
        new ClassLoaderMetrics().bindTo(registry);
        
        // 绑定系统指标
        new ProcessorMetrics().bindTo(registry);
        new UptimeMetrics().bindTo(registry);
        new FileDescriptorMetrics().bindTo(registry);
        
        // 绑定数据库连接池指标
        DataSource dataSource = event.getApplicationContext()
            .getBean(DataSource.class);
        new DataSourcePoolMetrics(dataSource, "hikari", 
            Collections.emptyList()).bindTo(registry);
    }
}

// ✅ 正确：异常统计和性能监控
@Service
public class PaymentService {
    private final MeterRegistry meterRegistry;
    private final Timer paymentTimer;
    private final Counter paymentCounter;
    private final Counter paymentErrorCounter;
    private final Gauge activePayments;
    
    public PaymentService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.paymentTimer = Timer.builder("payment.gateway.duration")
            .description("Payment gateway call duration")
            .register(meterRegistry);
        this.paymentCounter = Counter.builder("payment.gateway.total")
            .description("Payment gateway call total")
            .register(meterRegistry);
        this.paymentErrorCounter = Counter.builder("payment.errors.total")
            .description("Payment errors count")
            .register(meterRegistry);
        this.activePayments = Gauge.builder("payment.active.count")
            .description("Active payment processes")
            .register(meterRegistry, this, PaymentService::getActivePaymentCount);
    }
    
    @NewSpan("payment-process")
    public PaymentResult processPayment(PaymentRequest request) {
        Timer.Sample sample = Timer.Sample.start(meterRegistry);
        
        try {
            // 增加活跃支付计数
            meterRegistry.gauge("payment.active.count", getActivePaymentCount() + 1);
            
            PaymentResult result = paymentGateway.charge(request);
            
            // 记录成功指标
            paymentCounter.increment(Tags.of(
                "status", "success",
                "gateway", request.getGateway(),
                "amount_range", getAmountRange(request.getAmount())
            ));
            
            // 记录金额指标
            meterRegistry.gauge("payment.amount", 
                Tags.of("gateway", request.getGateway()),
                request.getAmount().doubleValue());
            
            // 记录响应时间分布
            sample.stop(Timer.builder("payment.duration")
                .tag("gateway", request.getGateway())
                .tag("status", "success")
                .register(meterRegistry));
            
            return result;
            
        } catch (PaymentTimeoutException e) {
            // 记录超时异常
            paymentCounter.increment(Tags.of(
                "status", "timeout",
                "gateway", request.getGateway()
            ));
            paymentErrorCounter.increment(Tags.of(
                "type", "timeout",
                "gateway", request.getGateway()
            ));
            sample.stop(Timer.builder("payment.duration")
                .tag("gateway", request.getGateway())
                .tag("status", "timeout")
                .register(meterRegistry));
            throw e;
            
        } catch (PaymentException e) {
            // 记录支付失败
            paymentCounter.increment(Tags.of(
                "status", "failed",
                "gateway", request.getGateway(),
                "error_code", e.getErrorCode()
            ));
            paymentErrorCounter.increment(Tags.of(
                "type", "business",
                "gateway", request.getGateway(),
                "error_code", e.getErrorCode()
            ));
            sample.stop(Timer.builder("payment.duration")
                .tag("gateway", request.getGateway())
                .tag("status", "failed")
                .register(meterRegistry));
            throw e;
            
        } catch (Exception e) {
            // 记录系统异常
            paymentCounter.increment(Tags.of(
                "status", "error",
                "gateway", request.getGateway(),
                "exception", e.getClass().getSimpleName()
            ));
            paymentErrorCounter.increment(Tags.of(
                "type", "system",
                "gateway", request.getGateway(),
                "exception", e.getClass().getSimpleName()
            ));
            sample.stop(Timer.builder("payment.duration")
                .tag("gateway", request.getGateway())
                .tag("status", "error")
                .register(meterRegistry));
            throw e;
            
        } finally {
            // 减少活跃支付计数
            meterRegistry.gauge("payment.active.count", getActivePaymentCount() - 1);
        }
    }
    
    private String getAmountRange(BigDecimal amount) {
        if (amount.compareTo(BigDecimal.valueOf(100)) <= 0) {
            return "small";
        } else if (amount.compareTo(BigDecimal.valueOf(1000)) <= 0) {
            return "medium";
        } else {
            return "large";
        }
    }
    
    private double getActivePaymentCount() {
        // 实际实现中应该返回真实的活跃支付数量
        return 0.0;
    }
}
```

##### 4.10.2.2 业务指标监控检查

**1. 检测目标**

a. 必须监控核心业务指标（订单量、支付成功率、用户活跃度）
b. 必须监控业务流程关键节点的转化率
c. 必须监控业务异常和错误分布
d. 必须支持业务指标的实时统计和趋势分析
e. 必须设置业务指标的阈值告警

**2. 检测方法**

a. 业务测试：验证业务指标统计准确性
b. 流程测试：验证业务流程监控完整性
c. 异常测试：验证业务异常统计正确性
d. 告警测试：验证业务指标告警及时性

**3. 错误示例**

```java
// ❌ 错误：没有业务指标监控
@Service
public class OrderService {
    public OrderResult createOrder(OrderRequest request) {
        // 没有订单创建指标统计
        Order order = new Order(request);
        orderRepository.save(order);
        return new OrderResult(order);
    }
    
    public void cancelOrder(Long orderId) {
        // 没有订单取消指标统计
        Order order = orderRepository.findById(orderId);
        order.cancel();
        orderRepository.save(order);
    }
}

// ❌ 错误：没有用户行为监控
@Service
public class UserService {
    public void userLogin(String userId) {
        // 没有用户登录统计
        updateLastLoginTime(userId);
    }
    
    public void userAction(String userId, String action) {
        // 没有用户行为统计
        processAction(userId, action);
    }
}

// ❌ 错误：没有支付业务监控
@Service
public class PaymentService {
    public PaymentResult processPayment(PaymentRequest request) {
        try {
            return paymentGateway.charge(request);
        } catch (Exception e) {
            // 没有支付失败原因统计
            throw e;
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的业务指标监控
@Service
public class OrderService {
    private final MeterRegistry meterRegistry;
    private final Counter orderCreateCounter;
    private final Counter orderCancelCounter;
    private final Timer orderProcessTimer;
    private final Gauge dailyOrderAmount;
    
    public OrderService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.orderCreateCounter = Counter.builder("order.create.total")
            .description("Total order creation count")
            .register(meterRegistry);
        this.orderCancelCounter = Counter.builder("order.cancel.total")
            .description("Total order cancellation count")
            .register(meterRegistry);
        this.orderProcessTimer = Timer.builder("order.process.duration")
            .description("Order processing duration")
            .register(meterRegistry);
    }
    
    @Timed(value = "order.create", description = "Order creation time")
    public OrderResult createOrder(OrderRequest request) {
        Timer.Sample sample = Timer.Sample.start(meterRegistry);
        
        try {
            Order order = new Order(request);
            orderRepository.save(order);
            
            // 记录订单创建指标
            orderCreateCounter.increment(Tags.of(
                "status", "success",
                "product_type", request.getProductType(),
                "channel", request.getChannel(),
                "amount_range", getAmountRange(request.getAmount())
            ));
            
            // 记录订单金额分布
            meterRegistry.gauge("order.amount.distribution", 
                Tags.of("range", getAmountRange(request.getAmount())),
                request.getAmount().doubleValue());
            
            // 记录每日订单总金额
            meterRegistry.gauge("order.daily.amount", 
                getDailyOrderAmount());
            
            // 记录订单处理时间
            sample.stop(orderProcessTimer);
            
            return new OrderResult(order);
            
        } catch (BusinessException e) {
            // 记录业务异常
            orderCreateCounter.increment(Tags.of(
                "status", "business_error",
                "error_code", e.getErrorCode(),
                "product_type", request.getProductType()
            ));
            sample.stop(orderProcessTimer);
            throw e;
            
        } catch (Exception e) {
            // 记录系统异常
            orderCreateCounter.increment(Tags.of(
                "status", "system_error",
                "exception", e.getClass().getSimpleName(),
                "product_type", request.getProductType()
            ));
            sample.stop(orderProcessTimer);
            throw e;
        }
    }
    
    public void cancelOrder(Long orderId, String reason) {
        Timer.Sample sample = Timer.Sample.start(meterRegistry);
        
        try {
            Order order = orderRepository.findById(orderId);
            String originalStatus = order.getStatus();
            
            order.cancel();
            orderRepository.save(order);
            
            // 记录订单取消指标
            orderCancelCounter.increment(Tags.of(
                "reason", reason,
                "original_status", originalStatus,
                "product_type", order.getProductType(),
                "time_since_create", getTimeSinceCreate(order)
            ));
            
            // 记录取消率
            double cancelRate = calculateCancelRate();
            meterRegistry.gauge("order.cancel.rate", cancelRate);
            
            sample.stop(Timer.builder("order.cancel.duration")
                .register(meterRegistry));
                
        } catch (Exception e) {
            meterRegistry.counter("order.cancel.errors",
                "exception", e.getClass().getSimpleName()).increment();
            sample.stop(Timer.builder("order.cancel.duration")
                .register(meterRegistry));
            throw e;
        }
    }
    
    private String getAmountRange(BigDecimal amount) {
        if (amount.compareTo(BigDecimal.valueOf(100)) <= 0) {
            return "small";
        } else if (amount.compareTo(BigDecimal.valueOf(1000)) <= 0) {
            return "medium";
        } else {
            return "large";
        }
    }
    
    private String getTimeSinceCreate(Order order) {
        long minutes = Duration.between(order.getCreateTime(), 
            LocalDateTime.now()).toMinutes();
        if (minutes < 30) return "immediate";
        else if (minutes < 1440) return "same_day";
        else return "delayed";
    }
    
    private double getDailyOrderAmount() {
        // 实际实现中应该查询当日订单总金额
        return 0.0;
    }
    
    private double calculateCancelRate() {
        // 实际实现中应该计算真实的取消率
        return 0.0;
    }
}

// ✅ 正确：用户行为监控
@Service
public class UserService {
    private final MeterRegistry meterRegistry;
    private final Counter userLoginCounter;
    private final Counter userActionCounter;
    private final Gauge activeUserCount;
    
    public UserService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.userLoginCounter = Counter.builder("user.login.total")
            .description("Total user login count")
            .register(meterRegistry);
        this.userActionCounter = Counter.builder("user.action.total")
            .description("Total user action count")
            .register(meterRegistry);
    }
    
    public void userLogin(String userId, String channel, String deviceType) {
        // 记录用户登录指标
        userLoginCounter.increment(Tags.of(
            "channel", channel,
            "device_type", deviceType,
            "user_type", getUserType(userId)
        ));
        
        // 记录活跃用户数
        meterRegistry.gauge("user.active.count", getActiveUserCount());
        
        // 记录登录时间分布
        meterRegistry.gauge("user.login.hour.distribution",
            Tags.of("hour", String.valueOf(LocalDateTime.now().getHour())),
            1.0);
        
        updateLastLoginTime(userId);
    }
    
    public void userAction(String userId, String action, Map<String, Object> params) {
        // 记录用户行为指标
        userActionCounter.increment(Tags.of(
            "action", action,
            "user_type", getUserType(userId),
            "source", (String) params.getOrDefault("source", "unknown")
        ));
        
        // 记录特定业务行为
        if ("purchase".equals(action)) {
            meterRegistry.counter("user.purchase.total",
                "amount_range", getAmountRange(params)).increment();
        } else if ("view_product".equals(action)) {
            meterRegistry.counter("user.product.view.total",
                "category", (String) params.get("category")).increment();
        }
        
        // 记录用户活跃度
        meterRegistry.gauge("user.engagement.score",
            Tags.of("user_id", userId),
            calculateEngagementScore(userId));
        
        processAction(userId, action);
    }
    
    private String getUserType(String userId) {
        // 实际实现中应该返回真实的用户类型
        return "regular";
    }
    
    private double getActiveUserCount() {
        // 实际实现中应该返回真实的活跃用户数
        return 0.0;
    }
    
    private String getAmountRange(Map<String, Object> params) {
        // 实际实现中应该根据参数计算金额范围
        return "medium";
    }
    
    private double calculateEngagementScore(String userId) {
        // 实际实现中应该计算真实的用户活跃度分数
        return 0.0;
    }
}

// ✅ 正确：支付业务监控
@Service
public class PaymentService {
    private final MeterRegistry meterRegistry;
    private final Counter paymentCounter;
    private final Timer paymentTimer;
    private final Counter paymentErrorCounter;
    
    public PaymentService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.paymentCounter = Counter.builder("payment.total")
            .description("Total payment attempts")
            .register(meterRegistry);
        this.paymentTimer = Timer.builder("payment.duration")
            .description("Payment processing duration")
            .register(meterRegistry);
        this.paymentErrorCounter = Counter.builder("payment.errors.total")
            .description("Payment errors count")
            .register(meterRegistry);
    }
    
    public PaymentResult processPayment(PaymentRequest request) {
        Timer.Sample sample = Timer.Sample.start(meterRegistry);
        
        try {
            PaymentResult result = paymentGateway.charge(request);
            
            // 记录支付成功指标
            paymentCounter.increment(Tags.of(
                "status", "success",
                "gateway", request.getGateway(),
                "payment_method", request.getPaymentMethod(),
                "amount_range", getAmountRange(request.getAmount()),
                "currency", request.getCurrency()
            ));
            
            // 记录支付成功率
            double successRate = calculateSuccessRate(request.getGateway());
            meterRegistry.gauge("payment.success.rate",
                Tags.of("gateway", request.getGateway()),
                successRate);
            
            // 记录支付金额分布
            meterRegistry.gauge("payment.amount.distribution",
                Tags.of(
                    "gateway", request.getGateway(),
                    "range", getAmountRange(request.getAmount())
                ),
                request.getAmount().doubleValue());
            
            sample.stop(paymentTimer);
            return result;
            
        } catch (PaymentTimeoutException e) {
            // 记录支付超时
            paymentCounter.increment(Tags.of(
                "status", "timeout",
                "gateway", request.getGateway(),
                "payment_method", request.getPaymentMethod()
            ));
            paymentErrorCounter.increment(Tags.of(
                "type", "timeout",
                "gateway", request.getGateway()
            ));
            sample.stop(paymentTimer);
            throw e;
            
        } catch (InsufficientFundsException e) {
            // 记录余额不足
            paymentCounter.increment(Tags.of(
                "status", "insufficient_funds",
                "gateway", request.getGateway(),
                "payment_method", request.getPaymentMethod()
            ));
            paymentErrorCounter.increment(Tags.of(
                "type", "insufficient_funds",
                "gateway", request.getGateway()
            ));
            sample.stop(paymentTimer);
            throw e;
            
        } catch (PaymentException e) {
            // 记录支付业务异常
            paymentCounter.increment(Tags.of(
                "status", "business_error",
                "gateway", request.getGateway(),
                "error_code", e.getErrorCode(),
                "payment_method", request.getPaymentMethod()
            ));
            paymentErrorCounter.increment(Tags.of(
                "type", "business",
                "gateway", request.getGateway(),
                "error_code", e.getErrorCode()
            ));
            sample.stop(paymentTimer);
            throw e;
            
        } catch (Exception e) {
            // 记录系统异常
            paymentCounter.increment(Tags.of(
                "status", "system_error",
                "gateway", request.getGateway(),
                "exception", e.getClass().getSimpleName()
            ));
            paymentErrorCounter.increment(Tags.of(
                "type", "system",
                "gateway", request.getGateway(),
                "exception", e.getClass().getSimpleName()
            ));
            sample.stop(paymentTimer);
            throw e;
        }
    }
    
    private String getAmountRange(BigDecimal amount) {
        if (amount.compareTo(BigDecimal.valueOf(100)) <= 0) {
            return "small";
        } else if (amount.compareTo(BigDecimal.valueOf(1000)) <= 0) {
            return "medium";
        } else {
            return "large";
        }
    }
    
    private double calculateSuccessRate(String gateway) {
        // 实际实现中应该计算真实的成功率
        return 0.95;
    }
}
```

##### 4.10.2.3 系统资源监控检查

**1. 检测目标**

a. 必须监控JVM内存使用情况（堆内存、非堆内存、GC情况）
b. 必须监控CPU使用率和负载情况
c. 必须监控磁盘I/O和网络I/O性能
d. 必须监控数据库连接池和缓存资源使用
e. 必须监控线程池状态和队列情况

**2. 检测方法**

a. 资源测试：验证系统资源监控准确性
b. 负载测试：验证高负载下资源监控有效性
c. 压力测试：验证资源瓶颈监控及时性
d. 容量测试：验证资源使用趋势分析

**3. 错误示例**

```java
// ❌ 错误：没有JVM监控
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        // 没有配置JVM监控
        SpringApplication.run(Application.class, args);
    }
}

// ❌ 错误：没有线程池监控
@Configuration
public class ThreadPoolConfig {
    @Bean
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        // 没有监控配置
        return executor;
    }
}

// ❌ 错误：没有数据库连接池监控
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/test");
        config.setMaximumPoolSize(20);
        // 没有监控配置
        return new HikariDataSource(config);
    }
}

// ❌ 错误：没有缓存监控
@Service
public class CacheService {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public void put(String key, Object value) {
        cache.put(key, value); // 没有监控缓存大小和命中率
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的JVM监控配置
@Configuration
@EnableConfigurationProperties
public class JvmMonitoringConfiguration {
    
    @Bean
    public MeterRegistry meterRegistry() {
        return new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
    }
    
    @EventListener
    public void bindJvmMetrics(ApplicationReadyEvent event) {
        MeterRegistry registry = event.getApplicationContext()
            .getBean(MeterRegistry.class);
            
        // 绑定JVM内存指标
        new JvmMemoryMetrics().bindTo(registry);
        new JvmGcMetrics().bindTo(registry);
        
        // 绑定JVM线程指标
        new JvmThreadMetrics().bindTo(registry);
        
        // 绑定类加载指标
        new ClassLoaderMetrics().bindTo(registry);
        
        // 绑定系统指标
        new ProcessorMetrics().bindTo(registry);
        new UptimeMetrics().bindTo(registry);
        new FileDescriptorMetrics().bindTo(registry);
        
        // 自定义JVM监控
        Gauge.builder("jvm.memory.heap.usage.ratio")
            .description("JVM heap memory usage ratio")
            .register(registry, this, this::getHeapUsageRatio);
            
        Gauge.builder("jvm.memory.nonheap.usage.ratio")
            .description("JVM non-heap memory usage ratio")
            .register(registry, this, this::getNonHeapUsageRatio);
            
        // GC监控
        Timer.builder("jvm.gc.pause")
            .description("GC pause time")
            .register(registry);
    }
    
    private double getHeapUsageRatio() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        return (double) heapUsage.getUsed() / heapUsage.getMax();
    }
    
    private double getNonHeapUsageRatio() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage nonHeapUsage = memoryBean.getNonHeapMemoryUsage();
        return (double) nonHeapUsage.getUsed() / nonHeapUsage.getMax();
    }
}

// ✅ 正确：线程池监控
@Configuration
public class ThreadPoolMonitoringConfig {
    
    @Bean
    public ThreadPoolTaskExecutor monitoredTaskExecutor(MeterRegistry meterRegistry) {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-task-");
        
        // 配置线程池监控
        executor.setTaskDecorator(new MonitoringTaskDecorator(meterRegistry));
        
        // 注册线程池指标
        Gauge.builder("threadpool.active.threads")
            .description("Active threads in thread pool")
            .register(meterRegistry, executor, ThreadPoolTaskExecutor::getActiveCount);
            
        Gauge.builder("threadpool.pool.size")
            .description("Current pool size")
            .register(meterRegistry, executor, ThreadPoolTaskExecutor::getPoolSize);
            
        Gauge.builder("threadpool.queue.size")
            .description("Current queue size")
            .register(meterRegistry, executor, e -> e.getThreadPoolExecutor().getQueue().size());
            
        Gauge.builder("threadpool.completed.tasks")
            .description("Completed task count")
            .register(meterRegistry, executor, e -> e.getThreadPoolExecutor().getCompletedTaskCount());
        
        return executor;
    }
    
    private static class MonitoringTaskDecorator implements TaskDecorator {
        private final MeterRegistry meterRegistry;
        private final Counter taskCounter;
        private final Timer taskTimer;
        
        public MonitoringTaskDecorator(MeterRegistry meterRegistry) {
            this.meterRegistry = meterRegistry;
            this.taskCounter = Counter.builder("threadpool.tasks.total")
                .description("Total tasks executed")
                .register(meterRegistry);
            this.taskTimer = Timer.builder("threadpool.task.duration")
                .description("Task execution duration")
                .register(meterRegistry);
        }
        
        @Override
        public Runnable decorate(Runnable runnable) {
            return () -> {
                Timer.Sample sample = Timer.Sample.start(meterRegistry);
                try {
                    runnable.run();
                    taskCounter.increment(Tags.of("status", "success"));
                } catch (Exception e) {
                    taskCounter.increment(Tags.of("status", "error", 
                        "exception", e.getClass().getSimpleName()));
                    throw e;
                } finally {
                    sample.stop(taskTimer);
                }
            };
        }
    }
}

// ✅ 正确：数据库连接池监控
@Configuration
public class DataSourceMonitoringConfig {
    
    @Bean
    public DataSource monitoredDataSource(MeterRegistry meterRegistry) {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/test");
        config.setUsername("user");
        config.setPassword("password");
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);
        
        // 启用JMX监控
        config.setRegisterMbeans(true);
        
        // 配置连接池名称用于监控
        config.setPoolName("HikariPool-Main");
        
        HikariDataSource dataSource = new HikariDataSource(config);
        
        // 注册连接池监控指标
        new DataSourcePoolMetrics(dataSource, "hikari", 
            Collections.emptyList()).bindTo(meterRegistry);
            
        // 自定义连接池监控
        Gauge.builder("datasource.connections.active")
            .description("Active database connections")
            .register(meterRegistry, dataSource.getHikariPoolMXBean(), 
                HikariPoolMXBean::getActiveConnections);
                
        Gauge.builder("datasource.connections.idle")
            .description("Idle database connections")
            .register(meterRegistry, dataSource.getHikariPoolMXBean(), 
                HikariPoolMXBean::getIdleConnections);
                
        Gauge.builder("datasource.connections.total")
            .description("Total database connections")
            .register(meterRegistry, dataSource.getHikariPoolMXBean(), 
                HikariPoolMXBean::getTotalConnections);
                
        Gauge.builder("datasource.connections.pending")
            .description("Pending connection requests")
            .register(meterRegistry, dataSource.getHikariPoolMXBean(), 
                HikariPoolMXBean::getThreadsAwaitingConnection);
        
        return dataSource;
    }
}

// ✅ 正确：缓存资源监控
@Component
public class MonitoredCacheService {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    private final MeterRegistry meterRegistry;
    private final AtomicLong hitCount = new AtomicLong(0);
    private final AtomicLong missCount = new AtomicLong(0);
    private final AtomicLong evictionCount = new AtomicLong(0);
    private final int maxSize = 10000;
    
    public MonitoredCacheService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // 注册缓存监控指标
        Gauge.builder("cache.size")
            .description("Current cache size")
            .register(meterRegistry, this, c -> c.cache.size());
            
        Gauge.builder("cache.hit.ratio")
            .description("Cache hit ratio")
            .register(meterRegistry, this, this::getHitRatio);
            
        Gauge.builder("cache.memory.usage")
            .description("Cache memory usage estimation")
            .register(meterRegistry, this, this::getMemoryUsage);
            
        // 注册缓存操作计数器
        Counter.builder("cache.operations.total")
            .description("Total cache operations")
            .register(meterRegistry);
    }
    
    public Object get(String key) {
        Object value = cache.get(key);
        
        if (value != null) {
            hitCount.incrementAndGet();
            meterRegistry.counter("cache.access", "result", "hit").increment();
        } else {
            missCount.incrementAndGet();
            meterRegistry.counter("cache.access", "result", "miss").increment();
        }
        
        return value;
    }
    
    public void put(String key, Object value) {
        // 检查缓存大小限制
        if (cache.size() >= maxSize) {
            evictOldest();
            evictionCount.incrementAndGet();
            meterRegistry.counter("cache.evictions.total").increment();
        }
        
        cache.put(key, value);
        meterRegistry.counter("cache.operations.total", "type", "put").increment();
        
        // 监控缓存大小告警
        if (cache.size() > maxSize * 0.8) {
            meterRegistry.counter("cache.size.warning").increment();
        }
    }
    
    public void remove(String key) {
        cache.remove(key);
        meterRegistry.counter("cache.operations.total", "type", "remove").increment();
    }
    
    public void clear() {
        int size = cache.size();
        cache.clear();
        meterRegistry.counter("cache.operations.total", "type", "clear").increment();
        meterRegistry.counter("cache.clear.items").increment(size);
    }
    
    private double getHitRatio() {
        long total = hitCount.get() + missCount.get();
        return total > 0 ? (double) hitCount.get() / total : 0.0;
    }
    
    private double getMemoryUsage() {
        // 简单的内存使用估算
        return cache.size() * 1024.0; // 假设每个条目1KB
    }
    
    private void evictOldest() {
        // 简单的LRU实现，实际应该使用更复杂的策略
        if (!cache.isEmpty()) {
            String firstKey = cache.keySet().iterator().next();
            cache.remove(firstKey);
        }
    }
}

// ✅ 正确：系统资源监控
@Component
public class SystemResourceMonitor {
    private final MeterRegistry meterRegistry;
    private final OperatingSystemMXBean osBean;
    private final MemoryMXBean memoryBean;
    
    public SystemResourceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.osBean = ManagementFactory.getOperatingSystemMXBean();
        this.memoryBean = ManagementFactory.getMemoryMXBean();
        
        // 注册系统资源监控指标
        Gauge.builder("system.cpu.usage")
            .description("System CPU usage")
            .register(meterRegistry, this, this::getSystemCpuUsage);
            
        Gauge.builder("system.load.average")
            .description("System load average")
            .register(meterRegistry, this, this::getSystemLoadAverage);
            
        Gauge.builder("system.memory.usage")
            .description("System memory usage")
            .register(meterRegistry, this, this::getSystemMemoryUsage);
            
        // 定期收集磁盘I/O指标
        scheduleResourceCollection();
    }
    
    private double getSystemCpuUsage() {
        if (osBean instanceof com.sun.management.OperatingSystemMXBean) {
            return ((com.sun.management.OperatingSystemMXBean) osBean)
                .getSystemCpuLoad();
        }
        return osBean.getSystemLoadAverage();
    }
    
    private double getSystemLoadAverage() {
        return osBean.getSystemLoadAverage();
    }
    
    private double getSystemMemoryUsage() {
        if (osBean instanceof com.sun.management.OperatingSystemMXBean) {
            com.sun.management.OperatingSystemMXBean sunBean = 
                (com.sun.management.OperatingSystemMXBean) osBean;
            long totalMemory = sunBean.getTotalPhysicalMemorySize();
            long freeMemory = sunBean.getFreePhysicalMemorySize();
            return (double) (totalMemory - freeMemory) / totalMemory;
        }
        return 0.0;
    }
    
    @Scheduled(fixedRate = 30000) // 每30秒收集一次
    private void scheduleResourceCollection() {
        // 收集磁盘使用情况
        File[] roots = File.listRoots();
        for (File root : roots) {
            String path = root.getAbsolutePath();
            double usageRatio = (double) (root.getTotalSpace() - root.getFreeSpace()) 
                / root.getTotalSpace();
            
            meterRegistry.gauge("system.disk.usage", 
                Tags.of("path", path), usageRatio);
        }
        
        // 收集网络连接数（简化实现）
        try {
            Process process = Runtime.getRuntime().exec("netstat -an | wc -l");
            // 实际实现中应该解析netstat输出
            meterRegistry.gauge("system.network.connections", 0.0);
        } catch (Exception e) {
            // 忽略异常
        }
    }
}
```

##### 4.10.3 告警配置检查

**1. 检测目标**

a. 必须监控关键性能指标（响应时间、吞吐量、错误率）
b. 必须监控系统资源使用情况
c. 必须监控数据库连接池和缓存性能
d. 必须设置合理的性能阈值和告警
e. 必须支持性能数据的可视化展示

**2. 检测方法**

a. 性能测试：验证监控指标准确性
b. 压力测试：验证高负载下监控有效性
c. 告警测试：验证性能告警及时性
d. 可视化检查：确认监控数据可视化完整

**3. 错误示例**

```java
// ❌ 错误：没有性能监控
@Service
public class DataService {
    public List<Data> queryData(QueryRequest request) {
        // 没有性能监控
        return dataRepository.findByConditions(request);
    }
    
    public void batchProcess(List<Data> dataList) {
        // 批处理没有监控
        for (Data data : dataList) {
            processData(data);
        }
    }
}

// ❌ 错误：缺少资源监控
@Component
public class CacheManager {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public void put(String key, Object value) {
        cache.put(key, value); // 没有监控缓存大小
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的性能监控
@Service
public class DataService {
    private final MeterRegistry meterRegistry;
    private final Timer queryTimer;
    private final Counter queryCounter;
    private final Gauge cacheHitRatio;
    
    public DataService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.queryTimer = Timer.builder("data.query.duration")
            .description("Data query duration")
            .register(meterRegistry);
        this.queryCounter = Counter.builder("data.query.total")
            .description("Data query total count")
            .register(meterRegistry);
    }
    
    @Timed(value = "data.query", description = "Data query time")
    public List<Data> queryData(QueryRequest request) {
        return Timer.Sample.start(meterRegistry)
            .stop(queryTimer)
            .recordCallable(() -> {
                try {
                    List<Data> result = dataRepository.findByConditions(request);
                    
                    // 记录查询指标
                    queryCounter.increment(Tags.of(
                        "status", "success",
                        "type", request.getType(),
                        "size", String.valueOf(result.size())
                    ));
                    
                    // 监控查询结果大小
                    meterRegistry.gauge("data.query.result.size", result.size());
                    
                    return result;
                    
                } catch (Exception e) {
                    queryCounter.increment(Tags.of(
                        "status", "error",
                        "type", request.getType(),
                        "error", e.getClass().getSimpleName()
                    ));
                    throw e;
                }
            });
    }
    
    @Async
    @Timed(value = "data.batch.process", description = "Batch process time")
    public CompletableFuture<Void> batchProcess(List<Data> dataList) {
        Timer.Sample sample = Timer.Sample.start(meterRegistry);
        
        try {
            int totalCount = dataList.size();
            int processedCount = 0;
            
            for (Data data : dataList) {
                processData(data);
                processedCount++;
                
                // 更新处理进度
                meterRegistry.gauge("data.batch.progress", 
                    (double) processedCount / totalCount * 100);
            }
            
            // 记录批处理成功
            meterRegistry.counter("data.batch.total", 
                "status", "success").increment();
            
            return CompletableFuture.completedFuture(null);
            
        } catch (Exception e) {
            meterRegistry.counter("data.batch.total", 
                "status", "error", 
                "error", e.getClass().getSimpleName()).increment();
            throw e;
            
        } finally {
            sample.stop(Timer.builder("data.batch.duration")
                .register(meterRegistry));
        }
    }
}

// ✅ 正确：资源监控
@Component
public class CacheManager {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    private final MeterRegistry meterRegistry;
    private final AtomicLong hitCount = new AtomicLong(0);
    private final AtomicLong missCount = new AtomicLong(0);
    
    public CacheManager(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // 注册缓存监控指标
        Gauge.builder("cache.size")
            .description("Cache size")
            .register(meterRegistry, this, c -> c.cache.size());
            
        Gauge.builder("cache.hit.ratio")
            .description("Cache hit ratio")
            .register(meterRegistry, this, c -> {
                long total = c.hitCount.get() + c.missCount.get();
                return total > 0 ? (double) c.hitCount.get() / total : 0.0;
            });
    }
    
    public Object get(String key) {
        Object value = cache.get(key);
        if (value != null) {
            hitCount.incrementAndGet();
            meterRegistry.counter("cache.access", "result", "hit").increment();
        } else {
            missCount.incrementAndGet();
            meterRegistry.counter("cache.access", "result", "miss").increment();
        }
        return value;
    }
    
    public void put(String key, Object value) {
        cache.put(key, value);
        meterRegistry.counter("cache.operations", "type", "put").increment();
        
        // 监控缓存大小，超过阈值告警
        if (cache.size() > 10000) {
            meterRegistry.counter("cache.size.warning").increment();
        }
    }
}
```

**第三十八条** 健康检查检查 🟡：

**检查目标：** 确保服务健康状态可监控，支持自动化运维

**检测标准：**
- 必须提供 /actuator/health 健康检查端点
- 必须提供 /actuator/ready 就绪检查端点
- 必须检查关键依赖的健康状态：数据库、Redis、外部服务
- 健康检查响应时间不超过 3 秒
- 健康检查失败时必须返回具体的错误信息
- 必须支持优雅关闭

**检测方法：**
- 接口测试：验证健康检查端点正常工作
- 依赖测试：模拟依赖故障，验证健康检查响应
- 性能测试：确认健康检查响应时间
- 运维验证：确认与负载均衡器集成正常

**错误示例：**
```java
// ❌ 错误：简单的健康检查，没有依赖检查
@RestController
public class HealthController {
    @GetMapping("/health")
    public String health() {
        return "OK"; // 过于简单，没有实际检查
    }
}
```

**正确示例：**
```java
// ✅ 正确：完整的健康检查实现
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    private final DataSource dataSource;
    
    public DatabaseHealthIndicator(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    
    @Override
    public Health health() {
        try (Connection connection = dataSource.getConnection()) {
            if (connection.isValid(3)) {
                return Health.up()
                    .withDetail("database", "Available")
                    .withDetail("validationQuery", "SELECT 1")
                    .build();
            } else {
                return Health.down()
                    .withDetail("database", "Connection validation failed")
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail("database", "Connection failed")
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}

// ✅ 正确：应用配置
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,ready,info,metrics
  endpoint:
    health:
      show-details: when-authorized
      probes:
        enabled: true
  health:
    db:
      enabled: true
    redis:
      enabled: true
```

#### 4.10.3 告警配置检查 🟠

##### 4.10.3.1 告警规则设置检查

**1. 检测目标**

a. 关键指标必须设置合理的告警阈值（响应时间、错误率、资源使用率）。

b. 告警规则必须分级（Critical、Warning、Info）。

c. 告警条件必须考虑时间窗口和持续时间。

d. 必须避免告警风暴和误报。

e. 告警规则必须定期评估和调整。

**2. 检测方法**

1. 告警配置审查（阈值合理性、规则完整性）。

2. 历史数据分析（基于历史数据设置阈值）。

3. 告警测试（模拟异常情况验证告警）。

4. 告警效果评估（误报率、漏报率分析）。

**3. 错误示例**

```java
// ❌ 错误：没有告警配置
@Configuration
public class MonitoringConfig {
    
    @Bean
    public MeterRegistry meterRegistry() {
        // 只配置了指标收集，没有告警规则
        return new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
    }
}

// ❌ 错误：告警阈值不合理
@Component
public class AlertConfig {
    
    public void configureAlerts() {
        // 错误：阈值过于敏感，容易产生误报
        createAlert("response_time", "> 100ms", "CRITICAL");
        
        // 错误：阈值过于宽松，可能漏报
        createAlert("error_rate", "> 50%", "WARNING");
        
        // 错误：没有考虑时间窗口
        createAlert("cpu_usage", "> 80%", "CRITICAL");
    }
}

// ❌ 错误：缺少告警抑制机制
@Service
public class AlertService {
    
    public void sendAlert(String message) {
        // 没有告警抑制，可能产生告警风暴
        emailService.sendAlert(message);
        smsService.sendAlert(message);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的告警规则配置
@Configuration
@EnableConfigurationProperties(AlertProperties.class)
public class AlertConfiguration {
    
    private final AlertProperties alertProperties;
    private final MeterRegistry meterRegistry;
    
    public AlertConfiguration(AlertProperties alertProperties, 
                            MeterRegistry meterRegistry) {
        this.alertProperties = alertProperties;
        this.meterRegistry = meterRegistry;
    }
    
    @Bean
    public AlertManager alertManager() {
        AlertManager alertManager = new AlertManager();
        
        // 配置响应时间告警
        configureResponseTimeAlerts(alertManager);
        
        // 配置错误率告警
        configureErrorRateAlerts(alertManager);
        
        // 配置资源使用告警
        configureResourceAlerts(alertManager);
        
        // 配置业务指标告警
        configureBusinessAlerts(alertManager);
        
        return alertManager;
    }
    
    private void configureResponseTimeAlerts(AlertManager alertManager) {
        // 接口响应时间告警 - 分级设置
        AlertRule criticalRule = AlertRule.builder()
            .name("api_response_time_critical")
            .metric("http_request_duration_seconds")
            .condition("p95 > 2.0") // 95分位数超过2秒
            .duration("2m") // 持续2分钟
            .severity(AlertSeverity.CRITICAL)
            .description("API响应时间严重超标")
            .tags(Map.of("service", "order-service"))
            .build();
            
        AlertRule warningRule = AlertRule.builder()
            .name("api_response_time_warning")
            .metric("http_request_duration_seconds")
            .condition("p95 > 1.0") // 95分位数超过1秒
            .duration("5m") // 持续5分钟
            .severity(AlertSeverity.WARNING)
            .description("API响应时间超标")
            .tags(Map.of("service", "order-service"))
            .build();
            
        alertManager.addRule(criticalRule);
        alertManager.addRule(warningRule);
    }
    
    private void configureErrorRateAlerts(AlertManager alertManager) {
        // 错误率告警
        AlertRule errorRateRule = AlertRule.builder()
            .name("api_error_rate_high")
            .metric("http_requests_total")
            .condition("rate(http_requests_total{status=~\"5..\"}[5m]) / rate(http_requests_total[5m]) > 0.05")
            .duration("3m")
            .severity(AlertSeverity.CRITICAL)
            .description("API错误率超过5%")
            .build();
            
        // 业务异常告警
        AlertRule businessErrorRule = AlertRule.builder()
            .name("business_error_rate_high")
            .metric("business_errors_total")
            .condition("rate(business_errors_total[5m]) > 10")
            .duration("2m")
            .severity(AlertSeverity.WARNING)
            .description("业务异常频率过高")
            .build();
            
        alertManager.addRule(errorRateRule);
        alertManager.addRule(businessErrorRule);
    }
    
    private void configureResourceAlerts(AlertManager alertManager) {
        // JVM内存告警
        AlertRule memoryRule = AlertRule.builder()
            .name("jvm_memory_usage_high")
            .metric("jvm_memory_used_bytes")
            .condition("jvm_memory_used_bytes{area=\"heap\"} / jvm_memory_max_bytes{area=\"heap\"} > 0.85")
            .duration("5m")
            .severity(AlertSeverity.WARNING)
            .description("JVM堆内存使用率超过85%")
            .build();
            
        // CPU使用率告警
        AlertRule cpuRule = AlertRule.builder()
            .name("cpu_usage_high")
            .metric("system_cpu_usage")
            .condition("system_cpu_usage > 0.8")
            .duration("10m") // 较长时间窗口避免误报
            .severity(AlertSeverity.WARNING)
            .description("CPU使用率持续超过80%")
            .build();
            
        // 数据库连接池告警
        AlertRule dbConnectionRule = AlertRule.builder()
            .name("db_connection_pool_exhausted")
            .metric("hikaricp_connections_active")
            .condition("hikaricp_connections_active / hikaricp_connections_max > 0.9")
            .duration("1m")
            .severity(AlertSeverity.CRITICAL)
            .description("数据库连接池使用率超过90%")
            .build();
            
        alertManager.addRule(memoryRule);
        alertManager.addRule(cpuRule);
        alertManager.addRule(dbConnectionRule);
    }
    
    private void configureBusinessAlerts(AlertManager alertManager) {
        // 订单处理失败率告警
        AlertRule orderFailureRule = AlertRule.builder()
            .name("order_failure_rate_high")
            .metric("order_create_total")
            .condition("rate(order_create_total{status=\"failed\"}[10m]) / rate(order_create_total[10m]) > 0.1")
            .duration("5m")
            .severity(AlertSeverity.CRITICAL)
            .description("订单创建失败率超过10%")
            .build();
            
        // 支付成功率告警
        AlertRule paymentSuccessRule = AlertRule.builder()
            .name("payment_success_rate_low")
            .metric("payment_total")
            .condition("rate(payment_total{status=\"success\"}[10m]) / rate(payment_total[10m]) < 0.95")
            .duration("3m")
            .severity(AlertSeverity.WARNING)
            .description("支付成功率低于95%")
            .build();
            
        alertManager.addRule(orderFailureRule);
        alertManager.addRule(paymentSuccessRule);
    }
}

// ✅ 正确：告警属性配置
@ConfigurationProperties(prefix = "alert")
@Data
public class AlertProperties {
    
    private ResponseTime responseTime = new ResponseTime();
    private ErrorRate errorRate = new ErrorRate();
    private Resource resource = new Resource();
    private Notification notification = new Notification();
    
    @Data
    public static class ResponseTime {
        private Duration warningThreshold = Duration.ofSeconds(1);
        private Duration criticalThreshold = Duration.ofSeconds(2);
        private Duration evaluationWindow = Duration.ofMinutes(5);
    }
    
    @Data
    public static class ErrorRate {
        private double warningThreshold = 0.02; // 2%
        private double criticalThreshold = 0.05; // 5%
        private Duration evaluationWindow = Duration.ofMinutes(5);
    }
    
    @Data
    public static class Resource {
        private double memoryWarningThreshold = 0.85; // 85%
        private double memoryCriticalThreshold = 0.95; // 95%
        private double cpuWarningThreshold = 0.8; // 80%
        private double cpuCriticalThreshold = 0.9; // 90%
    }
    
    @Data
    public static class Notification {
        private Duration suppressionWindow = Duration.ofMinutes(30);
        private int maxAlertsPerHour = 10;
        private List<String> criticalChannels = Arrays.asList("email", "sms", "slack");
        private List<String> warningChannels = Arrays.asList("email", "slack");
    }
}
```

##### 4.10.3.2 通知配置检查

**1. 检测目标**

a. 必须配置多种通知渠道（邮件、短信、即时通讯）。

b. 不同级别告警使用不同通知方式。

c. 必须配置告警抑制和去重机制。

d. 通知内容必须包含足够的上下文信息。

e. 必须支持告警升级机制。

**2. 检测方法**

1. 通知配置验证（渠道可用性、格式正确性）。

2. 通知测试（发送测试告警验证通知）。

3. 告警抑制测试（验证重复告警抑制）。

4. 升级机制测试（验证告警升级流程）。

**3. 错误示例**

```java
// ❌ 错误：单一通知渠道
@Service
public class AlertNotificationService {
    
    public void sendAlert(Alert alert) {
        // 只有邮件通知，没有其他渠道
        emailService.send(alert.getMessage());
    }
}

// ❌ 错误：没有告警抑制
@Service
public class SimpleAlertService {
    
    public void processAlert(Alert alert) {
        // 每次都发送，没有抑制机制
        notificationService.send(alert);
    }
}

// ❌ 错误：通知内容不完整
@Component
public class AlertFormatter {
    
    public String formatAlert(Alert alert) {
        // 信息不完整，缺少上下文
        return "Alert: " + alert.getName();
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的通知配置
@Service
public class AlertNotificationService {
    
    private final EmailNotificationChannel emailChannel;
    private final SmsNotificationChannel smsChannel;
    private final SlackNotificationChannel slackChannel;
    private final WeChatNotificationChannel weChatChannel;
    private final AlertSuppressionService suppressionService;
    private final AlertEscalationService escalationService;
    
    public AlertNotificationService(
            EmailNotificationChannel emailChannel,
            SmsNotificationChannel smsChannel,
            SlackNotificationChannel slackChannel,
            WeChatNotificationChannel weChatChannel,
            AlertSuppressionService suppressionService,
            AlertEscalationService escalationService) {
        this.emailChannel = emailChannel;
        this.smsChannel = smsChannel;
        this.slackChannel = slackChannel;
        this.weChatChannel = weChatChannel;
        this.suppressionService = suppressionService;
        this.escalationService = escalationService;
    }
    
    public void processAlert(Alert alert) {
        // 检查告警抑制
        if (suppressionService.isSuppressed(alert)) {
            log.info("Alert suppressed: alertId={}, rule={}", 
                alert.getId(), alert.getRuleName());
            return;
        }
        
        // 记录告警抑制状态
        suppressionService.recordAlert(alert);
        
        // 根据严重级别选择通知渠道
        List<NotificationChannel> channels = selectChannels(alert.getSeverity());
        
        // 格式化告警消息
        AlertMessage message = formatAlertMessage(alert);
        
        // 发送通知
        for (NotificationChannel channel : channels) {
            try {
                channel.send(message);
                log.info("Alert sent via {}: alertId={}, rule={}", 
                    channel.getName(), alert.getId(), alert.getRuleName());
            } catch (Exception e) {
                log.error("Failed to send alert via {}: alertId={}, rule={}", 
                    channel.getName(), alert.getId(), alert.getRuleName(), e);
            }
        }
        
        // 启动升级机制
        if (alert.getSeverity() == AlertSeverity.CRITICAL) {
            escalationService.scheduleEscalation(alert);
        }
    }
    
    private List<NotificationChannel> selectChannels(AlertSeverity severity) {
        switch (severity) {
            case CRITICAL:
                return Arrays.asList(emailChannel, smsChannel, slackChannel, weChatChannel);
            case WARNING:
                return Arrays.asList(emailChannel, slackChannel);
            case INFO:
                return Arrays.asList(slackChannel);
            default:
                return Arrays.asList(emailChannel);
        }
    }
    
    private AlertMessage formatAlertMessage(Alert alert) {
        return AlertMessage.builder()
            .title(formatTitle(alert))
            .content(formatContent(alert))
            .severity(alert.getSeverity())
            .timestamp(alert.getTimestamp())
            .tags(alert.getTags())
            .runbookUrl(generateRunbookUrl(alert))
            .dashboardUrl(generateDashboardUrl(alert))
            .build();
    }
    
    private String formatTitle(Alert alert) {
        return String.format("[%s] %s - %s", 
            alert.getSeverity().name(),
            alert.getService(),
            alert.getDescription());
    }
    
    private String formatContent(Alert alert) {
        StringBuilder content = new StringBuilder();
        content.append("告警详情:\n");
        content.append("服务: ").append(alert.getService()).append("\n");
        content.append("规则: ").append(alert.getRuleName()).append("\n");
        content.append("描述: ").append(alert.getDescription()).append("\n");
        content.append("当前值: ").append(alert.getCurrentValue()).append("\n");
        content.append("阈值: ").append(alert.getThreshold()).append("\n");
        content.append("持续时间: ").append(alert.getDuration()).append("\n");
        content.append("时间: ").append(alert.getTimestamp()).append("\n");
        
        if (!alert.getTags().isEmpty()) {
            content.append("标签: ");
            alert.getTags().forEach((key, value) -> 
                content.append(key).append("=").append(value).append(" "));
            content.append("\n");
        }
        
        content.append("\n处理建议:\n");
        content.append(generateSuggestions(alert));
        
        return content.toString();
    }
    
    private String generateSuggestions(Alert alert) {
        // 根据告警类型生成处理建议
        switch (alert.getType()) {
            case "response_time_high":
                return "1. 检查应用性能指标\n2. 查看数据库慢查询\n3. 检查外部依赖响应时间";
            case "error_rate_high":
                return "1. 查看错误日志\n2. 检查最近部署\n3. 验证外部依赖状态";
            case "memory_usage_high":
                return "1. 检查内存泄漏\n2. 分析GC日志\n3. 考虑扩容";
            default:
                return "请查看监控大盘和相关日志";
        }
    }
    
    private String generateRunbookUrl(Alert alert) {
        return String.format("https://runbook.company.com/alerts/%s", alert.getType());
    }
    
    private String generateDashboardUrl(Alert alert) {
        return String.format("https://grafana.company.com/d/service-dashboard?var-service=%s", 
            alert.getService());
    }
}

// ✅ 正确：告警抑制服务
@Service
public class AlertSuppressionService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final AlertProperties alertProperties;
    
    private static final String SUPPRESSION_KEY_PREFIX = "alert:suppression:";
    private static final String ALERT_COUNT_KEY_PREFIX = "alert:count:";
    
    public AlertSuppressionService(RedisTemplate<String, Object> redisTemplate,
                                 AlertProperties alertProperties) {
        this.redisTemplate = redisTemplate;
        this.alertProperties = alertProperties;
    }
    
    public boolean isSuppressed(Alert alert) {
        String suppressionKey = generateSuppressionKey(alert);
        String countKey = generateCountKey(alert);
        
        // 检查是否在抑制窗口内
        Boolean suppressed = redisTemplate.hasKey(suppressionKey);
        if (Boolean.TRUE.equals(suppressed)) {
            return true;
        }
        
        // 检查小时内告警数量限制
        Integer hourlyCount = (Integer) redisTemplate.opsForValue().get(countKey);
        if (hourlyCount != null && hourlyCount >= alertProperties.getNotification().getMaxAlertsPerHour()) {
            log.warn("Alert rate limit exceeded: rule={}, count={}", 
                alert.getRuleName(), hourlyCount);
            return true;
        }
        
        return false;
    }
    
    public void recordAlert(Alert alert) {
        String suppressionKey = generateSuppressionKey(alert);
        String countKey = generateCountKey(alert);
        
        Duration suppressionWindow = alertProperties.getNotification().getSuppressionWindow();
        
        // 设置抑制窗口
        redisTemplate.opsForValue().set(suppressionKey, alert.getId(), suppressionWindow);
        
        // 增加小时计数
        redisTemplate.opsForValue().increment(countKey);
        redisTemplate.expire(countKey, Duration.ofHours(1));
    }
    
    private String generateSuppressionKey(Alert alert) {
        return SUPPRESSION_KEY_PREFIX + alert.getRuleName() + ":" + 
               alert.getService() + ":" + alert.getFingerprint();
    }
    
    private String generateCountKey(Alert alert) {
        LocalDateTime now = LocalDateTime.now();
        String hourKey = now.format(DateTimeFormatter.ofPattern("yyyyMMddHH"));
        return ALERT_COUNT_KEY_PREFIX + alert.getRuleName() + ":" + hourKey;
    }
}
```

##### 4.10.3.3 处理流程检查

**1. 检测目标**

a. 必须建立标准化的告警处理流程。

b. 告警必须有明确的责任人和处理时限。

c. 必须记录告警处理过程和结果。

d. 必须建立告警回顾和改进机制。

e. 重要告警必须有应急预案。

**2. 检测方法**

1. 流程文档审查（处理流程完整性）。

2. 响应时间统计（处理效率分析）。

3. 处理质量评估（解决方案有效性）。

4. 流程改进跟踪（持续优化效果）。

**3. 错误示例**

```java
// ❌ 错误：没有处理流程跟踪
@Service
public class AlertHandlingService {
    
    public void handleAlert(Alert alert) {
        // 没有记录处理过程
        log.info("Handling alert: {}", alert.getId());
        
        // 没有指定责任人
        // 没有处理时限
        // 没有状态跟踪
    }
}

// ❌ 错误：缺少处理记录
@RestController
public class AlertController {
    
    @PostMapping("/alerts/{id}/acknowledge")
    public void acknowledgeAlert(@PathVariable String id) {
        // 只是简单确认，没有记录处理信息
        alertService.acknowledge(id);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的告警处理流程
@Service
public class AlertHandlingService {
    
    private final AlertRepository alertRepository;
    private final AlertAssignmentService assignmentService;
    private final AlertNotificationService notificationService;
    private final AlertMetricsService metricsService;
    
    public AlertHandlingService(
            AlertRepository alertRepository,
            AlertAssignmentService assignmentService,
            AlertNotificationService notificationService,
            AlertMetricsService metricsService) {
        this.alertRepository = alertRepository;
        this.assignmentService = assignmentService;
        this.notificationService = notificationService;
        this.metricsService = metricsService;
    }
    
    @Transactional
    public AlertHandlingResult processNewAlert(Alert alert) {
        // 1. 保存告警记录
        AlertRecord record = createAlertRecord(alert);
        alertRepository.save(record);
        
        // 2. 自动分配责任人
        String assignee = assignmentService.assignAlert(alert);
        record.setAssignee(assignee);
        record.setStatus(AlertStatus.ASSIGNED);
        
        // 3. 设置处理时限
        Duration sla = calculateSLA(alert.getSeverity());
        record.setSlaDeadline(LocalDateTime.now().plus(sla));
        
        // 4. 记录处理步骤
        addHandlingStep(record, "ASSIGNED", 
            String.format("Alert assigned to %s, SLA: %s", assignee, sla));
        
        // 5. 发送分配通知
        notificationService.sendAssignmentNotification(record);
        
        // 6. 启动SLA监控
        scheduleSLACheck(record);
        
        // 7. 更新指标
        metricsService.recordAlertCreated(alert);
        
        log.info("Alert processed: alertId={}, assignee={}, sla={}", 
            record.getId(), assignee, sla);
            
        return AlertHandlingResult.builder()
            .alertId(record.getId())
            .assignee(assignee)
            .slaDeadline(record.getSlaDeadline())
            .build();
    }
    
    @Transactional
    public void acknowledgeAlert(String alertId, String userId, String comment) {
        AlertRecord record = alertRepository.findById(alertId)
            .orElseThrow(() -> new AlertNotFoundException(alertId));
            
        // 验证权限
        if (!canAcknowledge(record, userId)) {
            throw new AlertAccessDeniedException("User cannot acknowledge this alert");
        }
        
        // 更新状态
        record.setStatus(AlertStatus.ACKNOWLEDGED);
        record.setAcknowledgedBy(userId);
        record.setAcknowledgedAt(LocalDateTime.now());
        
        // 记录处理步骤
        addHandlingStep(record, "ACKNOWLEDGED", 
            String.format("Alert acknowledged by %s: %s", userId, comment));
        
        // 取消SLA检查
        cancelSLACheck(alertId);
        
        // 更新指标
        metricsService.recordAlertAcknowledged(record);
        
        log.info("Alert acknowledged: alertId={}, user={}", alertId, userId);
    }
    
    @Transactional
    public void resolveAlert(String alertId, String userId, 
                           AlertResolution resolution) {
        AlertRecord record = alertRepository.findById(alertId)
            .orElseThrow(() -> new AlertNotFoundException(alertId));
            
        // 验证权限
        if (!canResolve(record, userId)) {
            throw new AlertAccessDeniedException("User cannot resolve this alert");
        }
        
        // 更新状态
        record.setStatus(AlertStatus.RESOLVED);
        record.setResolvedBy(userId);
        record.setResolvedAt(LocalDateTime.now());
        record.setResolution(resolution);
        
        // 记录处理步骤
        addHandlingStep(record, "RESOLVED", 
            String.format("Alert resolved by %s: %s\nRoot cause: %s\nSolution: %s", 
                userId, resolution.getSummary(), 
                resolution.getRootCause(), resolution.getSolution()));
        
        // 发送解决通知
        notificationService.sendResolutionNotification(record);
        
        // 更新指标
        metricsService.recordAlertResolved(record);
        
        // 安排回顾
        if (record.getSeverity() == AlertSeverity.CRITICAL) {
            schedulePostMortem(record);
        }
        
        log.info("Alert resolved: alertId={}, user={}, duration={}", 
            alertId, userId, 
            Duration.between(record.getCreatedAt(), record.getResolvedAt()));
    }
    
    private AlertRecord createAlertRecord(Alert alert) {
        return AlertRecord.builder()
            .id(UUID.randomUUID().toString())
            .ruleName(alert.getRuleName())
            .service(alert.getService())
            .severity(alert.getSeverity())
            .description(alert.getDescription())
            .currentValue(alert.getCurrentValue())
            .threshold(alert.getThreshold())
            .tags(alert.getTags())
            .status(AlertStatus.NEW)
            .createdAt(LocalDateTime.now())
            .handlingSteps(new ArrayList<>())
            .build();
    }
    
    private Duration calculateSLA(AlertSeverity severity) {
        switch (severity) {
            case CRITICAL:
                return Duration.ofMinutes(15);
            case WARNING:
                return Duration.ofHours(2);
            case INFO:
                return Duration.ofHours(8);
            default:
                return Duration.ofHours(24);
        }
    }
    
    private void addHandlingStep(AlertRecord record, String action, String description) {
        AlertHandlingStep step = AlertHandlingStep.builder()
            .timestamp(LocalDateTime.now())
            .action(action)
            .description(description)
            .build();
        record.getHandlingSteps().add(step);
    }
    
    private boolean canAcknowledge(AlertRecord record, String userId) {
        // 检查用户权限和告警状态
        return record.getAssignee().equals(userId) || 
               hasAdminRole(userId);
    }
    
    private boolean canResolve(AlertRecord record, String userId) {
        // 检查用户权限和告警状态
        return (record.getAssignee().equals(userId) || hasAdminRole(userId)) &&
               record.getStatus() == AlertStatus.ACKNOWLEDGED;
    }
    
    private boolean hasAdminRole(String userId) {
        // 实际实现中检查用户角色
        return false;
    }
    
    private void scheduleSLACheck(AlertRecord record) {
        // 实现SLA检查调度
    }
    
    private void cancelSLACheck(String alertId) {
        // 取消SLA检查
    }
    
    private void schedulePostMortem(AlertRecord record) {
        // 安排事后回顾
    }
}

// ✅ 正确：告警指标服务
@Service
public class AlertMetricsService {
    
    private final MeterRegistry meterRegistry;
    private final Counter alertCreatedCounter;
    private final Counter alertResolvedCounter;
    private final Timer alertResolutionTimer;
    private final Gauge activeAlertsGauge;
    
    public AlertMetricsService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.alertCreatedCounter = Counter.builder("alerts.created.total")
            .description("Total alerts created")
            .register(meterRegistry);
        this.alertResolvedCounter = Counter.builder("alerts.resolved.total")
            .description("Total alerts resolved")
            .register(meterRegistry);
        this.alertResolutionTimer = Timer.builder("alerts.resolution.duration")
            .description("Alert resolution time")
            .register(meterRegistry);
        this.activeAlertsGauge = Gauge.builder("alerts.active.count")
            .description("Active alerts count")
            .register(meterRegistry, this, AlertMetricsService::getActiveAlertCount);
    }
    
    public void recordAlertCreated(Alert alert) {
        alertCreatedCounter.increment(Tags.of(
            "severity", alert.getSeverity().name().toLowerCase(),
            "service", alert.getService(),
            "rule", alert.getRuleName()
        ));
    }
    
    public void recordAlertAcknowledged(AlertRecord record) {
        Duration acknowledgmentTime = Duration.between(
            record.getCreatedAt(), record.getAcknowledgedAt());
            
        Timer.builder("alerts.acknowledgment.duration")
            .tag("severity", record.getSeverity().name().toLowerCase())
            .tag("service", record.getService())
            .register(meterRegistry)
            .record(acknowledgmentTime);
    }
    
    public void recordAlertResolved(AlertRecord record) {
        alertResolvedCounter.increment(Tags.of(
            "severity", record.getSeverity().name().toLowerCase(),
            "service", record.getService(),
            "rule", record.getRuleName()
        ));
        
        Duration resolutionTime = Duration.between(
            record.getCreatedAt(), record.getResolvedAt());
            
        alertResolutionTimer.record(resolutionTime, Tags.of(
            "severity", record.getSeverity().name().toLowerCase(),
            "service", record.getService()
        ));
        
        // 记录SLA达成情况
        boolean slaViolated = record.getResolvedAt().isAfter(record.getSlaDeadline());
        meterRegistry.counter("alerts.sla.violations",
            "severity", record.getSeverity().name().toLowerCase(),
            "violated", String.valueOf(slaViolated))
            .increment();
    }
    
    private double getActiveAlertCount() {
        // 实际实现中返回活跃告警数量
        return 0.0;
    }
}
```