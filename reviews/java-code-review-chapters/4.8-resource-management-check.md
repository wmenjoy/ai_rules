# 4.8 资源管理检查

##### 4.8.1 内存资源管理检查

###### 4.8.1.1 内存泄漏检查

**1. 检测目标**

a. 避免无限制的缓存和集合增长
b. 防止静态集合持有对象引用
c. 及时清理事件监听器和回调
d. 避免ThreadLocal使用后不清理

**2. 检测方法**

a. 静态分析：使用 SpotBugs、FindBugs 检测内存泄漏模式
b. 内存分析：使用 JProfiler、MAT 分析堆内存
c. 压力测试：长时间运行验证内存稳定性
d. 代码审查：检查集合使用和对象生命周期

**3. 错误示例**

```java
// ❌ 错误：无限制的缓存导致内存泄漏
public class UserCache {
    private static final Map<String, User> cache = new HashMap<>();
    
    public User getUser(String id) {
        if (!cache.containsKey(id)) {
            User user = userService.findById(id);
            cache.put(id, user); // 无限制添加，可能导致OOM
        }
        return cache.get(id);
    }
}

// ❌ 错误：静态集合持有对象引用
public class EventManager {
    private static final List<EventListener> listeners = new ArrayList<>();
    
    public static void addListener(EventListener listener) {
        listeners.add(listener); // 永远不清理，导致内存泄漏
    }
}

// ❌ 错误：ThreadLocal使用后不清理
public class UserContext {
    private static final ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public static void setCurrentUser(User user) {
        currentUser.set(user); // 使用后不清理
    }
    
    public static User getCurrentUser() {
        return currentUser.get();
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：使用有限制的缓存
@Component
public class UserCache {
    private final Cache<String, User> cache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(30, TimeUnit.MINUTES)
        .removalListener((key, value, cause) -> {
            log.debug("Cache entry removed: key={}, cause={}", key, cause);
        })
        .build();
    
    public User getUser(String id) {
        return cache.get(id, key -> userService.findById(key));
    }
    
    @PreDestroy
    public void cleanup() {
        cache.invalidateAll();
    }
}

// ✅ 正确：使用弱引用避免内存泄漏
public class EventManager {
    private final Set<WeakReference<EventListener>> listeners = 
        Collections.synchronizedSet(new HashSet<>());
    
    public void addListener(EventListener listener) {
        listeners.add(new WeakReference<>(listener));
        cleanupStaleReferences();
    }
    
    public void removeListener(EventListener listener) {
        listeners.removeIf(ref -> ref.get() == listener || ref.get() == null);
    }
    
    private void cleanupStaleReferences() {
        listeners.removeIf(ref -> ref.get() == null);
    }
}

// ✅ 正确：ThreadLocal正确使用和清理
public class UserContext {
    private static final ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public static void setCurrentUser(User user) {
        currentUser.set(user);
    }
    
    public static User getCurrentUser() {
        return currentUser.get();
    }
    
    public static void clear() {
        currentUser.remove(); // 使用后必须清理
    }
}

// 在Filter或Interceptor中确保清理
@Component
public class UserContextFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        try {
            chain.doFilter(request, response);
        } finally {
            UserContext.clear(); // 确保清理
        }
    }
}
```

###### 4.8.1.2 对象创建优化检查

**1. 检测目标**

a. 避免在循环中创建大量临时对象
b. 合理使用对象池和复用机制
c. 避免不必要的装箱拆箱操作
d. 优化字符串拼接操作

**2. 检测方法**

a. 性能分析：使用 JProfiler 分析对象创建热点
b. 代码审查：检查循环和频繁调用的方法
c. 静态分析：检测字符串拼接和装箱操作
d. 基准测试：对比优化前后的性能

**3. 错误示例**

```java
// ❌ 错误：循环中创建大量临时对象
public class DataProcessor {
    public List<String> processData(List<Integer> numbers) {
        List<String> result = new ArrayList<>();
        for (Integer num : numbers) {
            // 每次循环都创建新的StringBuilder
            StringBuilder sb = new StringBuilder();
            sb.append("Number: ").append(num);
            result.add(sb.toString());
        }
        return result;
    }
    
    // ❌ 错误：字符串拼接性能差
    public String buildMessage(List<String> items) {
        String message = "";
        for (String item : items) {
            message += item + ", "; // 每次都创建新字符串
        }
        return message;
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：复用对象，减少创建开销
public class DataProcessor {
    private static final ThreadLocal<StringBuilder> STRING_BUILDER = 
        ThreadLocal.withInitial(() -> new StringBuilder(256));
    
    public List<String> processData(List<Integer> numbers) {
        List<String> result = new ArrayList<>(numbers.size());
        StringBuilder sb = STRING_BUILDER.get();
        
        for (Integer num : numbers) {
            sb.setLength(0); // 重置而不是创建新对象
            sb.append("Number: ").append(num);
            result.add(sb.toString());
        }
        return result;
    }
    
    // ✅ 正确：使用StringBuilder进行字符串拼接
    public String buildMessage(List<String> items) {
        StringBuilder sb = new StringBuilder(items.size() * 20);
        for (int i = 0; i < items.size(); i++) {
            if (i > 0) sb.append(", ");
            sb.append(items.get(i));
        }
        return sb.toString();
    }
    
    // ✅ 正确：使用对象池复用昂贵对象
    @Component
    public class ConnectionPoolManager {
        private final ObjectPool<ExpensiveObject> objectPool;
        
        public ConnectionPoolManager() {
            this.objectPool = new GenericObjectPool<>(
                new ExpensiveObjectFactory(), 
                new GenericObjectPoolConfig<>());
        }
        
        public void processWithPooledObject() {
            ExpensiveObject obj = null;
            try {
                obj = objectPool.borrowObject();
                obj.doWork();
            } catch (Exception e) {
                log.error("Error processing with pooled object", e);
            } finally {
                if (obj != null) {
                    try {
                        objectPool.returnObject(obj);
                    } catch (Exception e) {
                        log.error("Error returning object to pool", e);
                    }
                }
            }
        }
    }
}
```

###### 4.8.1.3 大对象处理检查

**1. 检测目标**

a. 避免一次性加载大量数据到内存
b. 合理使用流式处理和分页机制
c. 及时释放大对象引用
d. 避免大对象在堆中长时间驻留

**2. 检测方法**

a. 内存监控：监控堆内存使用和GC频率
b. 代码审查：检查大数据集处理逻辑
c. 性能测试：模拟大数据量场景
d. 静态分析：检测可能的大对象创建

**3. 错误示例**

```java
// ❌ 错误：一次性加载大量数据
@Service
public class DataExportService {
    public void exportAllUsers() {
        List<User> allUsers = userRepository.findAll(); // 可能有百万条记录
        for (User user : allUsers) {
            processUser(user);
        }
    }
    
    // ❌ 错误：创建大数组占用内存
    public byte[] processLargeFile(String filePath) {
        File file = new File(filePath);
        byte[] data = new byte[(int) file.length()]; // 可能几GB大小
        // 处理逻辑...
        return data;
    }
    
    // ❌ 错误：大对象长时间持有引用
    public class ReportGenerator {
        private List<BigData> cachedData; // 大对象缓存
        
        public void generateReport() {
            cachedData = loadBigData(); // 加载大量数据
            // 处理完后没有清理引用
            processData(cachedData);
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：使用分页和流式处理
@Service
public class DataExportService {
    private static final int BATCH_SIZE = 1000;
    
    public void exportAllUsers() {
        int page = 0;
        Page<User> userPage;
        
        do {
            Pageable pageable = PageRequest.of(page, BATCH_SIZE);
            userPage = userRepository.findAll(pageable);
            
            userPage.getContent().forEach(this::processUser);
            
            // 及时清理引用，帮助GC
            userPage = null;
            page++;
            
            // 适当的内存压力检查
            if (page % 10 == 0) {
                System.gc(); // 建议GC（可选）
            }
        } while (userPage != null && userPage.hasNext());
    }
    
    // ✅ 正确：使用流式处理大文件
    public void processLargeFile(String filePath) {
        try (BufferedInputStream bis = new BufferedInputStream(
                new FileInputStream(filePath), 8192)) {
            
            byte[] buffer = new byte[8192];
            int bytesRead;
            
            while ((bytesRead = bis.read(buffer)) != -1) {
                processChunk(buffer, bytesRead);
                // buffer会被重用，不会创建大量对象
            }
        } catch (IOException e) {
            log.error("Error processing large file: {}", filePath, e);
        }
    }
    
    // ✅ 正确：及时清理大对象引用
    @Component
    public class ReportGenerator {
        
        public void generateReport() {
            List<BigData> data = null;
            try {
                data = loadBigData();
                processData(data);
            } finally {
                // 及时清理大对象引用
                if (data != null) {
                    data.clear();
                    data = null;
                }
                // 建议进行垃圾回收
                Runtime.getRuntime().gc();
            }
        }
        
        // ✅ 正确：使用WeakReference持有大对象
        private WeakReference<List<BigData>> cachedDataRef;
        
        public List<BigData> getCachedData() {
            List<BigData> data = cachedDataRef != null ? cachedDataRef.get() : null;
            if (data == null) {
                data = loadBigData();
                cachedDataRef = new WeakReference<>(data);
            }
            return data;
        }
    }
    
    // ✅ 正确：使用NIO处理大文件
    public void processLargeFileWithNIO(String filePath) {
        try (RandomAccessFile file = new RandomAccessFile(filePath, "r");
             FileChannel channel = file.getChannel()) {
            
            long fileSize = channel.size();
            long position = 0;
            int bufferSize = 1024 * 1024; // 1MB buffer
            
            while (position < fileSize) {
                MappedByteBuffer buffer = channel.map(
                    FileChannel.MapMode.READ_ONLY, 
                    position, 
                    Math.min(bufferSize, fileSize - position));
                
                processBuffer(buffer);
                position += buffer.capacity();
                
                // 显式清理MappedByteBuffer
                if (buffer instanceof DirectBuffer) {
                    ((DirectBuffer) buffer).cleaner().clean();
                }
            }
        } catch (IOException e) {
            log.error("Error processing large file with NIO: {}", filePath, e);
        }
    }
    
    private void processChunk(byte[] buffer, int length) {
        // 处理数据块
    }
    
    private void processBuffer(ByteBuffer buffer) {
        // 处理缓冲区数据
    }
    
    private void processUser(User user) {
        // 处理用户数据
    }
    
    private List<BigData> loadBigData() {
        // 加载大数据
        return new ArrayList<>(); 
    }
    
    private void processData(List<BigData> data) {
        // 处理数据
    }
}
```

###### 4.8.1.3 大对象处理检查

**1. 检测目标**

a. 及时释放大对象引用
b. 避免长时间持有大对象
c. 合理处理大文件和大数据集
d. 实现流式处理避免内存溢出

**2. 检测方法**

a. 内存监控：监控大对象的生命周期
b. 代码审查：检查大对象的使用模式
c. 压力测试：验证大数据处理的稳定性
d. 性能分析：分析内存使用峰值

**3. 错误示例**

```java
// ❌ 错误：一次性加载大文件到内存
public class FileProcessor {
    public void processLargeFile(String filePath) {
        try {
            // 一次性读取整个文件，可能导致OOM
            List<String> lines = Files.readAllLines(Paths.get(filePath));
            for (String line : lines) {
                processLine(line);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    // ❌ 错误：长时间持有大对象引用
    private List<byte[]> largeDataCache = new ArrayList<>();
    
    public void processData(byte[] data) {
        largeDataCache.add(data); // 持续累积，不释放
        // 处理逻辑
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：流式处理大文件
public class FileProcessor {
    
    public void processLargeFile(String filePath) {
        try (Stream<String> lines = Files.lines(Paths.get(filePath))) {
            lines.forEach(this::processLine); // 逐行处理，不占用大量内存
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    // ✅ 正确：批量处理大数据集
    public void processBatchData(List<DataRecord> records) {
        final int batchSize = 1000;
        
        for (int i = 0; i < records.size(); i += batchSize) {
            int endIndex = Math.min(i + batchSize, records.size());
            List<DataRecord> batch = records.subList(i, endIndex);
            
            processBatch(batch);
            
            // 处理完批次后，建议进行垃圾回收
            if (i % (batchSize * 10) == 0) {
                System.gc(); // 仅在必要时建议GC
            }
        }
    }
    
    // ✅ 正确：使用有界队列处理大数据流
    @Service
    public class DataStreamProcessor {
        private final BlockingQueue<DataRecord> queue = 
            new ArrayBlockingQueue<>(1000); // 有界队列
        
        @Async
        public void processDataStream(Stream<DataRecord> dataStream) {
            dataStream.forEach(record -> {
                try {
                    queue.put(record); // 背压控制
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException(e);
                }
            });
        }
        
        @EventListener
        public void processQueuedData() {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    DataRecord record = queue.take();
                    processRecord(record);
                    record = null; // 显式释放引用
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
}
```

##### 4.8.2 文件资源管理检查

###### 4.8.2.1 文件流关闭检查

**1. 检测目标**

a. 必须使用 try-with-resources 处理文件资源
b. 确保文件流、Reader、Writer 正确关闭
c. 避免文件句柄泄漏
d. 正确处理文件操作异常

**2. 检测方法**

a. 静态分析：使用 SpotBugs 检测资源泄漏
b. 代码审查：检查所有文件 I/O 操作
c. 运行时监控：监控文件句柄数量
d. 单元测试：验证资源正确释放

**3. 错误示例**

```java
// ❌ 错误：手动管理文件资源，容易泄漏
public class FileProcessor {
    public String readFile(String path) {
        FileInputStream fis = null;
        BufferedReader reader = null;
        try {
            fis = new FileInputStream(path);
            reader = new BufferedReader(new InputStreamReader(fis));
            return reader.readLine();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            // ❌ 复杂的手动关闭逻辑，容易出错
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    // 忽略异常
                }
            }
        }
    }
    
    // ❌ 错误：没有关闭文件流
    public void copyFile(String source, String target) {
        try {
            FileInputStream input = new FileInputStream(source);
            FileOutputStream output = new FileOutputStream(target);
            
            byte[] buffer = new byte[1024];
            int length;
            while ((length = input.read(buffer)) > 0) {
                output.write(buffer, 0, length);
            }
            // ❌ 没有关闭流，导致资源泄漏
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：使用 try-with-resources 自动管理资源
public class FileProcessor {
    public String readFile(String path) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(path))) {
            return reader.readLine();
        }
    }
    
    public void writeFile(String path, String content) throws IOException {
        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(path))) {
            writer.write(content);
        }
    }
    
    // ✅ 正确：多个资源的正确管理
    public void copyFile(String source, String target) throws IOException {
        try (FileInputStream input = new FileInputStream(source);
             FileOutputStream output = new FileOutputStream(target)) {
            
            byte[] buffer = new byte[1024];
            int length;
            while ((length = input.read(buffer)) > 0) {
                output.write(buffer, 0, length);
            }
        }
    }
    
    // ✅ 正确：使用 Files 工具类简化操作
    public List<String> readAllLines(String path) throws IOException {
        return Files.readAllLines(Paths.get(path), StandardCharsets.UTF_8);
    }
    
    public void writeAllLines(String path, List<String> lines) throws IOException {
        Files.write(Paths.get(path), lines, StandardCharsets.UTF_8);
    }
}
```

###### 4.8.2.2 文件锁管理检查

**1. 检测目标**

a. 正确使用文件锁避免并发冲突
b. 及时释放文件锁资源
c. 处理文件锁获取失败的情况
d. 避免死锁和锁竞争

**2. 检测方法**

a. 代码审查：检查文件锁的使用模式
b. 并发测试：验证多线程文件访问
c. 静态分析：检测锁资源泄漏
d. 性能测试：评估锁竞争影响

**3. 错误示例**

```java
// ❌ 错误：文件锁使用不当
public class FileLocker {
    public void writeWithLock(String path, String content) {
        try {
            RandomAccessFile file = new RandomAccessFile(path, "rw");
            FileChannel channel = file.getChannel();
            FileLock lock = channel.lock(); // 可能阻塞很久
            
            // 写入数据
            file.writeUTF(content);
            
            // ❌ 没有释放锁和文件资源
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    // ❌ 错误：没有处理锁获取失败
    public void processFile(String path) {
        try (RandomAccessFile file = new RandomAccessFile(path, "rw");
             FileChannel channel = file.getChannel()) {
            
            FileLock lock = channel.tryLock(); // 可能返回null
            // ❌ 没有检查lock是否为null
            processFileContent(file);
            lock.release();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：正确使用文件锁
public class FileLocker {
    
    public void writeWithLock(String path, String content) throws IOException {
        try (RandomAccessFile file = new RandomAccessFile(path, "rw");
             FileChannel channel = file.getChannel()) {
            
            // 使用try-with-resources管理锁资源
            try (FileLock lock = channel.lock()) {
                file.writeUTF(content);
                file.getFD().sync(); // 强制同步到磁盘
            }
        }
    }
    
    // ✅ 正确：处理锁获取失败
    public boolean processFileWithTimeout(String path, long timeoutMs) {
        try (RandomAccessFile file = new RandomAccessFile(path, "rw");
             FileChannel channel = file.getChannel()) {
            
            FileLock lock = null;
            long startTime = System.currentTimeMillis();
            
            // 重试获取锁，直到超时
            while (lock == null && 
                   (System.currentTimeMillis() - startTime) < timeoutMs) {
                try {
                    lock = channel.tryLock();
                    if (lock == null) {
                        Thread.sleep(100); // 短暂等待后重试
                    }
                } catch (OverlappingFileLockException e) {
                    Thread.sleep(100);
                }
            }
            
            if (lock != null) {
                try {
                    processFileContent(file);
                    return true;
                } finally {
                    lock.release();
                }
            }
            return false; // 获取锁失败
            
        } catch (IOException | InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
    
    // ✅ 正确：使用共享锁进行读操作
    public String readWithSharedLock(String path) throws IOException {
        try (RandomAccessFile file = new RandomAccessFile(path, "r");
             FileChannel channel = file.getChannel();
             FileLock lock = channel.lock(0, Long.MAX_VALUE, true)) { // 共享锁
            
            return file.readUTF();
        }
    }
    
    private void processFileContent(RandomAccessFile file) throws IOException {
        // 处理文件内容
    }
}
```

###### 4.8.2.3 临时文件清理检查

**1. 检测目标**

a. 及时清理临时文件和目录
b. 使用 deleteOnExit 或显式删除
c. 避免临时文件累积占用磁盘空间
d. 处理临时文件删除失败的情况

**2. 检测方法**

a. 代码审查：检查临时文件的生命周期管理
b. 磁盘监控：监控临时目录空间使用
c. 单元测试：验证临时文件正确清理
d. 集成测试：长时间运行验证清理效果

**3. 错误示例**

```java
// ❌ 错误：临时文件没有清理
public class TempFileProcessor {
    public void processData(byte[] data) {
        try {
            // 创建临时文件但不清理
            File tempFile = File.createTempFile("data", ".tmp");
            Files.write(tempFile.toPath(), data);
            
            // 处理文件
            processFile(tempFile);
            
            // ❌ 没有删除临时文件
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    // ❌ 错误：临时目录没有清理
    public void createWorkspace() {
        try {
            Path tempDir = Files.createTempDirectory("workspace");
            // 在临时目录中创建文件
            Files.createFile(tempDir.resolve("work.txt"));
            
            // ❌ 处理完后没有清理整个目录
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：正确管理临时文件生命周期
public class TempFileProcessor {
    
    public void processData(byte[] data) throws IOException {
        Path tempFile = null;
        try {
            tempFile = Files.createTempFile("data", ".tmp");
            Files.write(tempFile, data);
            
            processFile(tempFile.toFile());
            
        } finally {
            // 确保临时文件被删除
            if (tempFile != null) {
                try {
                    Files.deleteIfExists(tempFile);
                } catch (IOException e) {
                    log.warn("Failed to delete temp file: {}", tempFile, e);
                }
            }
        }
    }
    
    // ✅ 正确：使用 deleteOnExit 作为备选方案
    public File createTempFileWithBackup(String prefix, String suffix) throws IOException {
        File tempFile = File.createTempFile(prefix, suffix);
        tempFile.deleteOnExit(); // JVM退出时删除
        return tempFile;
    }
    
    // ✅ 正确：递归清理临时目录
    public void createAndCleanWorkspace() throws IOException {
        Path tempDir = null;
        try {
            tempDir = Files.createTempDirectory("workspace");
            
            // 在临时目录中工作
            Path workFile = tempDir.resolve("work.txt");
            Files.createFile(workFile);
            Files.write(workFile, "test data".getBytes());
            
            // 处理工作文件
            processWorkFile(workFile);
            
        } finally {
            // 递归删除整个临时目录
            if (tempDir != null) {
                deleteDirectoryRecursively(tempDir);
            }
        }
    }
    
    // ✅ 正确：使用 try-with-resources 管理临时资源
    public void processWithAutoCleanup(byte[] data) throws IOException {
        try (TempFileResource tempResource = new TempFileResource("data", ".tmp")) {
            Files.write(tempResource.getPath(), data);
            processFile(tempResource.getPath().toFile());
            // 资源会自动清理
        }
    }
    
    private void deleteDirectoryRecursively(Path directory) {
        try {
            Files.walk(directory)
                .sorted(Comparator.reverseOrder())
                .map(Path::toFile)
                .forEach(file -> {
                    if (!file.delete()) {
                        log.warn("Failed to delete: {}", file.getAbsolutePath());
                    }
                });
        } catch (IOException e) {
            log.error("Error deleting directory: {}", directory, e);
        }
    }
    
    private void processFile(File file) {
        // 处理文件
    }
    
    private void processWorkFile(Path file) {
        // 处理工作文件
    }
    
    // 自定义资源管理类
    private static class TempFileResource implements AutoCloseable {
        private final Path tempFile;
        
        public TempFileResource(String prefix, String suffix) throws IOException {
            this.tempFile = Files.createTempFile(prefix, suffix);
        }
        
        public Path getPath() {
            return tempFile;
        }
        
        @Override
        public void close() {
            try {
                Files.deleteIfExists(tempFile);
            } catch (IOException e) {
                log.warn("Failed to delete temp file: {}", tempFile, e);
            }
        }
    }
    
    // 处理多个资源
    public void copyFile(String source, String target) throws IOException {
        try (InputStream in = Files.newInputStream(Paths.get(source));
             OutputStream out = Files.newOutputStream(Paths.get(target))) {
            in.transferTo(out);
        }
    }
}
```

##### 4.8.3 网络资源管理检查

###### 4.8.3.1 连接池配置检查

**1. 检测目标**

a. 正确配置HTTP连接池参数
b. 设置合理的最大连接数和每路由连接数
c. 配置连接池的空闲连接管理
d. 避免连接池资源耗尽

**2. 检测方法**

a. 配置审查：检查连接池配置参数
b. 性能测试：验证连接池在高并发下的表现
c. 监控分析：监控连接池使用情况
d. 代码审查：检查连接池的创建和使用

**3. 错误示例**

```java
// ❌ 错误：每次创建新连接，没有连接池
@Service
public class ApiService {
    public String callApi(String url) {
        RestTemplate restTemplate = new RestTemplate(); // 每次新建
        return restTemplate.getForObject(url, String.class);
    }
    
    // ❌ 错误：没有配置连接池参数
    public String callExternalApi(String url) {
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory();
        // 使用默认配置，没有设置连接池
        RestTemplate restTemplate = new RestTemplate(factory);
        return restTemplate.getForObject(url, String.class);
    }
}

// ❌ 错误：连接池配置不合理
@Configuration
public class BadHttpClientConfig {
    @Bean
    public RestTemplate restTemplate() {
        PoolingHttpClientConnectionManager connectionManager = 
            new PoolingHttpClientConnectionManager();
        connectionManager.setMaxTotal(1); // 太小
        connectionManager.setDefaultMaxPerRoute(1); // 太小
        // 没有设置空闲连接清理
        
        CloseableHttpClient httpClient = HttpClients.custom()
            .setConnectionManager(connectionManager)
            .build();
        
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory(httpClient);
        return new RestTemplate(factory);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：合理配置连接池
@Configuration
public class HttpClientConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        // 配置连接池
        PoolingHttpClientConnectionManager connectionManager = 
            new PoolingHttpClientConnectionManager();
        connectionManager.setMaxTotal(200); // 总连接数
        connectionManager.setDefaultMaxPerRoute(50); // 每个路由的最大连接数
        connectionManager.setValidateAfterInactivity(2000); // 验证空闲连接
        
        // 配置空闲连接清理
        connectionManager.closeExpiredConnections();
        connectionManager.closeIdleConnections(30, TimeUnit.SECONDS);
        
        CloseableHttpClient httpClient = HttpClients.custom()
            .setConnectionManager(connectionManager)
            .setDefaultRequestConfig(RequestConfig.custom()
                .setConnectTimeout(5000)
                .setSocketTimeout(30000)
                .setConnectionRequestTimeout(3000) // 从连接池获取连接的超时
                .build())
            .setRetryHandler(new DefaultHttpRequestRetryHandler(3, true))
            .build();
        
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory(httpClient);
        return new RestTemplate(factory);
    }
    
    // ✅ 正确：定期清理空闲连接
    @Bean
    public IdleConnectionEvictor idleConnectionEvictor(
            PoolingHttpClientConnectionManager connectionManager) {
        return new IdleConnectionEvictor(connectionManager, 30, TimeUnit.SECONDS);
    }
}

// ✅ 正确：使用连接池的服务
@Service
public class ApiService {
    private final RestTemplate restTemplate;
    
    public ApiService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }
    
    public String callApi(String url) {
        return restTemplate.getForObject(url, String.class);
    }
    
    // ✅ 正确：批量调用时复用连接
    public List<String> batchCallApi(List<String> urls) {
        return urls.parallelStream()
            .map(this::callApi)
            .collect(Collectors.toList());
    }
}
```

###### 4.8.3.2 超时设置检查

**1. 检测目标**

a. 设置合理的连接超时时间
b. 配置适当的读取超时时间
c. 设置连接请求超时时间
d. 根据业务场景调整超时参数

**2. 检测方法**

a. 配置审查：检查各种超时配置
b. 性能测试：验证超时设置的有效性
c. 网络测试：模拟网络延迟和中断
d. 日志分析：分析超时异常的频率和原因

**3. 错误示例**

```java
// ❌ 错误：没有设置超时时间
public class HttpClient {
    public String get(String url) throws IOException {
        URL urlObj = new URL(url);
        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();
        // 没有设置任何超时，可能无限等待
        try (InputStream in = conn.getInputStream()) {
            return new String(in.readAllBytes());
        }
    }
    
    // ❌ 错误：超时时间设置不合理
    public String getWithBadTimeout(String url) throws IOException {
        URL urlObj = new URL(url);
        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();
        conn.setConnectTimeout(1); // 太短，容易失败
        conn.setReadTimeout(300000); // 5分钟太长
        
        try (InputStream in = conn.getInputStream()) {
            return new String(in.readAllBytes());
        }
    }
}

// ❌ 错误：没有处理超时异常
@Service
public class BadApiService {
    @Autowired
    private RestTemplate restTemplate;
    
    public String callApi(String url) {
        // 没有捕获和处理超时异常
        return restTemplate.getForObject(url, String.class);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：合理设置超时时间
public class HttpClient {
    
    public String get(String url) throws IOException {
        URL urlObj = new URL(url);
        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();
        
        // 设置合理的超时时间
        conn.setConnectTimeout(5000); // 连接超时5秒
        conn.setReadTimeout(30000); // 读取超时30秒
        
        try (InputStream in = conn.getInputStream()) {
            return new String(in.readAllBytes());
        } finally {
            conn.disconnect(); // 确保连接关闭
        }
    }
    
    // ✅ 正确：根据业务场景设置不同超时
    public String getWithCustomTimeout(String url, int connectTimeout, int readTimeout) 
            throws IOException {
        URL urlObj = new URL(url);
        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();
        
        conn.setConnectTimeout(connectTimeout);
        conn.setReadTimeout(readTimeout);
        
        try (InputStream in = conn.getInputStream()) {
            return new String(in.readAllBytes());
        } finally {
            conn.disconnect();
        }
    }
}

// ✅ 正确：处理超时异常
@Service
public class ApiService {
    private final RestTemplate restTemplate;
    
    public ApiService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }
    
    public String callApi(String url) {
        try {
            return restTemplate.getForObject(url, String.class);
        } catch (ResourceAccessException e) {
            if (e.getCause() instanceof SocketTimeoutException) {
                log.warn("API调用超时: {}", url);
                throw new ApiTimeoutException("API调用超时", e);
            } else if (e.getCause() instanceof ConnectTimeoutException) {
                log.warn("连接超时: {}", url);
                throw new ApiConnectionException("连接超时", e);
            }
            throw e;
        }
    }
    
    // ✅ 正确：带重试的超时处理
    @Retryable(
        value = {ApiTimeoutException.class, ApiConnectionException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public String callApiWithRetry(String url) {
        return callApi(url);
    }
}

// ✅ 正确：异步调用的超时处理
@Service
public class AsyncApiService {
    
    @Async
    public CompletableFuture<String> callApiAsync(String url) {
        return CompletableFuture.supplyAsync(() -> {
            // 实现API调用逻辑
            return callApi(url);
        }).orTimeout(10, TimeUnit.SECONDS) // 设置异步超时
          .exceptionally(throwable -> {
              if (throwable instanceof TimeoutException) {
                  log.warn("异步API调用超时: {}", url);
                  return "TIMEOUT";
              }
              throw new RuntimeException(throwable);
          });
    }
    
    private String callApi(String url) {
        // 具体的API调用实现
        return "result";
    }
}
```

###### 4.8.3.3 连接泄漏检查

**1. 检测目标**

a. 确保网络连接正确关闭
b. 避免连接池连接泄漏
c. 处理异常情况下的连接释放
d. 监控连接使用情况

**2. 检测方法**

a. 代码审查：检查连接的生命周期管理
b. 运行时监控：监控活跃连接数
c. 压力测试：长时间运行验证连接泄漏
d. 工具检测：使用连接池监控工具

**3. 错误示例**

```java
// ❌ 错误：手动管理连接但没有正确关闭
public class LeakyHttpClient {
    
    public String getData(String url) {
        try {
            URL urlObj = new URL(url);
            HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();
            
            if (conn.getResponseCode() != 200) {
                return null; // ❌ 没有关闭连接就返回
            }
            
            try (InputStream in = conn.getInputStream()) {
                return new String(in.readAllBytes());
            }
            // ❌ 没有在finally中关闭连接
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    // ❌ 错误：使用完RestTemplate后没有清理
    public void batchProcess(List<String> urls) {
        for (String url : urls) {
            RestTemplate restTemplate = new RestTemplate();
            try {
                String result = restTemplate.getForObject(url, String.class);
                processResult(result);
            } catch (Exception e) {
                // ❌ 异常时没有清理资源
                log.error("处理失败: {}", url, e);
            }
            // ❌ 没有清理RestTemplate的连接
        }
    }
    
    private void processResult(String result) {
        // 处理结果
    }
}

// ❌ 错误：数据库连接泄漏
@Repository
public class LeakyDataAccess {
    
    @Autowired
    private DataSource dataSource;
    
    public List<User> getUsers() {
        try {
            Connection conn = dataSource.getConnection();
            PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users");
            ResultSet rs = stmt.executeQuery();
            
            List<User> users = new ArrayList<>();
            while (rs.next()) {
                users.add(mapUser(rs));
            }
            return users;
            // ❌ 没有关闭Connection、PreparedStatement、ResultSet
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
    
    private User mapUser(ResultSet rs) throws SQLException {
        // 映射用户对象
        return new User();
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：确保连接正确关闭
public class ProperHttpClient {
    
    public String getData(String url) throws IOException {
        URL urlObj = new URL(url);
        HttpURLConnection conn = null;
        
        try {
            conn = (HttpURLConnection) urlObj.openConnection();
            conn.setConnectTimeout(5000);
            conn.setReadTimeout(30000);
            
            if (conn.getResponseCode() != 200) {
                throw new IOException("HTTP错误: " + conn.getResponseCode());
            }
            
            try (InputStream in = conn.getInputStream()) {
                return new String(in.readAllBytes());
            }
        } finally {
            // 确保连接被关闭
            if (conn != null) {
                conn.disconnect();
            }
        }
    }
    
    // ✅ 正确：使用try-with-resources管理资源
    public String getDataWithAutoClose(String url) throws IOException {
        URL urlObj = new URL(url);
        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();
        conn.setConnectTimeout(5000);
        conn.setReadTimeout(30000);
        
        try (AutoCloseableConnection autoConn = new AutoCloseableConnection(conn)) {
            if (conn.getResponseCode() != 200) {
                throw new IOException("HTTP错误: " + conn.getResponseCode());
            }
            
            try (InputStream in = conn.getInputStream()) {
                return new String(in.readAllBytes());
            }
        }
    }
    
    // 自定义AutoCloseable包装器
    private static class AutoCloseableConnection implements AutoCloseable {
        private final HttpURLConnection connection;
        
        public AutoCloseableConnection(HttpURLConnection connection) {
            this.connection = connection;
        }
        
        @Override
        public void close() {
            if (connection != null) {
                connection.disconnect();
            }
        }
    }
}

// ✅ 正确：使用连接池并监控连接
@Service
public class ManagedApiService {
    private final RestTemplate restTemplate;
    private final MeterRegistry meterRegistry;
    
    public ManagedApiService(RestTemplate restTemplate, MeterRegistry meterRegistry) {
        this.restTemplate = restTemplate;
        this.meterRegistry = meterRegistry;
    }
    
    public String callApi(String url) {
        Timer.Sample sample = Timer.start(meterRegistry);
        try {
            String result = restTemplate.getForObject(url, String.class);
            meterRegistry.counter("api.calls", "status", "success").increment();
            return result;
        } catch (Exception e) {
            meterRegistry.counter("api.calls", "status", "error").increment();
            throw e;
        } finally {
            sample.stop(Timer.builder("api.call.duration")
                .description("API调用耗时")
                .register(meterRegistry));
        }
    }
    
    // ✅ 正确：批量处理时复用连接
    public List<String> batchCallApi(List<String> urls) {
        return urls.stream()
            .map(url -> {
                try {
                    return callApi(url);
                } catch (Exception e) {
                    log.warn("API调用失败: {}", url, e);
                    return null;
                }
            })
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }
}

// ✅ 正确：数据库连接正确管理
@Repository
public class ProperDataAccess {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // 使用JdbcTemplate自动管理连接
    public List<User> getUsers() {
        return jdbcTemplate.query(
            "SELECT * FROM users",
            (rs, rowNum) -> mapUser(rs)
        );
    }
    
    // 如果必须手动管理连接，使用try-with-resources
    public List<User> getUsersWithManualConnection() {
        String sql = "SELECT * FROM users";
        
        try (Connection conn = jdbcTemplate.getDataSource().getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            
            List<User> users = new ArrayList<>();
            while (rs.next()) {
                users.add(mapUser(rs));
            }
            return users;
        } catch (SQLException e) {
            throw new RuntimeException("数据库查询失败", e);
        }
    }
    
    private User mapUser(ResultSet rs) throws SQLException {
        User user = new User();
        user.setId(rs.getLong("id"));
        user.setName(rs.getString("name"));
        return user;
    }
}

// ✅ 正确：连接池健康检查
@Component
public class ConnectionPoolHealthIndicator implements HealthIndicator {
    
    private final PoolingHttpClientConnectionManager connectionManager;
    
    public ConnectionPoolHealthIndicator(PoolingHttpClientConnectionManager connectionManager) {
        this.connectionManager = connectionManager;
    }
    
    @Override
    public Health health() {
        try {
            PoolStats totalStats = connectionManager.getTotalStats();
            
            Health.Builder builder = Health.up()
                .withDetail("maxTotal", totalStats.getMax())
                .withDetail("available", totalStats.getAvailable())
                .withDetail("leased", totalStats.getLeased())
                .withDetail("pending", totalStats.getPending());
            
            // 检查连接池是否健康
            if (totalStats.getLeased() > totalStats.getMax() * 0.8) {
                builder.status(Status.DOWN)
                    .withDetail("reason", "连接池使用率过高");
            }
            
            return builder.build();
        } catch (Exception e) {
            return Health.down(e).build();
        }
    }
}
```

**第三十二条** Redis连接池检查 🟡：

##### 4.8.4 Redis资源管理检查

#### 4.8.4.1 Redis连接池配置 🟡:

##### 4.8.4.1.1 Redis连接池参数配置

**1. 检测目标**

a. 最大连接数设置是否合理（根据 Redis 服务器配置，通常 8-32）
b. 最大空闲连接设置是否合理（最大连接数的 50%-80%）
c. 连接超时设置是否合理（3-10 秒）
d. 连接池配置是否包含重试机制
e. 是否有连接池监控和健康检查

**2. 检测方法**

a. 配置文件审查：检查 Redis 连接池相关配置
b. 代码审查：检查 Redis 连接池创建和使用的代码
c. 运行时监控：监控 Redis 连接数和使用情况
d. 压力测试：验证连接池在高负载下的表现

**3. 错误示例**

```java
// ❌ 错误：连接池配置不合理
@Configuration
public class BadRedisConfig {
    @Bean
    public JedisConnectionFactory redisConnectionFactory() {
        JedisConnectionFactory factory = new JedisConnectionFactory();
        
        // 连接数设置过小，可能导致资源不足
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(3);  // 太小
        poolConfig.setMaxIdle(1);   // 太小
        poolConfig.setMinIdle(0);   // 没有保持最小连接数
        
        // 超时设置不合理
        poolConfig.setMaxWaitMillis(500); // 等待时间太短
        
        factory.setPoolConfig(poolConfig);
        return factory;
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：连接池参数配置合理
@Configuration
public class RedisConfig {
    @Bean
    public JedisConnectionFactory redisConnectionFactory() {
        JedisConnectionFactory factory = new JedisConnectionFactory();
        
        // 合理设置连接池参数
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(16);  // 合理的连接数
        poolConfig.setMaxIdle(12);   // 最大连接数的75%
        poolConfig.setMinIdle(4);    // 保持最小连接数
        
        // 合理的超时设置
        poolConfig.setMaxWaitMillis(5000);  // 5秒等待时间
        poolConfig.setTestOnBorrow(true);   // 获取连接前测试
        poolConfig.setTestWhileIdle(true);  // 空闲时测试连接
        
        factory.setPoolConfig(poolConfig);
        return factory;
    }
    
    // 添加连接池监控
    @Bean
    public HealthIndicator redisHealthIndicator(RedisConnectionFactory connectionFactory) {
        return new RedisHealthIndicator(connectionFactory);
    }
}
```

#### 4.8.4.2 Redis键值操作规范 🟡:

##### 4.8.4.2.1 键值过期设置

**1. 检测目标**

a. 所有 key 是否设置了合理的过期时间
b. 是否根据业务需求区分不同的过期策略
c. 是否有防止缓存穿透的机制
d. 是否有缓存更新和失效策略

**2. 检测方法**

a. 代码审查：检查 Redis 操作相关代码中的过期时间设置
b. 运行时检查：使用 TTL 命令检查 key 的过期时间
c. 日志分析：分析缓存命中率和失效情况
d. 监控审查：监控无过期时间的 key 数量

**3. 错误示例**

```java
// ❌ 错误：没有设置过期时间
@Service
public class BadCacheService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void cacheUser(String userId, User user) {
        redisTemplate.opsForValue().set("user:" + userId, user); // 没有过期时间
    }
    
    // 缓存结果没有过期策略
    public List<Product> getProducts(String category) {
        String key = "products:" + category;
        if (redisTemplate.hasKey(key)) {
            return (List<Product>) redisTemplate.opsForValue().get(key);
        }
        
        List<Product> products = productService.findByCategory(category);
        // 没有过期时间，数据可能永远不更新
        redisTemplate.opsForValue().set(key, products);
        return products;
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：设置合理的过期时间
@Service
public class CacheService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 定义不同类型数据的过期时间常量
    private static final Duration USER_CACHE_TTL = Duration.ofHours(1);
    private static final Duration PRODUCT_CACHE_TTL = Duration.ofMinutes(30);
    private static final Duration NULL_VALUE_TTL = Duration.ofMinutes(5);
    
    public void cacheUser(String userId, User user) {
        // 设置合理的过期时间
        redisTemplate.opsForValue().set(
            "user:" + userId, 
            user, 
            USER_CACHE_TTL
        );
    }
    
    // 处理缓存穿透和过期策略
    public List<Product> getProducts(String category) {
        String key = "products:" + category;
        if (redisTemplate.hasKey(key)) {
            return (List<Product>) redisTemplate.opsForValue().get(key);
        }
        
        List<Product> products = productService.findByCategory(category);
        
        // 即使查询结果为空也缓存，但过期时间较短，防止缓存穿透
        if (products == null || products.isEmpty()) {
            redisTemplate.opsForValue().set(key, Collections.emptyList(), NULL_VALUE_TTL);
        } else {
            redisTemplate.opsForValue().set(key, products, PRODUCT_CACHE_TTL);
        }
        
        return products;
    }
    
    // 缓存更新策略
    public void updateProduct(Product product) {
        // 先更新数据库
        productService.update(product);
        
        // 再更新或删除缓存
        String key = "products:" + product.getCategory();
        // 方案1: 直接删除缓存，下次查询时重建
        redisTemplate.delete(key);
        
        // 方案2: 更新缓存（适用于频繁读取的场景）
        // List<Product> products = getProductsFromCache(product.getCategory());
        // updateProductInList(products, product);
        // redisTemplate.opsForValue().set(key, products, PRODUCT_CACHE_TTL);
    }
}
```

#### 4.8.4.3 Redis命令使用安全 🟡:

##### 4.8.4.3.1 避免危险命令

**1. 检测目标**

a. 是否使用了高风险命令（KEYS、FLUSHALL、FLUSHDB等）
b. 是否限制了 Redis 命令执行权限
c. 是否有命令审计和监控
d. 生产环境是否禁用了危险命令

**2. 检测方法**

a. 代码审查：检查是否直接调用危险命令
b. 配置审查：检查 Redis 命令禁用配置
c. 日志分析：分析 Redis 命令执行记录
d. 安全扫描：使用工具扫描危险命令使用

**3. 错误示例**

```java
// ❌ 错误：使用危险命令
@Service
public class DangerousRedisService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 使用 KEYS 命令，在数据量大时会阻塞Redis
    public Set<String> getAllUserKeys() {
        return redisTemplate.keys("user:*");
    }
    
    // 清空所有数据，非常危险
    public void clearAllData() {
        redisTemplate.execute((RedisCallback<Object>) connection -> {
            connection.flushAll();
            return null;
        });
    }
    
    // 直接执行脚本，没有安全检查
    public void executeArbitraryCommand(String command) {
        redisTemplate.execute((RedisCallback<Object>) connection -> {
            connection.execute(command);
            return null;
        });
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：安全使用 Redis 命令
@Service
public class SafeRedisService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    private final MeterRegistry meterRegistry;
    
    // 使用 SCAN 代替 KEYS
    public Set<String> getUserKeys(String pattern) {
        Set<String> keys = new HashSet<>();
        ScanOptions options = ScanOptions.scanOptions()
            .match(pattern)
            .count(100)
            .build();
        
        // 记录命令执行
        Timer.Sample sample = Timer.start(meterRegistry);
        try {
            Cursor<String> cursor = redisTemplate.scan(options);
            while (cursor.hasNext()) {
                keys.add(cursor.next());
            }
            return keys;
        } finally {
            sample.stop(Timer.builder("redis.command.scan")
                .description("Redis SCAN command execution time")
                .register(meterRegistry));
        }
    }
    
    // 安全的数据清理方法，限制范围
    public void clearUserData(String userId) {
        String keyPattern = "user:" + userId + ":*";
        Set<String> keys = getUserKeys(keyPattern);
        if (!keys.isEmpty()) {
            redisTemplate.delete(keys);
            log.info("Cleared {} keys for user: {}", keys.size(), userId);
        }
    }
    
    // 使用权限检查和审计日志
    @PreAuthorize("hasRole('ADMIN')")
    public void executeAdminCommand(String command, String params) {
        if (isCommandBlacklisted(command)) {
            log.warn("Attempted to execute blacklisted command: {}", command);
            throw new SecurityException("Command not allowed: " + command);
        }
        
        log.info("Admin executing Redis command: {} with params: {}", command, params);
        // 执行安全检查过的命令...
    }
    
    private boolean isCommandBlacklisted(String command) {
        List<String> blacklist = Arrays.asList("FLUSHALL", "FLUSHDB", "KEYS", "CONFIG");
        return blacklist.contains(command.toUpperCase());
    }
}
```

#### 4.8.4.4 Redis性能优化 🟡:

##### 4.8.4.4.1 批量操作优化

**1. 检测目标**

a. 大批量操作是否使用 pipeline 或批量命令
b. 是否避免循环中单个执行 Redis 命令
c. 是否合理使用 Redis 事务
d. 批量操作是否考虑内存和网络影响

**2. 检测方法**

a. 代码审查：检查批量操作实现方式
b. 性能测试：对比不同实现的性能差异
c. 监控分析：监控 Redis 命令执行频率和耗时
d. 负载测试：验证高负载下的批量操作效率

**3. 错误示例**

```java
// ❌ 错误：循环中单个执行命令，性能差
@Service
public class InefficientBatchService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 在循环中单个执行命令
    public void cacheUserList(List<User> users) {
        for (User user : users) {
            String key = "user:" + user.getId();
            // 每个用户单独发送一次网络请求
            redisTemplate.opsForValue().set(key, user, Duration.ofHours(1));
        }
    }
    
    // 循环获取多个键值
    public List<User> getMultipleUsers(List<String> userIds) {
        List<User> result = new ArrayList<>();
        for (String userId : userIds) {
            // 每次查询发送一次网络请求
            User user = (User) redisTemplate.opsForValue().get("user:" + userId);
            if (user != null) {
                result.add(user);
            }
        }
        return result;
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：使用 pipeline 和批量命令优化性能
@Service
public class EfficientBatchService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 使用 pipeline 批量缓存
    public void cacheUserList(List<User> users) {
        redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
            for (User user : users) {
                byte[] key = redisTemplate.getStringSerializer()
                    .serialize("user:" + user.getId());
                byte[] value = redisTemplate.getValueSerializer().serialize(user);
                
                // 在一次网络往返中执行多个命令
                connection.set(key, value, Expiration.from(1, TimeUnit.HOURS), null);
            }
            return null;
        });
    }
    
    // 使用 MGET 批量获取
    public List<User> getMultipleUsers(List<String> userIds) {
        List<String> keys = userIds.stream()
            .map(id -> "user:" + id)
            .collect(Collectors.toList());
        
        // 一次网络请求获取多个键值
        List<Object> values = redisTemplate.opsForValue().multiGet(keys);
        
        List<User> result = new ArrayList<>();
        if (values != null) {
            for (Object value : values) {
                if (value != null) {
                    result.add((User) value);
                }
            }
        }
        return result;
    }
    
    // 使用 Redis 事务
    public void updateUserDataInTransaction(String userId, User user, List<String> roles) {
        redisTemplate.execute(new SessionCallback<Object>() {
            @Override
            public Object execute(RedisOperations operations) {
                operations.multi();
                
                operations.opsForValue().set("user:" + userId, user, Duration.ofHours(1));
                operations.opsForList().rightPushAll("user:" + userId + ":roles", roles);
                
                return operations.exec();
            }
        });
    }
    
    // 分批处理大量数据，避免内存压力
    public void processBulkData(List<String> allItems) {
        int batchSize = 1000;
        
        for (int i = 0; i < allItems.size(); i += batchSize) {
            int endIndex = Math.min(i + batchSize, allItems.size());
            List<String> batch = allItems.subList(i, endIndex);
            
            // 处理当前批次
            processBatch(batch);
        }
    }
    
    private void processBatch(List<String> items) {
        // 使用pipeline处理批次数据
        redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
            for (String item : items) {
                // 批量处理逻辑
            }
            return null;
        });
    }
}
```