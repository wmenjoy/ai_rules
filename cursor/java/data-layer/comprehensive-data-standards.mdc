# ç»¼åˆæ•°æ®å±‚å¼€å‘è§„èŒƒ
> æ¶µç›–SQLã€MySQLã€Redisçš„ä¼ä¸šçº§æ•°æ®å¤„ç†æ ‡å‡†

## ğŸ¯ æ•°æ®å±‚æ¶æ„åŸåˆ™

### åˆ†å±‚èŒè´£å®šä¹‰ [MUST - L1]
- **Entityå±‚**ï¼šæ•°æ®æ¨¡å‹å®šä¹‰ï¼Œå­—æ®µæ˜ å°„ï¼Œå…³ç³»ç»´æŠ¤
- **Repositoryå±‚**ï¼šæ•°æ®è®¿é—®æŠ½è±¡ï¼ŒæŸ¥è¯¢å°è£…ï¼Œäº‹åŠ¡è¾¹ç•Œ
- **Cacheå±‚**ï¼šç¼“å­˜ç­–ç•¥ï¼Œæ•°æ®ä¸€è‡´æ€§ï¼Œè¿‡æœŸç®¡ç†
- **Databaseå±‚**ï¼šè¡¨ç»“æ„è®¾è®¡ï¼Œç´¢å¼•ä¼˜åŒ–ï¼Œæ•°æ®çº¦æŸ

## ğŸ”§ Entityè®¾è®¡è§„èŒƒ

### JPA Entityæ ‡å‡† [MUST - L1]
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: æ•°æ®å±‚è§„èŒƒ v1.0
@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_users_email", columnList = "email", unique = true),
    @Index(name = "idx_users_status_create_time", columnList = "status,create_time"),
    @Index(name = "idx_users_update_time", columnList = "update_time")
})
@EntityListeners(AuditingEntityListener.class)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class User {
    
    /**
     * ä¸»é”®ID - ä½¿ç”¨é›ªèŠ±ç®—æ³•ç”Ÿæˆ
     */
    @Id
    @EqualsAndHashCode.Include
    private Long id;
    
    /**
     * ç”¨æˆ·å - ä¸šåŠ¡å”¯ä¸€æ ‡è¯†
     */
    @Column(name = "username", length = 50, nullable = false, unique = true)
    @Size(min = 3, max = 50)
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿")
    private String username;
    
    /**
     * é‚®ç®± - è”ç³»æ–¹å¼
     */
    @Column(name = "email", length = 100, nullable = false, unique = true)
    @Email(message = "é‚®ç®±æ ¼å¼æ— æ•ˆ")
    private String email;
    
    /**
     * æ‰‹æœºå· - å¯é€‰è”ç³»æ–¹å¼
     */
    @Column(name = "phone", length = 20)
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "æ‰‹æœºå·æ ¼å¼æ— æ•ˆ")
    private String phone;
    
    /**
     * å¯†ç å“ˆå¸Œ - å®‰å…¨å­˜å‚¨
     */
    @Column(name = "password_hash", length = 255, nullable = false)
    @JsonIgnore  // é˜²æ­¢åºåˆ—åŒ–æ³„éœ²
    private String passwordHash;
    
    /**
     * ç”¨æˆ·çŠ¶æ€ - æšä¸¾ç±»å‹
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", length = 20, nullable = false)
    private UserStatus status;
    
    /**
     * ç”¨æˆ·è§’è‰² - å¤šå¯¹å¤šå…³ç³»
     */
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    @JsonIgnore  // é¿å…å¾ªç¯å¼•ç”¨
    private Set<Role> roles = new HashSet<>();
    
    /**
     * ç”¨æˆ·é…ç½® - ä¸€å¯¹ä¸€å…³ç³»
     */
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private UserProfile profile;
    
    /**
     * ç”¨æˆ·è®¢å• - ä¸€å¯¹å¤šå…³ç³»
     */
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private List<Order> orders = new ArrayList<>();
    
    /**
     * åˆ›å»ºæ—¶é—´ - è‡ªåŠ¨å®¡è®¡
     */
    @CreatedDate
    @Column(name = "create_time", nullable = false, updatable = false)
    private LocalDateTime createTime;
    
    /**
     * æ›´æ–°æ—¶é—´ - è‡ªåŠ¨å®¡è®¡
     */
    @LastModifiedDate
    @Column(name = "update_time", nullable = false)
    private LocalDateTime updateTime;
    
    /**
     * åˆ›å»ºäºº - è‡ªåŠ¨å®¡è®¡
     */
    @CreatedBy
    @Column(name = "created_by", length = 50, updatable = false)
    private String createdBy;
    
    /**
     * æ›´æ–°äºº - è‡ªåŠ¨å®¡è®¡
     */
    @LastModifiedBy
    @Column(name = "updated_by", length = 50)
    private String updatedBy;
    
    /**
     * ç‰ˆæœ¬å· - ä¹è§‚é”
     */
    @Version
    @Column(name = "version")
    private Long version;
    
    /**
     * è½¯åˆ é™¤æ ‡è®°
     */
    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private Boolean deleted = false;
    
    /**
     * ä¸šåŠ¡æ–¹æ³• - å°è£…ä¸šåŠ¡é€»è¾‘
     */
    public void activate() {
        this.status = UserStatus.ACTIVE;
    }
    
    public void deactivate() {
        this.status = UserStatus.INACTIVE;
    }
    
    public boolean isActive() {
        return UserStatus.ACTIVE.equals(this.status);
    }
    
    public void addRole(Role role) {
        this.roles.add(role);
        role.getUsers().add(this);
    }
    
    public void removeRole(Role role) {
        this.roles.remove(role);
        role.getUsers().remove(this);
    }
}

/**
 * ç”¨æˆ·çŠ¶æ€æšä¸¾
 */
public enum UserStatus {
    PENDING("å¾…æ¿€æ´»"),
    ACTIVE("å·²æ¿€æ´»"), 
    INACTIVE("å·²ç¦ç”¨"),
    LOCKED("å·²é”å®š"),
    DELETED("å·²åˆ é™¤");
    
    private final String description;
    
    UserStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
// [AI-BLOCK-END]
```

## ğŸ”§ SQLç¼–å†™è§„èŒƒ

### æŸ¥è¯¢ä¼˜åŒ–æ ‡å‡† [MUST - L1]
```sql
-- [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: SQLè§„èŒƒ v1.0

-- âœ… æ­£ç¡®çš„SELECTæŸ¥è¯¢
-- 1. æ˜ç¡®æŒ‡å®šå­—æ®µï¼Œé¿å…SELECT *
-- 2. ä½¿ç”¨åˆ«åæé«˜å¯è¯»æ€§
-- 3. åˆç†ä½¿ç”¨ç´¢å¼•å­—æ®µè¿›è¡Œè¿‡æ»¤
SELECT 
    u.id,
    u.username,
    u.email,
    u.status,
    u.create_time,
    p.avatar,
    p.nickname
FROM users u
LEFT JOIN user_profiles p ON u.id = p.user_id
WHERE u.status = 'ACTIVE'
  AND u.create_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
  AND u.deleted = FALSE
ORDER BY u.create_time DESC
LIMIT 20 OFFSET 0;

-- âœ… å¤æ‚å…³è”æŸ¥è¯¢ä¼˜åŒ–
-- 1. ä¼˜å…ˆä½¿ç”¨å†…è¿æ¥
-- 2. å°†è¿‡æ»¤æ¡ä»¶å‰ç½®
-- 3. åˆç†ä½¿ç”¨å­æŸ¥è¯¢
SELECT 
    u.id,
    u.username,
    u.email,
    COUNT(o.id) AS order_count,
    SUM(o.total_amount) AS total_spent
FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE u.status = 'ACTIVE'
  AND o.status IN ('COMPLETED', 'SHIPPED')
  AND o.create_time >= DATE_SUB(NOW(), INTERVAL 1 YEAR)
GROUP BY u.id, u.username, u.email
HAVING COUNT(o.id) >= 5
ORDER BY total_spent DESC
LIMIT 100;

-- âœ… åˆ†é¡µæŸ¥è¯¢ä¼˜åŒ–
-- ä½¿ç”¨è¦†ç›–ç´¢å¼•é¿å…å›è¡¨
SELECT u.*
FROM users u
INNER JOIN (
    SELECT id 
    FROM users 
    WHERE status = 'ACTIVE' 
      AND deleted = FALSE
    ORDER BY create_time DESC
    LIMIT 20 OFFSET 1000
) temp ON u.id = temp.id
ORDER BY u.create_time DESC;

-- âœ… æ›´æ–°æ“ä½œè§„èŒƒ
-- 1. ä½¿ç”¨WHEREæ¡ä»¶é˜²æ­¢è¯¯æ“ä½œ
-- 2. æ›´æ–°ç‰ˆæœ¬å·å®ç°ä¹è§‚é”
-- 3. è®°å½•æ“ä½œæ—¶é—´å’Œæ“ä½œäºº
UPDATE users 
SET 
    status = 'INACTIVE',
    update_time = NOW(),
    updated_by = 'admin',
    version = version + 1
WHERE id = 12345 
  AND version = 1
  AND deleted = FALSE;

-- âœ… åˆ é™¤æ“ä½œè§„èŒƒ
-- ä¼˜å…ˆä½¿ç”¨è½¯åˆ é™¤
UPDATE users 
SET 
    deleted = TRUE,
    status = 'DELETED',
    update_time = NOW(),
    updated_by = 'system'
WHERE id IN (12345, 12346, 12347)
  AND deleted = FALSE;

-- âœ… æ‰¹é‡æ’å…¥ä¼˜åŒ–
INSERT INTO user_login_logs (
    user_id, 
    login_time, 
    ip_address, 
    user_agent,
    create_time
) VALUES 
(1001, '2023-12-01 10:00:00', '192.168.1.100', 'Chrome/119.0', NOW()),
(1002, '2023-12-01 10:01:00', '192.168.1.101', 'Firefox/118.0', NOW()),
(1003, '2023-12-01 10:02:00', '192.168.1.102', 'Safari/17.0', NOW());

-- [AI-BLOCK-END]
```

### ç´¢å¼•è®¾è®¡è§„èŒƒ [MUST - L1]
```sql
-- [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: SQLè§„èŒƒ v1.0

-- âœ… ä¸»é”®ç´¢å¼•è®¾è®¡
-- ä½¿ç”¨BIGINTç±»å‹ï¼Œæ”¯æŒå¤§æ•°æ®é‡
ALTER TABLE users 
ADD PRIMARY KEY (id);

-- âœ… å”¯ä¸€ç´¢å¼•è®¾è®¡
-- ä¸šåŠ¡å”¯ä¸€æ€§çº¦æŸ
CREATE UNIQUE INDEX uk_users_username ON users(username);
CREATE UNIQUE INDEX uk_users_email ON users(email);

-- âœ… æ™®é€šç´¢å¼•è®¾è®¡
-- 1. é«˜é¢‘æŸ¥è¯¢å­—æ®µå»ºç«‹ç´¢å¼•
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_create_time ON users(create_time);

-- 2. å¤åˆç´¢å¼•è®¾è®¡ - éµå¾ªæœ€å·¦å‰ç¼€åŸåˆ™
-- çŠ¶æ€ + åˆ›å»ºæ—¶é—´ï¼ˆçŠ¶æ€è¿‡æ»¤ + æ—¶é—´æ’åºåœºæ™¯ï¼‰
CREATE INDEX idx_users_status_create_time ON users(status, create_time);

-- 3. è¦†ç›–ç´¢å¼•è®¾è®¡ - é¿å…å›è¡¨æŸ¥è¯¢
-- ç”¨æˆ·åˆ—è¡¨æŸ¥è¯¢è¦†ç›–ç´¢å¼•
CREATE INDEX idx_users_list_query ON users(status, deleted, id, username, email, create_time);

-- âœ… å‡½æ•°ç´¢å¼•è®¾è®¡ï¼ˆMySQL 8.0+ï¼‰
-- æ”¯æŒè¡¨è¾¾å¼æŸ¥è¯¢
CREATE INDEX idx_users_email_domain ON users((SUBSTRING_INDEX(email, '@', -1)));

-- âœ… åˆ†åŒºè¡¨ç´¢å¼•è®¾è®¡
-- æŒ‰æœˆåˆ†åŒºçš„è®¢å•è¡¨
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    create_time DATETIME NOT NULL,
    INDEX idx_orders_user_id (user_id),
    INDEX idx_orders_status (status),
    INDEX idx_orders_create_time (create_time)
) PARTITION BY RANGE (YEAR(create_time) * 100 + MONTH(create_time)) (
    PARTITION p202301 VALUES LESS THAN (202302),
    PARTITION p202302 VALUES LESS THAN (202303),
    PARTITION p202303 VALUES LESS THAN (202304),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- âœ… ç´¢å¼•ç»´æŠ¤SQL
-- æŸ¥çœ‹ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    NULLABLE,
    INDEX_TYPE
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'your_database'
  AND TABLE_NAME = 'users'
ORDER BY TABLE_NAME, SEQ_IN_INDEX;

-- åˆ†æç´¢å¼•æ•ˆç‡
EXPLAIN SELECT * FROM users 
WHERE status = 'ACTIVE' 
  AND create_time >= '2023-12-01'
ORDER BY create_time DESC
LIMIT 20;

-- [AI-BLOCK-END]
```

## ğŸ”§ Redisç¼“å­˜è§„èŒƒ

### Keyå‘½åè§„èŒƒ [MUST - L1]
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Redisè§„èŒƒ v1.0

/**
 * Redis Keyå‘½åå·¥å…·ç±»
 */
@Component
public class RedisKeyBuilder {
    
    // Keyå‰ç¼€å¸¸é‡
    private static final String APP_PREFIX = "myapp";
    private static final String SEPARATOR = ":";
    
    // ä¸šåŠ¡æ¨¡å—å‰ç¼€
    public static final String USER_MODULE = "user";
    public static final String ORDER_MODULE = "order";
    public static final String PRODUCT_MODULE = "product";
    
    // æ•°æ®ç±»å‹åç¼€
    public static final String CACHE_SUFFIX = "cache";
    public static final String LOCK_SUFFIX = "lock";
    public static final String COUNTER_SUFFIX = "counter";
    public static final String LIST_SUFFIX = "list";
    public static final String SET_SUFFIX = "set";
    
    /**
     * æ„å»ºç”¨æˆ·ç¼“å­˜Key
     * æ ¼å¼: myapp:user:cache:userId
     */
    public static String buildUserCacheKey(Long userId) {
        return String.join(SEPARATOR, APP_PREFIX, USER_MODULE, CACHE_SUFFIX, String.valueOf(userId));
    }
    
    /**
     * æ„å»ºç”¨æˆ·åˆ†å¸ƒå¼é”Key
     * æ ¼å¼: myapp:user:lock:userId
     */
    public static String buildUserLockKey(Long userId) {
        return String.join(SEPARATOR, APP_PREFIX, USER_MODULE, LOCK_SUFFIX, String.valueOf(userId));
    }
    
    /**
     * æ„å»ºè®¢å•ç¼“å­˜Key
     * æ ¼å¼: myapp:order:cache:orderId
     */
    public static String buildOrderCacheKey(String orderId) {
        return String.join(SEPARATOR, APP_PREFIX, ORDER_MODULE, CACHE_SUFFIX, orderId);
    }
    
    /**
     * æ„å»ºç”¨æˆ·è®¢å•åˆ—è¡¨Key
     * æ ¼å¼: myapp:user:order:list:userId
     */
    public static String buildUserOrderListKey(Long userId) {
        return String.join(SEPARATOR, APP_PREFIX, USER_MODULE, ORDER_MODULE, LIST_SUFFIX, String.valueOf(userId));
    }
    
    /**
     * æ„å»ºè®¡æ•°å™¨Key
     * æ ¼å¼: myapp:module:counter:type:date
     */
    public static String buildCounterKey(String module, String type, String date) {
        return String.join(SEPARATOR, APP_PREFIX, module, COUNTER_SUFFIX, type, date);
    }
    
    /**
     * æ„å»ºä¼šè¯Key
     * æ ¼å¼: myapp:session:sessionId
     */
    public static String buildSessionKey(String sessionId) {
        return String.join(SEPARATOR, APP_PREFIX, "session", sessionId);
    }
    
    /**
     * æ„å»ºéªŒè¯ç Key
     * æ ¼å¼: myapp:captcha:type:target
     */
    public static String buildCaptchaKey(String type, String target) {
        return String.join(SEPARATOR, APP_PREFIX, "captcha", type, target);
    }
}

/**
 * Redisæ“ä½œæœåŠ¡
 */
@Service
@Slf4j
public class RedisService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final StringRedisTemplate stringRedisTemplate;
    
    public RedisService(RedisTemplate<String, Object> redisTemplate,
                       StringRedisTemplate stringRedisTemplate) {
        this.redisTemplate = redisTemplate;
        this.stringRedisTemplate = stringRedisTemplate;
    }
    
    /**
     * è®¾ç½®ç¼“å­˜ - å¸¦è¿‡æœŸæ—¶é—´
     */
    public void setCache(String key, Object value, Duration timeout) {
        try {
            redisTemplate.opsForValue().set(key, value, timeout);
            log.debug("Set cache: key={}, timeout={}", key, timeout);
        } catch (Exception e) {
            log.error("Failed to set cache: key={}", key, e);
        }
    }
    
    /**
     * è·å–ç¼“å­˜
     */
    public <T> T getCache(String key, Class<T> clazz) {
        try {
            Object value = redisTemplate.opsForValue().get(key);
            if (value != null && clazz.isInstance(value)) {
                return clazz.cast(value);
            }
            return null;
        } catch (Exception e) {
            log.error("Failed to get cache: key={}", key, e);
            return null;
        }
    }
    
    /**
     * åˆ é™¤ç¼“å­˜
     */
    public void deleteCache(String key) {
        try {
            redisTemplate.delete(key);
            log.debug("Deleted cache: key={}", key);
        } catch (Exception e) {
            log.error("Failed to delete cache: key={}", key, e);
        }
    }
    
    /**
     * æ‰¹é‡åˆ é™¤ç¼“å­˜ - æŒ‰æ¨¡å¼åŒ¹é…
     */
    public void deleteCacheByPattern(String pattern) {
        try {
            Set<String> keys = redisTemplate.keys(pattern);
            if (keys != null && !keys.isEmpty()) {
                redisTemplate.delete(keys);
                log.debug("Deleted cache by pattern: pattern={}, count={}", pattern, keys.size());
            }
        } catch (Exception e) {
            log.error("Failed to delete cache by pattern: pattern={}", pattern, e);
        }
    }
    
    /**
     * è®¾ç½®åˆ†å¸ƒå¼é”
     */
    public boolean setLock(String lockKey, String value, Duration timeout) {
        try {
            Boolean result = stringRedisTemplate.opsForValue()
                .setIfAbsent(lockKey, value, timeout);
            return Boolean.TRUE.equals(result);
        } catch (Exception e) {
            log.error("Failed to set lock: lockKey={}", lockKey, e);
            return false;
        }
    }
    
    /**
     * é‡Šæ”¾åˆ†å¸ƒå¼é” - Luaè„šæœ¬ä¿è¯åŸå­æ€§
     */
    public boolean releaseLock(String lockKey, String value) {
        try {
            String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                           "return redis.call('del', KEYS[1]) " +
                           "else return 0 end";
            Long result = stringRedisTemplate.execute(
                new DefaultRedisScript<>(script, Long.class),
                Collections.singletonList(lockKey),
                value
            );
            return Long.valueOf(1).equals(result);
        } catch (Exception e) {
            log.error("Failed to release lock: lockKey={}", lockKey, e);
            return false;
        }
    }
    
    /**
     * è®¡æ•°å™¨é€’å¢
     */
    public Long increment(String key, long delta, Duration timeout) {
        try {
            Long result = stringRedisTemplate.opsForValue().increment(key, delta);
            if (timeout != null) {
                stringRedisTemplate.expire(key, timeout);
            }
            return result;
        } catch (Exception e) {
            log.error("Failed to increment: key={}", key, e);
            return null;
        }
    }
    
    /**
     * åˆ—è¡¨æ“ä½œ - å·¦æ¨å…¥
     */
    public void listLeftPush(String key, Object value, Duration timeout) {
        try {
            redisTemplate.opsForList().leftPush(key, value);
            if (timeout != null) {
                redisTemplate.expire(key, timeout);
            }
        } catch (Exception e) {
            log.error("Failed to left push list: key={}", key, e);
        }
    }
    
    /**
     * åˆ—è¡¨æ“ä½œ - èŒƒå›´è·å–
     */
    public List<Object> listRange(String key, long start, long end) {
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            log.error("Failed to get list range: key={}", key, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * é›†åˆæ“ä½œ - æ·»åŠ æˆå‘˜
     */
    public void setAdd(String key, Object... values) {
        try {
            redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            log.error("Failed to add set members: key={}", key, e);
        }
    }
    
    /**
     * æœ‰åºé›†åˆæ“ä½œ - æ·»åŠ æˆå‘˜
     */
    public void zsetAdd(String key, Object value, double score) {
        try {
            redisTemplate.opsForZSet().add(key, value, score);
        } catch (Exception e) {
            log.error("Failed to add zset member: key={}", key, e);
        }
    }
    
    /**
     * ç®¡é“æ“ä½œ - æ‰¹é‡æ‰§è¡Œ
     */
    public List<Object> executePipeline(List<Runnable> operations) {
        return redisTemplate.executePipelined(new SessionCallback<Object>() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {
                for (Runnable operation : operations) {
                    operation.run();
                }
                return null;
            }
        });
    }
}
// [AI-BLOCK-END]
```

### ç¼“å­˜ç­–ç•¥è§„èŒƒ [MUST - L1]
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Redisè§„èŒƒ v1.0

/**
 * ç¼“å­˜ç­–ç•¥å®ç°
 */
@Service
@Slf4j
public class UserCacheService {
    
    private final RedisService redisService;
    private final UserRepository userRepository;
    
    // ç¼“å­˜è¿‡æœŸæ—¶é—´é…ç½®
    private static final Duration USER_CACHE_TTL = Duration.ofHours(1);
    private static final Duration USER_LIST_CACHE_TTL = Duration.ofMinutes(30);
    private static final Duration USER_LOCK_TTL = Duration.ofSeconds(30);
    
    public UserCacheService(RedisService redisService, UserRepository userRepository) {
        this.redisService = redisService;
        this.userRepository = userRepository;
    }
    
    /**
     * Cache-Asideæ¨¡å¼ - è·å–ç”¨æˆ·
     */
    public User getUserById(Long userId) {
        String cacheKey = RedisKeyBuilder.buildUserCacheKey(userId);
        
        // 1. å…ˆæŸ¥ç¼“å­˜
        User cachedUser = redisService.getCache(cacheKey, User.class);
        if (cachedUser != null) {
            log.debug("Cache hit for user: {}", userId);
            return cachedUser;
        }
        
        // 2. ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥æ•°æ®åº“
        log.debug("Cache miss for user: {}", userId);
        User user = userRepository.findById(userId).orElse(null);
        
        // 3. å†™å…¥ç¼“å­˜ï¼ˆå³ä½¿æ˜¯nullä¹Ÿè¦ç¼“å­˜ï¼Œé˜²æ­¢ç¼“å­˜ç©¿é€ï¼‰
        if (user != null) {
            redisService.setCache(cacheKey, user, USER_CACHE_TTL);
        } else {
            // ç©ºå€¼ç¼“å­˜ï¼Œè¾ƒçŸ­è¿‡æœŸæ—¶é—´
            redisService.setCache(cacheKey, new NullUser(), Duration.ofMinutes(5));
        }
        
        return user;
    }
    
    /**
     * Write-Throughæ¨¡å¼ - æ›´æ–°ç”¨æˆ·
     */
    @Transactional
    public User updateUser(Long userId, User updatedUser) {
        String cacheKey = RedisKeyBuilder.buildUserCacheKey(userId);
        String lockKey = RedisKeyBuilder.buildUserLockKey(userId);
        String lockValue = UUID.randomUUID().toString();
        
        // 1. è·å–åˆ†å¸ƒå¼é”
        if (!redisService.setLock(lockKey, lockValue, USER_LOCK_TTL)) {
            throw new BusinessException("ç”¨æˆ·æ­£åœ¨è¢«å…¶ä»–æ“ä½œä¿®æ”¹ï¼Œè¯·ç¨åé‡è¯•");
        }
        
        try {
            // 2. æ›´æ–°æ•°æ®åº“
            User savedUser = userRepository.save(updatedUser);
            
            // 3. æ›´æ–°ç¼“å­˜
            redisService.setCache(cacheKey, savedUser, USER_CACHE_TTL);
            
            // 4. æ¸…é™¤ç›¸å…³åˆ—è¡¨ç¼“å­˜
            invalidateUserListCaches(userId);
            
            return savedUser;
            
        } finally {
            // 5. é‡Šæ”¾é”
            redisService.releaseLock(lockKey, lockValue);
        }
    }
    
    /**
     * Write-Behindæ¨¡å¼ - å¼‚æ­¥å†™å…¥
     */
    @Async
    public void updateUserAsync(User user) {
        try {
            // å»¶è¿Ÿå†™å…¥æ•°æ®åº“
            Thread.sleep(100);
            userRepository.save(user);
            
            // æ›´æ–°ç¼“å­˜
            String cacheKey = RedisKeyBuilder.buildUserCacheKey(user.getId());
            redisService.setCache(cacheKey, user, USER_CACHE_TTL);
            
        } catch (Exception e) {
            log.error("Async user update failed: {}", user.getId(), e);
        }
    }
    
    /**
     * ç¼“å­˜é¢„çƒ­ - ç³»ç»Ÿå¯åŠ¨æ—¶é¢„åŠ è½½çƒ­ç‚¹æ•°æ®
     */
    @EventListener(ApplicationReadyEvent.class)
    public void warmupCache() {
        log.info("Starting cache warmup...");
        
        // é¢„åŠ è½½æ´»è·ƒç”¨æˆ·
        List<User> activeUsers = userRepository.findTop1000ByStatusOrderByUpdateTimeDesc(UserStatus.ACTIVE);
        
        for (User user : activeUsers) {
            String cacheKey = RedisKeyBuilder.buildUserCacheKey(user.getId());
            redisService.setCache(cacheKey, user, USER_CACHE_TTL);
        }
        
        log.info("Cache warmup completed, loaded {} users", activeUsers.size());
    }
    
    /**
     * å¤šçº§ç¼“å­˜ç­–ç•¥ - L1æœ¬åœ°ç¼“å­˜ + L2Redisç¼“å­˜
     */
    @Cacheable(value = "userCache", key = "#userId", unless = "#result == null")
    public User getUserWithLocalCache(Long userId) {
        // æœ¬åœ°ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢Redisç¼“å­˜
        return getUserById(userId);
    }
    
    /**
     * ç¼“å­˜æ›´æ–°ç­–ç•¥ - æ›´æ–°æœ¬åœ°å’ŒRedisç¼“å­˜
     */
    @CacheEvict(value = "userCache", key = "#userId")
    public void evictUserCache(Long userId) {
        String cacheKey = RedisKeyBuilder.buildUserCacheKey(userId);
        redisService.deleteCache(cacheKey);
    }
    
    /**
     * ç¼“å­˜ä¸€è‡´æ€§ä¿è¯ - äº‹åŠ¡åå¤„ç†
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleUserUpdated(UserUpdatedEvent event) {
        // äº‹åŠ¡æäº¤åæ¸…é™¤ç¼“å­˜ï¼Œä¿è¯ä¸€è‡´æ€§
        evictUserCache(event.getUserId());
        invalidateUserListCaches(event.getUserId());
    }
    
    /**
     * é˜²æ­¢ç¼“å­˜ç©¿é€ - å¸ƒéš†è¿‡æ»¤å™¨
     */
    public boolean userExists(Long userId) {
        // ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨å¿«é€Ÿåˆ¤æ–­ç”¨æˆ·æ˜¯å¦å­˜åœ¨
        String bloomKey = "user:bloom:filter";
        // ç®€åŒ–å®ç°ï¼Œå®é™…åº”ä½¿ç”¨Rediså¸ƒéš†è¿‡æ»¤å™¨æ¨¡å—
        return redisService.getCache(bloomKey + ":" + userId, Boolean.class) != null;
    }
    
    /**
     * é˜²æ­¢ç¼“å­˜é›ªå´© - éšæœºè¿‡æœŸæ—¶é—´
     */
    private Duration getRandomTtl(Duration baseTtl) {
        long baseSeconds = baseTtl.getSeconds();
        long randomSeconds = (long) (baseSeconds * 0.1 * Math.random()); // 10%éšæœºæ³¢åŠ¨
        return Duration.ofSeconds(baseSeconds + randomSeconds);
    }
    
    /**
     * æ¸…é™¤ç”¨æˆ·ç›¸å…³åˆ—è¡¨ç¼“å­˜
     */
    private void invalidateUserListCaches(Long userId) {
        // æ¸…é™¤ç”¨æˆ·è®¢å•åˆ—è¡¨ç¼“å­˜
        String orderListKey = RedisKeyBuilder.buildUserOrderListKey(userId);
        redisService.deleteCache(orderListKey);
        
        // æ¸…é™¤ç”¨æˆ·ç›¸å…³çš„å…¶ä»–åˆ—è¡¨ç¼“å­˜
        String pattern = "myapp:user:*:list:" + userId;
        redisService.deleteCacheByPattern(pattern);
    }
    
    /**
     * ç©ºå¯¹è±¡ï¼Œé˜²æ­¢ç¼“å­˜ç©¿é€
     */
    private static class NullUser {
        // æ ‡è®°å¯¹è±¡ï¼Œè¡¨ç¤ºæ•°æ®åº“ä¸­ä¸å­˜åœ¨è¯¥ç”¨æˆ·
    }
}

/**
 * Redisé…ç½®ç±»
 */
@Configuration
@EnableCaching
public class RedisConfig {
    
    /**
     * Redisè¿æ¥é…ç½®
     */
    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("localhost");
        config.setPort(6379);
        config.setDatabase(0);
        
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
            .commandTimeout(Duration.ofSeconds(5))
            .poolConfig(buildPoolConfig())
            .build();
            
        return new LettuceConnectionFactory(config, clientConfig);
    }
    
    /**
     * Redis Templateé…ç½®
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        // Keyåºåˆ—åŒ–
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        
        // Valueåºåˆ—åŒ– - ä½¿ç”¨Jackson
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(objectMapper);
        
        template.setValueSerializer(serializer);
        template.setHashValueSerializer(serializer);
        
        template.afterPropertiesSet();
        return template;
    }
    
    /**
     * è¿æ¥æ± é…ç½®
     */
    private GenericObjectPoolConfig buildPoolConfig() {
        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
        poolConfig.setMaxTotal(20);
        poolConfig.setMaxIdle(10);
        poolConfig.setMinIdle(5);
        poolConfig.setMaxWaitMillis(3000);
        poolConfig.setTestOnBorrow(true);
        poolConfig.setTestOnReturn(true);
        return poolConfig;
    }
    
    /**
     * ç¼“å­˜ç®¡ç†å™¨é…ç½®
     */
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .disableCachingNullValues()
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
            
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .build();
    }
}
// [AI-BLOCK-END]
```

---

*æ­¤ç»¼åˆæ•°æ®å±‚è§„èŒƒæ¶µç›–äº†Entityè®¾è®¡ã€SQLä¼˜åŒ–ã€Redisç¼“å­˜çš„ä¼ä¸šçº§æ ‡å‡†ï¼Œç¡®ä¿æ•°æ®å¤„ç†çš„é«˜æ€§èƒ½å’Œä¸€è‡´æ€§*
description:
globs:
alwaysApply: false
---
