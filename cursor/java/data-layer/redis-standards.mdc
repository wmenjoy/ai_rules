# Redisä½¿ç”¨è§„èŒƒ

## ğŸ¯ è§„èŒƒç›®æ ‡
- å»ºç«‹Redisä½¿ç”¨çš„ç»Ÿä¸€æ ‡å‡†å’Œæœ€ä½³å®è·µ
- ä¼˜åŒ–Redisæ€§èƒ½å’Œå†…å­˜ä½¿ç”¨æ•ˆç‡
- ç¡®ä¿Redisæ•°æ®çš„ä¸€è‡´æ€§å’Œå¯é æ€§
- æä¾›é«˜å¯ç”¨æ€§å’Œæ•…éšœæ¢å¤æ–¹æ¡ˆ

## ğŸ“‹ é”®å€¼è®¾è®¡è§„èŒƒ

### é”®å‘½åè§„èŒƒ

#### MUST - å¿…é¡»éµå®ˆ
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * Redisé”®å‘½åå·¥å…·ç±»
 */
@Component
public class RedisKeyBuilder {
    
    // âœ… æ ‡å‡†é”®å‘½åæ ¼å¼ï¼š{ä¸šåŠ¡æ¨¡å—}:{å®ä½“}:{æ ‡è¯†ç¬¦}:{å±æ€§}
    public static final String USER_INFO_KEY = "user:info:%s";
    public static final String USER_SESSION_KEY = "user:session:%s";
    public static final String PRODUCT_STOCK_KEY = "product:stock:%s";
    public static final String ORDER_LOCK_KEY = "order:lock:%s";
    public static final String CACHE_LIST_KEY = "cache:list:%s:%s";
    
    /**
     * æ„å»ºç”¨æˆ·ä¿¡æ¯ç¼“å­˜é”®
     */
    public static String buildUserInfoKey(Long userId) {
        return String.format(USER_INFO_KEY, userId);
    }
    
    /**
     * æ„å»ºç”¨æˆ·ä¼šè¯é”®
     */
    public static String buildUserSessionKey(String sessionId) {
        return String.format(USER_SESSION_KEY, sessionId);
    }
    
    /**
     * æ„å»ºäº§å“åº“å­˜é”®
     */
    public static String buildProductStockKey(Long productId) {
        return String.format(PRODUCT_STOCK_KEY, productId);
    }
    
    /**
     * æ„å»ºåˆ†å¸ƒå¼é”é”®
     */
    public static String buildOrderLockKey(Long orderId) {
        return String.format(ORDER_LOCK_KEY, orderId);
    }
    
    /**
     * æ„å»ºåˆ†é¡µç¼“å­˜é”®
     */
    public static String buildCacheListKey(String module, String queryHash) {
        return String.format(CACHE_LIST_KEY, module, queryHash);
    }
}
// [AI-BLOCK-END]
```

#### é”®å‘½ååŸåˆ™
```text
âœ… æ­£ç¡®ç¤ºä¾‹ï¼š
user:info:123456                    # ç”¨æˆ·ä¿¡æ¯
user:session:abc123def456           # ç”¨æˆ·ä¼šè¯
product:stock:789                   # äº§å“åº“å­˜
order:lock:order_123               # è®¢å•é”
cache:user:list:page_1_size_20     # ç”¨æˆ·åˆ—è¡¨ç¼“å­˜
config:system:mail_server          # ç³»ç»Ÿé…ç½®

âŒ é”™è¯¯ç¤ºä¾‹ï¼š
userInfo123                        # ç¼ºå°‘åˆ†éš”ç¬¦å’Œç»“æ„
User:Session:ABC123               # å¤§å°å†™ä¸ä¸€è‡´
product-stock-789                 # ä½¿ç”¨è¿å­—ç¬¦è€Œéå†’å·
cache_user_list                   # ä½¿ç”¨ä¸‹åˆ’çº¿è€Œéå†’å·
```

### é”®è¿‡æœŸç­–ç•¥
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * Redisè¿‡æœŸæ—¶é—´å¸¸é‡
 */
public class RedisExpireTime {
    
    // çŸ­æœŸç¼“å­˜ (1-10åˆ†é’Ÿ)
    public static final Duration VERY_SHORT = Duration.ofMinutes(1);    // éªŒè¯ç 
    public static final Duration SHORT = Duration.ofMinutes(5);         // çƒ­ç‚¹æ•°æ®
    public static final Duration MEDIUM_SHORT = Duration.ofMinutes(10); // æœç´¢ç»“æœ
    
    // ä¸­æœŸç¼“å­˜ (30åˆ†é’Ÿ-2å°æ—¶)
    public static final Duration MEDIUM = Duration.ofMinutes(30);       // ç”¨æˆ·ä¿¡æ¯
    public static final Duration MEDIUM_LONG = Duration.ofHours(1);     // é…ç½®ä¿¡æ¯
    public static final Duration LONG = Duration.ofHours(2);            // å•†å“ä¿¡æ¯
    
    // é•¿æœŸç¼“å­˜ (6-24å°æ—¶)
    public static final Duration VERY_LONG = Duration.ofHours(6);       // å­—å…¸æ•°æ®
    public static final Duration DAY = Duration.ofHours(24);            // ç»Ÿè®¡æ•°æ®
    
    // ä¼šè¯ç›¸å…³
    public static final Duration SESSION = Duration.ofMinutes(30);      // ç”¨æˆ·ä¼šè¯
    public static final Duration TOKEN = Duration.ofHours(2);           // è®¿é—®ä»¤ç‰Œ
    public static final Duration REFRESH_TOKEN = Duration.ofDays(7);    // åˆ·æ–°ä»¤ç‰Œ
}

/**
 * Redisç¼“å­˜ç®¡ç†æœåŠ¡
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisCacheManager {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * è®¾ç½®ç¼“å­˜å€¼ï¼Œå¸¦è¿‡æœŸæ—¶é—´
     */
    public void setWithExpire(String key, Object value, Duration expire) {
        try {
            redisTemplate.opsForValue().set(key, value, expire);
            log.debug("ç¼“å­˜è®¾ç½®æˆåŠŸ: key={}, expire={}", key, expire);
        } catch (Exception e) {
            log.error("ç¼“å­˜è®¾ç½®å¤±è´¥: key={}", key, e);
        }
    }
    
    /**
     * è®¾ç½®ç¼“å­˜å€¼ï¼Œå¦‚æœä¸å­˜åœ¨
     */
    public boolean setIfAbsent(String key, Object value, Duration expire) {
        try {
            Boolean result = redisTemplate.opsForValue().setIfAbsent(key, value, expire);
            log.debug("ç¼“å­˜æ¡ä»¶è®¾ç½®: key={}, success={}", key, result);
            return Boolean.TRUE.equals(result);
        } catch (Exception e) {
            log.error("ç¼“å­˜æ¡ä»¶è®¾ç½®å¤±è´¥: key={}", key, e);
            return false;
        }
    }
    
    /**
     * å»¶é•¿é”®çš„è¿‡æœŸæ—¶é—´
     */
    public boolean extendExpire(String key, Duration expire) {
        try {
            Boolean result = redisTemplate.expire(key, expire);
            log.debug("è¿‡æœŸæ—¶é—´å»¶é•¿: key={}, expire={}, success={}", key, expire, result);
            return Boolean.TRUE.equals(result);
        } catch (Exception e) {
            log.error("è¿‡æœŸæ—¶é—´å»¶é•¿å¤±è´¥: key={}", key, e);
            return false;
        }
    }
}
// [AI-BLOCK-END]
```

## ğŸ“‹ æ•°æ®ç»“æ„ä½¿ç”¨è§„èŒƒ

### Stringç±»å‹ä½¿ç”¨
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * Stringç±»å‹ä½¿ç”¨ç¤ºä¾‹
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisStringService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * âœ… ç®€å•å€¼ç¼“å­˜
     */
    public void cacheUserToken(String userId, String token) {
        String key = "user:token:" + userId;
        redisTemplate.opsForValue().set(key, token, RedisExpireTime.TOKEN);
    }
    
    /**
     * âœ… è®¡æ•°å™¨å®ç°
     */
    public Long incrementCounter(String counterName) {
        String key = "counter:" + counterName;
        return redisTemplate.opsForValue().increment(key);
    }
    
    /**
     * âœ… åˆ†å¸ƒå¼IDç”Ÿæˆ
     */
    public String generateOrderId() {
        String key = "id:generator:order";
        Long sequence = redisTemplate.opsForValue().increment(key);
        return "ORD" + System.currentTimeMillis() + String.format("%04d", sequence % 10000);
    }
    
    /**
     * âœ… é™æµå®ç°
     */
    public boolean isAllowed(String userId, int limit, Duration window) {
        String key = "rate_limit:" + userId + ":" + (System.currentTimeMillis() / window.toMillis());
        
        String countStr = (String) redisTemplate.opsForValue().get(key);
        int currentCount = countStr != null ? Integer.parseInt(countStr) : 0;
        
        if (currentCount >= limit) {
            return false;
        }
        
        // ä½¿ç”¨ç®¡é“æ“ä½œä¿è¯åŸå­æ€§
        redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
            connection.incr(key.getBytes());
            connection.expire(key.getBytes(), window.getSeconds());
            return null;
        });
        
        return true;
    }
}
// [AI-BLOCK-END]
```

### Hashç±»å‹ä½¿ç”¨
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * Hashç±»å‹ä½¿ç”¨ç¤ºä¾‹
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisHashService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * âœ… ç”¨æˆ·ä¿¡æ¯ç¼“å­˜ (æ¨èç”¨Hashå­˜å‚¨å¯¹è±¡å­—æ®µ)
     */
    public void cacheUserInfo(User user) {
        String key = RedisKeyBuilder.buildUserInfoKey(user.getId());
        
        Map<String, Object> userMap = new HashMap<>();
        userMap.put("id", user.getId());
        userMap.put("username", user.getUsername());
        userMap.put("email", user.getEmail());
        userMap.put("status", user.getStatus());
        userMap.put("lastLoginTime", user.getLastLoginTime());
        
        redisTemplate.opsForHash().putAll(key, userMap);
        redisTemplate.expire(key, RedisExpireTime.MEDIUM);
        
        log.debug("ç”¨æˆ·ä¿¡æ¯å·²ç¼“å­˜: userId={}", user.getId());
    }
    
    /**
     * âœ… è·å–ç”¨æˆ·ç‰¹å®šå­—æ®µ
     */
    public String getUserEmail(Long userId) {
        String key = RedisKeyBuilder.buildUserInfoKey(userId);
        return (String) redisTemplate.opsForHash().get(key, "email");
    }
    
    /**
     * âœ… æ‰¹é‡è·å–ç”¨æˆ·ä¿¡æ¯
     */
    public Map<Object, Object> getUserInfo(Long userId) {
        String key = RedisKeyBuilder.buildUserInfoKey(userId);
        return redisTemplate.opsForHash().entries(key);
    }
    
    /**
     * âœ… æ›´æ–°ç”¨æˆ·ç‰¹å®šå­—æ®µ
     */
    public void updateUserStatus(Long userId, Integer status) {
        String key = RedisKeyBuilder.buildUserInfoKey(userId);
        redisTemplate.opsForHash().put(key, "status", status);
        
        // é‡æ–°è®¾ç½®è¿‡æœŸæ—¶é—´
        redisTemplate.expire(key, RedisExpireTime.MEDIUM);
    }
    
    /**
     * âœ… äº§å“åº“å­˜ç®¡ç†
     */
    public void updateProductStock(Long productId, int quantity) {
        String key = "product:stock:info";
        redisTemplate.opsForHash().put(key, productId.toString(), quantity);
    }
    
    public Integer getProductStock(Long productId) {
        String key = "product:stock:info";
        Object stock = redisTemplate.opsForHash().get(key, productId.toString());
        return stock != null ? (Integer) stock : 0;
    }
}
// [AI-BLOCK-END]
```

### Listç±»å‹ä½¿ç”¨
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * Listç±»å‹ä½¿ç”¨ç¤ºä¾‹
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisListService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * âœ… æ¶ˆæ¯é˜Ÿåˆ—å®ç°
     */
    public void pushMessage(String queueName, Object message) {
        String key = "queue:" + queueName;
        redisTemplate.opsForList().leftPush(key, message);
        log.debug("æ¶ˆæ¯å·²å…¥é˜Ÿ: queue={}", queueName);
    }
    
    public Object popMessage(String queueName, Duration timeout) {
        String key = "queue:" + queueName;
        return redisTemplate.opsForList().rightPop(key, timeout);
    }
    
    /**
     * âœ… æœ€è¿‘è®¿é—®è®°å½•
     */
    public void addRecentView(String userId, Long productId) {
        String key = "user:recent_view:" + userId;
        
        // ç§»é™¤é‡å¤é¡¹
        redisTemplate.opsForList().remove(key, 0, productId);
        
        // æ·»åŠ åˆ°åˆ—è¡¨å¤´éƒ¨
        redisTemplate.opsForList().leftPush(key, productId);
        
        // ä¿æŒåˆ—è¡¨é•¿åº¦ä¸è¶…è¿‡10
        redisTemplate.opsForList().trim(key, 0, 9);
        
        // è®¾ç½®è¿‡æœŸæ—¶é—´
        redisTemplate.expire(key, RedisExpireTime.DAY);
    }
    
    public List<Object> getRecentViews(String userId) {
        String key = "user:recent_view:" + userId;
        return redisTemplate.opsForList().range(key, 0, -1);
    }
    
    /**
     * âœ… æ—¥å¿—æ”¶é›†
     */
    public void collectLog(String logType, String logContent) {
        String key = "log:collect:" + logType + ":" + LocalDate.now();
        
        redisTemplate.opsForList().leftPush(key, logContent);
        
        // å•ä¸ªæ—¥å¿—åˆ—è¡¨ä¸è¶…è¿‡10000æ¡
        Long size = redisTemplate.opsForList().size(key);
        if (size != null && size > 10000) {
            redisTemplate.opsForList().trim(key, 0, 9999);
        }
        
        redisTemplate.expire(key, RedisExpireTime.DAY);
    }
}
// [AI-BLOCK-END]
```

### Setç±»å‹ä½¿ç”¨
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * Setç±»å‹ä½¿ç”¨ç¤ºä¾‹
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisSetService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * âœ… ç”¨æˆ·å…³æ³¨å…³ç³»
     */
    public void addFollowing(String userId, String targetUserId) {
        String followingKey = "user:following:" + userId;
        String followersKey = "user:followers:" + targetUserId;
        
        redisTemplate.opsForSet().add(followingKey, targetUserId);
        redisTemplate.opsForSet().add(followersKey, userId);
        
        redisTemplate.expire(followingKey, RedisExpireTime.VERY_LONG);
        redisTemplate.expire(followersKey, RedisExpireTime.VERY_LONG);
    }
    
    public void removeFollowing(String userId, String targetUserId) {
        String followingKey = "user:following:" + userId;
        String followersKey = "user:followers:" + targetUserId;
        
        redisTemplate.opsForSet().remove(followingKey, targetUserId);
        redisTemplate.opsForSet().remove(followersKey, userId);
    }
    
    /**
     * âœ… è·å–å…±åŒå…³æ³¨
     */
    public Set<Object> getCommonFollowing(String userId1, String userId2) {
        String key1 = "user:following:" + userId1;
        String key2 = "user:following:" + userId2;
        
        return redisTemplate.opsForSet().intersect(key1, key2);
    }
    
    /**
     * âœ… æ ‡ç­¾ç®¡ç†
     */
    public void addProductTags(Long productId, String... tags) {
        String key = "product:tags:" + productId;
        redisTemplate.opsForSet().add(key, (Object[]) tags);
        redisTemplate.expire(key, RedisExpireTime.LONG);
    }
    
    public Set<Object> getProductTags(Long productId) {
        String key = "product:tags:" + productId;
        return redisTemplate.opsForSet().members(key);
    }
    
    /**
     * âœ… åœ¨çº¿ç”¨æˆ·ç»Ÿè®¡
     */
    public void userOnline(String userId) {
        String key = "online:users:" + LocalDate.now();
        redisTemplate.opsForSet().add(key, userId);
        redisTemplate.expire(key, RedisExpireTime.DAY);
    }
    
    public void userOffline(String userId) {
        String key = "online:users:" + LocalDate.now();
        redisTemplate.opsForSet().remove(key, userId);
    }
    
    public Long getOnlineUserCount() {
        String key = "online:users:" + LocalDate.now();
        return redisTemplate.opsForSet().size(key);
    }
}
// [AI-BLOCK-END]
```

### ZSetç±»å‹ä½¿ç”¨
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * ZSetç±»å‹ä½¿ç”¨ç¤ºä¾‹
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisZSetService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * âœ… æ’è¡Œæ¦œå®ç°
     */
    public void updateUserScore(String userId, double score) {
        String key = "leaderboard:user_score";
        redisTemplate.opsForZSet().add(key, userId, score);
        redisTemplate.expire(key, RedisExpireTime.DAY);
    }
    
    /**
     * âœ… è·å–æ’è¡Œæ¦œTop N
     */
    public Set<ZSetOperations.TypedTuple<Object>> getTopUsers(int count) {
        String key = "leaderboard:user_score";
        return redisTemplate.opsForZSet().reverseRangeWithScores(key, 0, count - 1);
    }
    
    /**
     * âœ… è·å–ç”¨æˆ·æ’å
     */
    public Long getUserRank(String userId) {
        String key = "leaderboard:user_score";
        return redisTemplate.opsForZSet().reverseRank(key, userId);
    }
    
    /**
     * âœ… å»¶æ—¶é˜Ÿåˆ—å®ç°
     */
    public void addDelayedTask(String taskId, Object taskData, long executeTime) {
        String key = "delayed:tasks";
        
        // ä½¿ç”¨æ‰§è¡Œæ—¶é—´ä½œä¸ºåˆ†æ•°
        redisTemplate.opsForZSet().add(key, taskId, executeTime);
        
        // å•ç‹¬å­˜å‚¨ä»»åŠ¡æ•°æ®
        String dataKey = "task:data:" + taskId;
        redisTemplate.opsForValue().set(dataKey, taskData, Duration.ofDays(1));
    }
    
    public Set<Object> getReadyTasks() {
        String key = "delayed:tasks";
        long currentTime = System.currentTimeMillis();
        
        // è·å–å½“å‰æ—¶é—´ä¹‹å‰çš„æ‰€æœ‰ä»»åŠ¡
        return redisTemplate.opsForZSet().rangeByScore(key, 0, currentTime);
    }
    
    /**
     * âœ… çƒ­é—¨å•†å“ç»Ÿè®¡
     */
    public void incrementProductView(Long productId) {
        String key = "hot:products:" + LocalDate.now();
        redisTemplate.opsForZSet().incrementScore(key, productId.toString(), 1);
        redisTemplate.expire(key, RedisExpireTime.DAY);
    }
    
    public List<Object> getHotProducts(int count) {
        String key = "hot:products:" + LocalDate.now();
        Set<Object> products = redisTemplate.opsForZSet().reverseRange(key, 0, count - 1);
        return new ArrayList<>(products);
    }
}
// [AI-BLOCK-END]
```

## ğŸ“‹ åˆ†å¸ƒå¼é”å®ç°

### åŸºäºRedisçš„åˆ†å¸ƒå¼é”
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * åˆ†å¸ƒå¼é”å®ç°
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class RedisDistributedLock {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    private static final String LOCK_PREFIX = "lock:";
    private static final String UNLOCK_SCRIPT = 
        "if redis.call('get', KEYS[1]) == ARGV[1] then " +
        "    return redis.call('del', KEYS[1]) " +
        "else " +
        "    return 0 " +
        "end";
    
    /**
     * å°è¯•è·å–é”
     */
    public boolean tryLock(String lockKey, String lockValue, Duration expireTime) {
        try {
            String key = LOCK_PREFIX + lockKey;
            Boolean result = redisTemplate.opsForValue().setIfAbsent(key, lockValue, expireTime);
            
            if (Boolean.TRUE.equals(result)) {
                log.debug("åˆ†å¸ƒå¼é”è·å–æˆåŠŸ: key={}, value={}", key, lockValue);
                return true;
            } else {
                log.debug("åˆ†å¸ƒå¼é”è·å–å¤±è´¥: key={}, value={}", key, lockValue);
                return false;
            }
        } catch (Exception e) {
            log.error("åˆ†å¸ƒå¼é”è·å–å¼‚å¸¸: key={}", lockKey, e);
            return false;
        }
    }
    
    /**
     * é‡Šæ”¾é”
     */
    public boolean releaseLock(String lockKey, String lockValue) {
        try {
            String key = LOCK_PREFIX + lockKey;
            
            // ä½¿ç”¨Luaè„šæœ¬ä¿è¯åŸå­æ€§
            DefaultRedisScript<Long> script = new DefaultRedisScript<>();
            script.setScriptText(UNLOCK_SCRIPT);
            script.setResultType(Long.class);
            
            Long result = redisTemplate.execute(script, Collections.singletonList(key), lockValue);
            
            if (result != null && result == 1L) {
                log.debug("åˆ†å¸ƒå¼é”é‡Šæ”¾æˆåŠŸ: key={}, value={}", key, lockValue);
                return true;
            } else {
                log.warn("åˆ†å¸ƒå¼é”é‡Šæ”¾å¤±è´¥: key={}, value={}", key, lockValue);
                return false;
            }
        } catch (Exception e) {
            log.error("åˆ†å¸ƒå¼é”é‡Šæ”¾å¼‚å¸¸: key={}", lockKey, e);
            return false;
        }
    }
    
    /**
     * å¸¦é‡è¯•çš„é”è·å–
     */
    public boolean tryLockWithRetry(String lockKey, String lockValue, 
                                   Duration expireTime, Duration retryInterval, int maxRetries) {
        
        for (int i = 0; i < maxRetries; i++) {
            if (tryLock(lockKey, lockValue, expireTime)) {
                return true;
            }
            
            try {
                Thread.sleep(retryInterval.toMillis());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }
        
        log.warn("åˆ†å¸ƒå¼é”è·å–å¤±è´¥ï¼Œé‡è¯•æ¬¡æ•°å·²è¾¾ä¸Šé™: key={}, maxRetries={}", lockKey, maxRetries);
        return false;
    }
}

/**
 * åˆ†å¸ƒå¼é”æ³¨è§£
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DistributedLock {
    /**
     * é”çš„keyï¼Œæ”¯æŒSpELè¡¨è¾¾å¼
     */
    String key();
    
    /**
     * é”çš„è¿‡æœŸæ—¶é—´ï¼Œé»˜è®¤30ç§’
     */
    long expireTime() default 30;
    
    /**
     * æ—¶é—´å•ä½ï¼Œé»˜è®¤ç§’
     */
    TimeUnit timeUnit() default TimeUnit.SECONDS;
    
    /**
     * è·å–é”å¤±è´¥æ—¶æ˜¯å¦æŠ›å‡ºå¼‚å¸¸
     */
    boolean throwException() default true;
}

/**
 * åˆ†å¸ƒå¼é”åˆ‡é¢
 */
@Aspect
@Component
@RequiredArgsConstructor
@Slf4j
public class DistributedLockAspect {
    
    private final RedisDistributedLock distributedLock;
    private final SpelExpressionParser parser = new SpelExpressionParser();
    
    @Around("@annotation(distributedLockAnnotation)")
    public Object around(ProceedingJoinPoint joinPoint, DistributedLock distributedLockAnnotation) throws Throwable {
        
        // è§£æé”çš„key
        String lockKey = parseKey(distributedLockAnnotation.key(), joinPoint);
        String lockValue = UUID.randomUUID().toString();
        Duration expireTime = Duration.of(distributedLockAnnotation.expireTime(), 
            distributedLockAnnotation.timeUnit().toChronoUnit());
        
        boolean lockAcquired = distributedLock.tryLock(lockKey, lockValue, expireTime);
        
        if (!lockAcquired) {
            if (distributedLockAnnotation.throwException()) {
                throw new BusinessException(ErrorCode.LOCK_ACQUIRE_FAILED);
            } else {
                log.warn("è·å–åˆ†å¸ƒå¼é”å¤±è´¥ï¼Œæ–¹æ³•æ‰§è¡Œè·³è¿‡: key={}", lockKey);
                return null;
            }
        }
        
        try {
            return joinPoint.proceed();
        } finally {
            distributedLock.releaseLock(lockKey, lockValue);
        }
    }
    
    private String parseKey(String keyExpression, ProceedingJoinPoint joinPoint) {
        if (!keyExpression.contains("#")) {
            return keyExpression;
        }
        
        // æ„å»ºSpELä¸Šä¸‹æ–‡
        StandardEvaluationContext context = new StandardEvaluationContext();
        
        // è·å–æ–¹æ³•å‚æ•°
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        String[] paramNames = signature.getParameterNames();
        Object[] args = joinPoint.getArgs();
        
        for (int i = 0; i < paramNames.length; i++) {
            context.setVariable(paramNames[i], args[i]);
        }
        
        Expression expression = parser.parseExpression(keyExpression);
        return expression.getValue(context, String.class);
    }
}
// [AI-BLOCK-END]
```

## ğŸ“‹ æ€§èƒ½ä¼˜åŒ–è§„èŒƒ

### è¿æ¥æ± é…ç½®
```yaml
# âœ… Redisè¿æ¥æ± é…ç½®
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
    timeout: 5000ms
    
    # Lettuceè¿æ¥æ± é…ç½® (æ¨è)
    lettuce:
      pool:
        max-active: 200      # æœ€å¤§è¿æ¥æ•°
        max-idle: 20         # æœ€å¤§ç©ºé—²è¿æ¥æ•°
        min-idle: 5          # æœ€å°ç©ºé—²è¿æ¥æ•°
        max-wait: 1000ms     # è·å–è¿æ¥æœ€å¤§ç­‰å¾…æ—¶é—´
        time-between-eviction-runs: 30000ms  # ç©ºé—²è¿æ¥æ£€æµ‹é—´éš”
      shutdown-timeout: 100ms
      
    # é›†ç¾¤é…ç½®
    cluster:
      nodes:
        - 192.168.1.1:7001
        - 192.168.1.1:7002
        - 192.168.1.1:7003
        - 192.168.1.2:7001
        - 192.168.1.2:7002
        - 192.168.1.2:7003
      max-redirects: 3
```

### æ‰¹é‡æ“ä½œä¼˜åŒ–
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * æ‰¹é‡æ“ä½œä¼˜åŒ–
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisBatchService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * âœ… ä½¿ç”¨Pipelineæ‰¹é‡æ“ä½œ
     */
    public void batchSetUserInfo(Map<Long, User> userMap) {
        List<Object> results = redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
            userMap.forEach((userId, user) -> {
                String key = RedisKeyBuilder.buildUserInfoKey(userId);
                
                // åºåˆ—åŒ–ç”¨æˆ·å¯¹è±¡
                Map<String, Object> userFields = convertUserToMap(user);
                userFields.forEach((field, value) -> {
                    connection.hSet(key.getBytes(), field.getBytes(), 
                        redisTemplate.getValueSerializer().serialize(value));
                });
                
                // è®¾ç½®è¿‡æœŸæ—¶é—´
                connection.expire(key.getBytes(), RedisExpireTime.MEDIUM.getSeconds());
            });
            return null;
        });
        
        log.info("æ‰¹é‡ç¼“å­˜ç”¨æˆ·ä¿¡æ¯å®Œæˆ: count={}", userMap.size());
    }
    
    /**
     * âœ… æ‰¹é‡è·å–ç¼“å­˜
     */
    public Map<String, Object> batchGetCache(List<String> keys) {
        List<Object> values = redisTemplate.opsForValue().multiGet(keys);
        
        Map<String, Object> result = new HashMap<>();
        for (int i = 0; i < keys.size(); i++) {
            if (values.get(i) != null) {
                result.put(keys.get(i), values.get(i));
            }
        }
        
        return result;
    }
    
    /**
     * âœ… æ‰¹é‡åˆ é™¤ç¼“å­˜
     */
    public void batchDeleteCache(Collection<String> keys) {
        if (keys.isEmpty()) {
            return;
        }
        
        // åˆ†æ‰¹åˆ é™¤ï¼Œé¿å…å•æ¬¡æ“ä½œè¿‡å¤škey
        List<String> keyList = new ArrayList<>(keys);
        int batchSize = 100;
        
        for (int i = 0; i < keyList.size(); i += batchSize) {
            int endIndex = Math.min(i + batchSize, keyList.size());
            List<String> batch = keyList.subList(i, endIndex);
            
            redisTemplate.delete(batch);
            log.debug("æ‰¹é‡åˆ é™¤ç¼“å­˜: batch={}-{}, count={}", i, endIndex - 1, batch.size());
        }
    }
    
    private Map<String, Object> convertUserToMap(User user) {
        Map<String, Object> map = new HashMap<>();
        map.put("id", user.getId());
        map.put("username", user.getUsername());
        map.put("email", user.getEmail());
        map.put("status", user.getStatus());
        return map;
    }
}
// [AI-BLOCK-END]
```

### å†…å­˜ä¼˜åŒ–ç­–ç•¥
```java
// [AI-BLOCK-START] - ç”Ÿæˆå·¥å…·: Claude 3.5 Sonnet
/**
 * Rediså†…å­˜ä¼˜åŒ–æœåŠ¡
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisMemoryOptimizer {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * âœ… å¤§å¯¹è±¡å‹ç¼©å­˜å‚¨
     */
    public void setCompressedValue(String key, Object value, Duration expire) {
        try {
            // åºåˆ—åŒ–å¯¹è±¡
            byte[] serialized = serialize(value);
            
            // å¦‚æœæ•°æ®å¤§äº1KBï¼Œåˆ™è¿›è¡Œå‹ç¼©
            if (serialized.length > 1024) {
                byte[] compressed = compress(serialized);
                redisTemplate.opsForValue().set(key + ":compressed", compressed, expire);
                log.debug("å¤§å¯¹è±¡å‹ç¼©å­˜å‚¨: key={}, original={} bytes, compressed={} bytes", 
                    key, serialized.length, compressed.length);
            } else {
                redisTemplate.opsForValue().set(key, value, expire);
            }
        } catch (Exception e) {
            log.error("å‹ç¼©å­˜å‚¨å¤±è´¥: key={}", key, e);
        }
    }
    
    public Object getCompressedValue(String key) {
        try {
            // å…ˆå°è¯•è·å–å‹ç¼©ç‰ˆæœ¬
            byte[] compressed = (byte[]) redisTemplate.opsForValue().get(key + ":compressed");
            if (compressed != null) {
                byte[] decompressed = decompress(compressed);
                return deserialize(decompressed);
            }
            
            // è·å–æ™®é€šç‰ˆæœ¬
            return redisTemplate.opsForValue().get(key);
        } catch (Exception e) {
            log.error("å‹ç¼©æ•°æ®è¯»å–å¤±è´¥: key={}", key, e);
            return null;
        }
    }
    
    /**
     * âœ… å†…å­˜ä½¿ç”¨ç›‘æ§
     */
    @Scheduled(fixedRate = 300000) // æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void monitorMemoryUsage() {
        try {
            Properties info = redisTemplate.getConnectionFactory()
                .getConnection().info("memory");
            
            String usedMemory = info.getProperty("used_memory_human");
            String maxMemory = info.getProperty("maxmemory_human");
            String memoryUsageRatio = info.getProperty("used_memory_rss_ratio");
            
            log.info("Rediså†…å­˜ä½¿ç”¨æƒ…å†µ: used={}, max={}, ratio={}", 
                usedMemory, maxMemory, memoryUsageRatio);
            
            // å¦‚æœå†…å­˜ä½¿ç”¨ç‡è¶…è¿‡80%ï¼Œè®°å½•è­¦å‘Š
            if (memoryUsageRatio != null && Double.parseDouble(memoryUsageRatio) > 0.8) {
                log.warn("Rediså†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: {}", memoryUsageRatio);
            }
        } catch (Exception e) {
            log.error("å†…å­˜ç›‘æ§å¤±è´¥", e);
        }
    }
    
    /**
     * âœ… æ¸…ç†è¿‡æœŸé”®
     */
    public void cleanupExpiredKeys() {
        try {
            // è·å–æ‰€æœ‰é”®çš„æ•°é‡
            Set<String> keys = redisTemplate.keys("*");
            if (keys == null) return;
            
            int totalKeys = keys.size();
            int expiredKeys = 0;
            
            for (String key : keys) {
                Long ttl = redisTemplate.getExpire(key);
                if (ttl != null && ttl == -1) { // æ²¡æœ‰è®¾ç½®è¿‡æœŸæ—¶é—´çš„é”®
                    log.warn("å‘ç°æœªè®¾ç½®è¿‡æœŸæ—¶é—´çš„é”®: {}", key);
                }
            }
            
            log.info("é”®æ¸…ç†æ£€æŸ¥å®Œæˆ: total={}, expired={}", totalKeys, expiredKeys);
        } catch (Exception e) {
            log.error("é”®æ¸…ç†æ£€æŸ¥å¤±è´¥", e);
        }
    }
    
    private byte[] compress(byte[] data) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try (GZIPOutputStream gzos = new GZIPOutputStream(baos)) {
            gzos.write(data);
        }
        return baos.toByteArray();
    }
    
    private byte[] decompress(byte[] compressedData) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try (GZIPInputStream gzis = new GZIPInputStream(new ByteArrayInputStream(compressedData))) {
            byte[] buffer = new byte[1024];
            int length;
            while ((length = gzis.read(buffer)) != -1) {
                baos.write(buffer, 0, length);
            }
        }
        return baos.toByteArray();
    }
    
    private byte[] serialize(Object obj) {
        // ä½¿ç”¨Javaåºåˆ—åŒ–æˆ–å…¶ä»–åºåˆ—åŒ–æ–¹å¼
        return redisTemplate.getValueSerializer().serialize(obj);
    }
    
    private Object deserialize(byte[] data) {
        return redisTemplate.getValueSerializer().deserialize(data);
    }
}
// [AI-BLOCK-END]
```

## âœ… æ£€æŸ¥æ¸…å•

### é”®è®¾è®¡æ£€æŸ¥
- [ ] é”®å‘½åéµå¾ªç»Ÿä¸€æ ¼å¼ï¼š{æ¨¡å—}:{å®ä½“}:{æ ‡è¯†ç¬¦}
- [ ] æ‰€æœ‰é”®éƒ½è®¾ç½®äº†åˆç†çš„è¿‡æœŸæ—¶é—´
- [ ] é”®åé•¿åº¦æ§åˆ¶åœ¨åˆç†èŒƒå›´å†…
- [ ] é¿å…ä½¿ç”¨è¿‡æ·±çš„åµŒå¥—ç»“æ„

### æ•°æ®ç»“æ„é€‰æ‹©
- [ ] Stringç”¨äºç®€å•å€¼ã€è®¡æ•°å™¨ã€ä»¤ç‰Œ
- [ ] Hashç”¨äºå¯¹è±¡å­˜å‚¨å’Œå­—æ®µæ›´æ–°
- [ ] Listç”¨äºé˜Ÿåˆ—å’Œæ—¶é—´åºåˆ—æ•°æ®
- [ ] Setç”¨äºå»é‡å’Œé›†åˆè¿ç®—
- [ ] ZSetç”¨äºæ’åºå’Œè¯„åˆ†ç³»ç»Ÿ

### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥
- [ ] æ‰¹é‡æ“ä½œä½¿ç”¨Pipelineæˆ–äº‹åŠ¡
- [ ] å¤§å¯¹è±¡è€ƒè™‘å‹ç¼©å­˜å‚¨
- [ ] è¿æ¥æ± é…ç½®åˆç†
- [ ] é¿å…ä½¿ç”¨KEYSå‘½ä»¤æ‰«æ
- [ ] ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ

### å®‰å…¨æ£€æŸ¥
- [ ] ç”Ÿäº§ç¯å¢ƒé…ç½®å¯†ç è®¤è¯
- [ ] ç¦ç”¨å±é™©å‘½ä»¤ï¼ˆFLUSHDBã€CONFIGç­‰ï¼‰
- [ ] ç½‘ç»œè®¿é—®æ§åˆ¶é…ç½®
- [ ] æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] å®šæœŸå¤‡ä»½é‡è¦æ•°æ®

---
*éµå¾ªä»¥ä¸ŠRedisè§„èŒƒï¼Œç¡®ä¿ç¼“å­˜ç³»ç»Ÿçš„é«˜æ€§èƒ½ã€é«˜å¯ç”¨å’Œå¯ç»´æŠ¤æ€§*
description:
globs:
alwaysApply: false
---
