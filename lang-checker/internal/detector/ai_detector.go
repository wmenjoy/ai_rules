package detector

import (
	"fmt"
	"math"
	"regexp"
	"strings"

	"github.com/liujinliang/lang-checker/internal/models"
)

// AIPattern AI特征模式
type AIPattern struct {
	Pattern     *regexp.Regexp
	Description string
	Weight      float64
}

// GetDefaultPatterns 获取默认的AI特征模式
func GetDefaultPatterns() []AIPattern {
	return []AIPattern{
		{
			Pattern:     regexp.MustCompile(`(?i)\[AI-BLOCK-(START|END)\]`),
			Description: "AI生成标记",
			Weight:      30.0,
		},
		{
			Pattern:     regexp.MustCompile(`(?i)Generated by|Auto-generated|AI-generated`),
			Description: "生成声明",
			Weight:      25.0,
		},
		{
			Pattern:     regexp.MustCompile(`TODO:|FIXME:|NOTE:`),
			Description: "标准注释标记",
			Weight:      10.0,
		},
	}
}

// AIDetector AI代码检测器
type AIDetector struct {
	patterns []AIPattern
}

// NewAIDetector 创建新的AI检测器
func NewAIDetector() *AIDetector {
	return &AIDetector{
		patterns: GetDefaultPatterns(),
	}
}

// DetectAI 检测代码是否由AI生成
func (detector *AIDetector) DetectAI(content string) *models.AIDetectionResult {
	var indicators []string
	totalScore := 0.0

	lines := strings.Split(content, "\n")
	totalLines := float64(len(lines))

	// 基于模式的检测
	for _, pattern := range detector.patterns {
		matches := pattern.Pattern.FindAllString(content, -1)
		if len(matches) > 0 {
			// 计算匹配密度
			density := float64(len(matches)) / totalLines * 100
			if density > 5.0 { // 如果密度超过5%，认为是强特征
				score := pattern.Weight * math.Min(density/10.0, 2.0) // 最高2倍权重
				totalScore += score
				indicators = append(indicators, formatIndicator(pattern.Description, len(matches), density))
			}
		}
	}

	// 语言特异性检测
	totalScore += detector.detectLanguageSpecificAI(content, &indicators)

	// 统计学特征检测
	totalScore += detector.detectStatisticalFeatures(content, &indicators)

	return &models.AIDetectionResult{
		Score:      math.Min(totalScore, 100.0),
		Indicators: indicators,
	}
}

// detectLanguageSpecificAI 检测特定语言的AI特征
func (detector *AIDetector) detectLanguageSpecificAI(content string, indicators *[]string) float64 {
	score := 0.0

	// Java特异性检测
	if strings.Contains(content, "public class") || strings.Contains(content, "import java") {
		score += detector.detectJavaPatterns(content, indicators)
	}

	// Go特异性检测
	if strings.Contains(content, "package ") && strings.Contains(content, "func ") {
		score += detector.detectGoPatterns(content, indicators)
	}

	return score
}

// detectJavaPatterns 检测Java特定的AI模式
func (detector *AIDetector) detectJavaPatterns(content string, indicators *[]string) float64 {
	score := 0.0

	// 检测过度使用设计模式
	designPatterns := []string{"Factory", "Builder", "Strategy", "Observer", "Singleton"}
	patternCount := 0
	for _, pattern := range designPatterns {
		if strings.Contains(content, pattern) {
			patternCount++
		}
	}
	if patternCount >= 3 {
		score += 15.0
		*indicators = append(*indicators, "过度使用设计模式（AI特征）")
	}

	// 检测过于规范的异常处理
	exceptionPattern := regexp.MustCompile(`(?m)^\s*}\s*catch\s*\([^)]+\)\s*{\s*$`)
	if matches := exceptionPattern.FindAllString(content, -1); len(matches) > 2 {
		score += 10.0
		*indicators = append(*indicators, "过于规范的异常处理（AI特征）")
	}

	return score
}

// detectGoPatterns 检测Go特定的AI模式
func (detector *AIDetector) detectGoPatterns(content string, indicators *[]string) float64 {
	score := 0.0

	// 检测过度使用接口
	interfacePattern := regexp.MustCompile(`type\s+\w+\s+interface`)
	if matches := interfacePattern.FindAllString(content, -1); len(matches) > 3 {
		score += 12.0
		*indicators = append(*indicators, "过度使用接口（AI特征）")
	}

	// 检测完美的错误处理模式
	errorPattern := regexp.MustCompile(`if err != nil`)
	errorCount := len(errorPattern.FindAllString(content, -1))
	lines := len(strings.Split(content, "\n"))
	if errorCount > 0 && float64(errorCount)/float64(lines) > 0.1 {
		score += 8.0
		*indicators = append(*indicators, "异常频繁的错误检查（AI特征）")
	}

	return score
}

// detectStatisticalFeatures 检测统计学特征
func (detector *AIDetector) detectStatisticalFeatures(content string, indicators *[]string) float64 {
	score := 0.0
	lines := strings.Split(content, "\n")

	// 检测行长度的一致性
	if lineScore := detector.analyzeLineLengths(lines); lineScore > 0 {
		score += lineScore
		*indicators = append(*indicators, "行长度异常一致（AI特征）")
	}

	// 检测缩进的完美性
	if indentScore := detector.analyzeIndentation(lines); indentScore > 0 {
		score += indentScore
		*indicators = append(*indicators, "缩进异常完美（AI特征）")
	}

	// 检测AI常用词汇
	if wordScore := detector.analyzeCommonWords(content); wordScore > 0 {
		score += wordScore
		*indicators = append(*indicators, "使用AI常用词汇（AI特征）")
	}

	return score
}

// analyzeLineLengths 分析行长度的一致性
func (detector *AIDetector) analyzeLineLengths(lines []string) float64 {
	if len(lines) < 10 {
		return 0
	}

	// 计算行长度的标准差
	var lengths []float64
	for _, line := range lines {
		if len(strings.TrimSpace(line)) > 0 {
			lengths = append(lengths, float64(len(line)))
		}
	}

	if len(lengths) < 10 {
		return 0
	}

	mean := calculateMean(lengths)
	stdDev := calculateStdDev(lengths, mean)

	// 如果标准差异常小，说明行长度过于一致
	if stdDev < 5 {
		return 15.0
	} else if stdDev < 10 {
		return 8.0
	}

	return 0
}

// analyzeIndentation 分析缩进的完美性
func (detector *AIDetector) analyzeIndentation(lines []string) float64 {
	if len(lines) < 10 {
		return 0
	}

	perfectCount := 0
	for _, line := range lines {
		if len(line) == 0 {
			continue
		}

		// 检查是否是完美的缩进（4或8个空格）
		spaces := len(line) - len(strings.TrimLeft(line, " "))
		if spaces%4 == 0 {
			perfectCount++
		}
	}

	ratio := float64(perfectCount) / float64(len(lines))
	if ratio > 0.95 {
		return 12.0
	} else if ratio > 0.85 {
		return 6.0
	}

	return 0
}

// analyzeCommonWords 分析AI常用词汇
func (detector *AIDetector) analyzeCommonWords(content string) float64 {
	aiWords := []string{
		"implementation", "functionality", "initialize",
		"configuration", "instantiate", "parameter",
		"optimization", "interface", "abstraction",
	}

	score := 0.0
	for _, word := range aiWords {
		if count := strings.Count(strings.ToLower(content), strings.ToLower(word)); count > 0 {
			score += float64(count) * 2
		}
	}

	return math.Min(score, 20.0)
}

// 辅助函数
func calculateMean(numbers []float64) float64 {
	sum := 0.0
	for _, n := range numbers {
		sum += n
	}
	return sum / float64(len(numbers))
}

func calculateStdDev(numbers []float64, mean float64) float64 {
	sumSquares := 0.0
	for _, n := range numbers {
		diff := n - mean
		sumSquares += diff * diff
	}
	variance := sumSquares / float64(len(numbers))
	return math.Sqrt(variance)
}

func formatIndicator(desc string, matches int, density float64) string {
	return fmt.Sprintf("%s (匹配%d次, 密度%.1f%%)", desc, matches, density)
}
