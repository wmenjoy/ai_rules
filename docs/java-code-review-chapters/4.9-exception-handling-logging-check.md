### 4.9 异常处理与日志检查

#### 4.9.1 异常处理规范 🔴

##### 4.9.1.1 异常定义和分类检查

**1. 检测目标**

a. 必须定义清晰的异常层次结构
b. 业务异常和系统异常必须分离
c. 异常必须包含错误码和详细信息
d. 避免使用通用异常类型
e. 异常信息必须对用户友好

**2. 检测方法**

a. 代码审查：检查异常类定义和使用
b. 静态分析：检测异常处理模式
c. 单元测试：验证异常场景覆盖
d. 集成测试：验证异常传播正确性

**3. 错误示例**

```java
// ❌ 错误：使用通用异常，信息不明确
public class UserService {
    public User findUser(String id) throws Exception {
        if (StringUtils.isEmpty(id)) {
            throw new Exception("参数错误"); // 信息不具体
        }
        
        User user = userRepository.findById(id);
        if (user == null) {
            throw new RuntimeException("用户不存在"); // 使用通用异常
        }
        return user;
    }
}

// ❌ 错误：异常信息暴露内部实现
public class OrderService {
    public void createOrder(OrderRequest request) {
        try {
            orderRepository.save(request);
        } catch (SQLException e) {
            // 直接暴露数据库异常
            throw new RuntimeException("SQL执行失败: " + e.getMessage());
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：定义清晰的异常层次
public abstract class BaseException extends RuntimeException {
    private final String errorCode;
    private final String userMessage;
    
    protected BaseException(String errorCode, String userMessage, String systemMessage) {
        super(systemMessage);
        this.errorCode = errorCode;
        this.userMessage = userMessage;
    }
    
    protected BaseException(String errorCode, String userMessage, String systemMessage, Throwable cause) {
        super(systemMessage, cause);
        this.errorCode = errorCode;
        this.userMessage = userMessage;
    }
    
    public String getErrorCode() { return errorCode; }
    public String getUserMessage() { return userMessage; }
}

// 业务异常
public class BusinessException extends BaseException {
    public BusinessException(String errorCode, String userMessage) {
        super(errorCode, userMessage, userMessage);
    }
    
    public BusinessException(String errorCode, String userMessage, String systemMessage) {
        super(errorCode, userMessage, systemMessage);
    }
}

// 系统异常
public class SystemException extends BaseException {
    public SystemException(String errorCode, String userMessage, String systemMessage, Throwable cause) {
        super(errorCode, userMessage, systemMessage, cause);
    }
}

// 具体业务异常
public class UserNotFoundException extends BusinessException {
    public UserNotFoundException(String userId) {
        super("USER_NOT_FOUND", "用户不存在", "User not found with id: " + userId);
    }
}

public class InvalidParameterException extends BusinessException {
    public InvalidParameterException(String parameter, String reason) {
        super("INVALID_PARAMETER", 
              String.format("参数 %s 不正确: %s", parameter, reason),
              String.format("Invalid parameter %s: %s", parameter, reason));
    }
}

// ✅ 正确：服务层异常处理
@Service
public class UserService {
    
    public User findUser(String id) {
        if (StringUtils.isEmpty(id)) {
            throw new InvalidParameterException("id", "不能为空");
        }
        
        try {
            User user = userRepository.findById(id);
            if (user == null) {
                throw new UserNotFoundException(id);
            }
            return user;
            
        } catch (DataAccessException e) {
            throw new SystemException("DATABASE_ERROR", 
                "系统繁忙，请稍后重试", 
                "Database access failed for user query: " + id, e);
        }
    }
}
```

##### 4.9.1.2 异常处理策略检查

**1. 检测目标**

a. 异常处理策略必须明确（重试、降级、熔断）
b. 不同类型异常采用不同处理策略
c. 异常处理不能影响系统稳定性
d. 必须有异常恢复机制
e. 异常处理要考虑性能影响

**2. 检测方法**

a. 架构审查：检查异常处理策略设计
b. 代码审查：验证异常处理实现
c. 压力测试：验证异常情况下系统稳定性
d. 故障演练：验证异常恢复能力

**3. 错误示例**

```java
// ❌ 错误：没有明确的异常处理策略
@Service
public class OrderService {
    public void processOrder(Order order) {
        try {
            paymentService.charge(order);
            inventoryService.reserve(order);
            shippingService.arrange(order);
        } catch (Exception e) {
            // 没有明确的处理策略，直接抛出
            throw new RuntimeException("订单处理失败", e);
        }
    }
}

// ❌ 错误：异常处理影响系统性能
public class DataProcessor {
    public void processData(List<Data> dataList) {
        for (Data data : dataList) {
            try {
                expensiveOperation(data);
            } catch (Exception e) {
                // 每次异常都进行昂贵的操作
                sendAlertEmail(e);
                writeToDatabase(e);
                callExternalService(e);
            }
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：明确的异常处理策略
@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);
    
    @Retryable(value = {TransientException.class}, maxAttempts = 3)
    public OrderResult processOrder(Order order) {
        try {
            // 支付失败 - 直接返回，不重试
            PaymentResult payment = paymentService.charge(order);
            
            // 库存不足 - 直接返回，不重试
            InventoryResult inventory = inventoryService.reserve(order);
            
            // 配送安排失败 - 可重试
            ShippingResult shipping = shippingService.arrange(order);
            
            return OrderResult.success(payment, inventory, shipping);
            
        } catch (PaymentException e) {
            log.warn("Payment failed for order: {}", order.getId());
            return OrderResult.paymentFailed(e.getMessage());
            
        } catch (InsufficientInventoryException e) {
            log.warn("Insufficient inventory for order: {}", order.getId());
            return OrderResult.inventoryInsufficient(e.getMessage());
            
        } catch (ShippingException e) {
            log.warn("Shipping arrangement failed for order: {}", order.getId());
            throw new TransientException("配送安排失败", e); // 触发重试
            
        } catch (Exception e) {
            log.error("Unexpected error processing order: {}", order.getId(), e);
            return OrderResult.systemError("系统异常，请稍后重试");
        }
    }
}

// ✅ 正确：高性能异常处理
@Component
public class DataProcessor {
    private static final Logger log = LoggerFactory.getLogger(DataProcessor.class);
    private final AtomicLong errorCount = new AtomicLong(0);
    private final RateLimiter alertLimiter = RateLimiter.create(1.0/60); // 每分钟最多1次告警
    
    public ProcessResult processData(List<Data> dataList) {
        List<Data> successList = new ArrayList<>();
        List<ProcessError> errorList = new ArrayList<>();
        
        for (Data data : dataList) {
            try {
                Data processed = expensiveOperation(data);
                successList.add(processed);
                
            } catch (ValidationException e) {
                // 业务异常，记录但不告警
                errorList.add(new ProcessError(data.getId(), e.getMessage()));
                
            } catch (Exception e) {
                // 系统异常，限流告警
                long currentErrors = errorCount.incrementAndGet();
                log.error("Data processing error: dataId={}, errorCount={}", 
                    data.getId(), currentErrors, e);
                
                if (alertLimiter.tryAcquire()) {
                    alertService.sendAlert("数据处理异常", e);
                }
                
                errorList.add(new ProcessError(data.getId(), "系统异常"));
            }
        }
        
        return new ProcessResult(successList, errorList);
    }
}
```

##### 4.9.1.3 异常信息安全检查

**1. 检测目标**

a. 异常信息不能泄露敏感数据
b. 异常信息不能暴露系统内部结构
c. 用户看到的异常信息必须友好
d. 系统日志可以包含详细信息
e. 异常堆栈不能包含敏感信息

**2. 检测方法**

a. 安全审查：检查异常信息内容
b. 代码审查：验证异常信息处理
c. 渗透测试：验证异常信息不泄露
d. 日志审查：确认敏感信息不在日志中

**3. 错误示例**

```java
// ❌ 错误：异常信息泄露敏感数据
@RestController
public class UserController {
    public ResponseEntity<User> getUser(@PathVariable String id) {
        try {
            User user = userService.findById(id);
            return ResponseEntity.ok(user);
        } catch (Exception e) {
            // 直接返回异常信息，可能包含SQL、密码等敏感信息
            return ResponseEntity.status(500)
                .body(new ErrorResponse(e.getMessage()));
        }
    }
}

// ❌ 错误：异常信息暴露系统结构
public class DatabaseService {
    public User findUser(String id) {
        try {
            return jdbcTemplate.queryForObject(
                "SELECT * FROM users WHERE id = ?", 
                new Object[]{id}, 
                User.class);
        } catch (SQLException e) {
            // 暴露了数据库表结构和SQL语句
            throw new RuntimeException("SQL执行失败: " + e.getMessage() + 
                ", SQL: SELECT * FROM users WHERE id = " + id);
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：安全的异常信息处理
@RestController
public class UserController {
    private static final Logger log = LoggerFactory.getLogger(UserController.class);
    
    @GetMapping("/users/{id}")
    public ResponseEntity<ApiResponse<User>> getUser(@PathVariable String id) {
        try {
            User user = userService.findById(id);
            return ResponseEntity.ok(ApiResponse.success(user));
            
        } catch (UserNotFoundException e) {
            // 业务异常：返回友好信息
            return ResponseEntity.status(404)
                .body(ApiResponse.error("USER_NOT_FOUND", "用户不存在"));
                
        } catch (Exception e) {
            // 系统异常：记录详细日志，返回通用信息
            log.error("System error getting user: id={}", id, e);
            return ResponseEntity.status(500)
                .body(ApiResponse.error("SYSTEM_ERROR", "系统繁忙，请稍后重试"));
        }
    }
}

// ✅ 正确：安全的数据库异常处理
@Repository
public class UserRepository {
    private static final Logger log = LoggerFactory.getLogger(UserRepository.class);
    
    public User findById(String id) {
        try {
            return jdbcTemplate.queryForObject(
                "SELECT id, username, email, created_at FROM users WHERE id = ?", 
                new Object[]{id}, 
                (rs, rowNum) -> {
                    User user = new User();
                    user.setId(rs.getString("id"));
                    user.setUsername(rs.getString("username"));
                    user.setEmail(rs.getString("email"));
                    user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
                    return user;
                });
                
        } catch (EmptyResultDataAccessException e) {
            throw new UserNotFoundException(id);
            
        } catch (DataAccessException e) {
            // 记录详细的系统日志，但不暴露给上层
            log.error("Database error finding user: id={}, error={}", id, e.getMessage());
            throw new SystemException("DATABASE_ERROR", 
                "数据库访问异常", 
                "Database error finding user: " + id, e);
        }
    }
}

// ✅ 正确：全局异常处理器
@ControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException e) {
        log.warn("Business exception: code={}, message={}", e.getErrorCode(), e.getMessage());
        return ResponseEntity.status(400)
            .body(ApiResponse.error(e.getErrorCode(), e.getUserMessage()));
    }
    
    @ExceptionHandler(SystemException.class)
    public ResponseEntity<ApiResponse<Void>> handleSystemException(SystemException e) {
        log.error("System exception: code={}, message={}", e.getErrorCode(), e.getMessage(), e);
        return ResponseEntity.status(500)
            .body(ApiResponse.error(e.getErrorCode(), e.getUserMessage()));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleUnexpectedException(Exception e) {
        String errorId = UUID.randomUUID().toString();
        log.error("Unexpected exception: errorId={}", errorId, e);
        return ResponseEntity.status(500)
            .body(ApiResponse.error("SYSTEM_ERROR", 
                "系统异常，请联系管理员。错误ID: " + errorId));
    }
}
```

#### 4.9.2 异常捕获与处理 🟡

##### 4.9.2.1 try-catch使用检查

**1. 检测目标**

a. 避免捕获过于宽泛的异常
b. 不能忽略或吞掉异常
c. 异常处理必须有明确的业务逻辑
d. 必须记录异常日志
e. 异常重新抛出必须保留原始信息

**2. 检测方法**

a. 代码审查：检查 try-catch 块
b. 静态分析：检测空 catch 块和异常吞没
c. 日志检查：验证异常日志记录
d. 测试验证：确认异常处理逻辑正确

**3. 错误示例**

```java
// ❌ 错误：捕获过于宽泛的异常
public class FileProcessor {
    public void processFile(String path) {
        try {
            // 文件处理逻辑
            Files.readAllLines(Paths.get(path));
        } catch (Exception e) { // 过于宽泛
            // 忽略所有异常
        }
    }
}

// ❌ 错误：异常信息丢失
public class DataService {
    public void saveData(Data data) {
        try {
            dataRepository.save(data);
        } catch (DataAccessException e) {
            // 重新抛出时丢失原始异常信息
            throw new RuntimeException("保存失败");
        }
    }
}

// ❌ 错误：异常处理不当
public class ApiService {
    public String callExternalApi(String url) {
        try {
            return restTemplate.getForObject(url, String.class);
        } catch (RestClientException e) {
            // 返回null而不是处理异常
            return null;
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：精确的异常捕获和处理
@Service
public class FileProcessor {
    private static final Logger log = LoggerFactory.getLogger(FileProcessor.class);
    
    public List<String> processFile(String path) {
        try {
            return Files.readAllLines(Paths.get(path));
            
        } catch (NoSuchFileException e) {
            log.warn("File not found: {}", path);
            throw new BusinessException("FILE_NOT_FOUND", "文件不存在");
            
        } catch (AccessDeniedException e) {
            log.warn("Access denied to file: {}", path);
            throw new BusinessException("FILE_ACCESS_DENIED", "文件访问被拒绝");
            
        } catch (IOException e) {
            log.error("IO error reading file: {}", path, e);
            throw new SystemException("FILE_IO_ERROR", 
                "文件读取失败", 
                "IO error reading file: " + path, e);
        }
    }
}

// ✅ 正确：保留异常信息的重新抛出
@Service
public class DataService {
    private static final Logger log = LoggerFactory.getLogger(DataService.class);
    
    @Transactional
    public void saveData(Data data) {
        try {
            validateData(data);
            dataRepository.save(data);
            log.info("Data saved successfully: id={}", data.getId());
            
        } catch (ValidationException e) {
            log.warn("Data validation failed: {}", e.getMessage());
            throw e; // 业务异常直接重新抛出
            
        } catch (DataIntegrityViolationException e) {
            log.error("Data integrity violation: {}", e.getMessage());
            throw new BusinessException("DATA_DUPLICATE", 
                "数据已存在", 
                "Data integrity violation for: " + data.getId());
                
        } catch (DataAccessException e) {
            log.error("Database error saving data: id={}", data.getId(), e);
            throw new SystemException("DATABASE_ERROR", 
                "系统繁忙，请稍后重试", 
                "Database error saving data: " + data.getId(), e);
        }
    }
}

// ✅ 正确：外部服务调用异常处理
@Service
public class ApiService {
    private static final Logger log = LoggerFactory.getLogger(ApiService.class);
    
    @Retryable(value = {ResourceAccessException.class}, maxAttempts = 3)
    public ApiResponse callExternalApi(String url, Object request) {
        try {
            log.debug("Calling external API: {}", url);
            ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
                url, request, ApiResponse.class);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                return response.getBody();
            } else {
                throw new BusinessException("API_ERROR", 
                    "外部服务调用失败", 
                    "API returned non-success status: " + response.getStatusCode());
            }
            
        } catch (ResourceAccessException e) {
            log.warn("API call timeout or connection error: {}", url, e);
            throw e; // 让重试机制处理
            
        } catch (HttpClientErrorException e) {
            log.error("API client error: {} - {}", url, e.getStatusCode(), e);
            throw new BusinessException("API_CLIENT_ERROR", 
                "请求参数错误", 
                "API client error: " + e.getStatusCode());
                
        } catch (HttpServerErrorException e) {
            log.error("API server error: {} - {}", url, e.getStatusCode(), e);
            throw new SystemException("API_SERVER_ERROR", 
                "外部服务暂时不可用", 
                "API server error: " + e.getStatusCode(), e);
                
        } catch (RestClientException e) {
            log.error("Unexpected API error: {}", url, e);
            throw new SystemException("API_UNKNOWN_ERROR", 
                "外部服务调用异常", 
                "Unexpected API error: " + url, e);
        }
    }
}
```

##### 4.9.2.2 异常链保持检查

**1. 检测目标**

a. 重新抛出异常时必须保持原始异常链
b. 异常包装不能丢失根本原因
c. 异常堆栈信息必须完整
d. 异常上下文信息不能丢失
e. 异常转换要保持语义一致性

**2. 检测方法**

a. 代码审查：检查异常重新抛出逻辑
b. 静态分析：检测异常链断裂
c. 单元测试：验证异常链完整性
d. 日志分析：确认异常堆栈完整

**3. 错误示例**

```java
// ❌ 错误：异常链断裂
@Service
public class UserService {
    public User createUser(UserRequest request) {
        try {
            return userRepository.save(request.toUser());
        } catch (DataAccessException e) {
            // 丢失了原始异常信息
            throw new BusinessException("用户创建失败");
        }
    }
}

// ❌ 错误：异常信息不完整
public class FileProcessor {
    public void processFile(String path) {
        try {
            Files.readAllLines(Paths.get(path));
        } catch (IOException e) {
            // 只保留了异常消息，丢失了堆栈信息
            throw new ProcessException("文件处理失败: " + e.getMessage());
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：保持完整异常链
@Service
public class UserService {
    private static final Logger log = LoggerFactory.getLogger(UserService.class);
    
    public User createUser(UserRequest request) {
        try {
            User user = request.toUser();
            return userRepository.save(user);
            
        } catch (DataIntegrityViolationException e) {
            // 保持原始异常链，添加业务上下文
            log.warn("User creation failed - data integrity violation: username={}", 
                request.getUsername(), e);
            throw new BusinessException("USERNAME_EXISTS", 
                "用户名已存在", 
                "User creation failed for username: " + request.getUsername(), e);
                
        } catch (DataAccessException e) {
            // 保持原始异常链，转换为系统异常
            log.error("Database error creating user: username={}", 
                request.getUsername(), e);
            throw new SystemException("DATABASE_ERROR", 
                "用户创建失败", 
                "Database error creating user: " + request.getUsername(), e);
        }
    }
}

// ✅ 正确：异常包装保持上下文
@Component
public class FileProcessor {
    private static final Logger log = LoggerFactory.getLogger(FileProcessor.class);
    
    public ProcessResult processFile(String path) {
        try {
            List<String> lines = Files.readAllLines(Paths.get(path));
            return processLines(lines);
            
        } catch (NoSuchFileException e) {
            // 特定异常类型，保持异常链
            throw new FileNotFoundException("文件不存在: " + path, e);
            
        } catch (AccessDeniedException e) {
            // 特定异常类型，保持异常链
            throw new FileAccessException("文件访问被拒绝: " + path, e);
            
        } catch (IOException e) {
            // 通用IO异常，保持完整异常链和上下文
            log.error("IO error processing file: {}", path, e);
            throw new FileProcessException(
                "文件处理失败", 
                "IO error processing file: " + path, 
                e); // 保持原始异常作为cause
        }
    }
}

// ✅ 正确：异常转换保持语义
@Service
public class PaymentService {
    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);
    
    public PaymentResult processPayment(PaymentRequest request) {
        try {
            return paymentGateway.charge(request);
            
        } catch (PaymentGatewayTimeoutException e) {
            // 超时异常转换为可重试异常，保持异常链
            log.warn("Payment gateway timeout: orderId={}", request.getOrderId(), e);
            throw new RetryableException(
                "支付网关超时", 
                "Payment gateway timeout for order: " + request.getOrderId(), 
                e);
                
        } catch (InsufficientFundsException e) {
            // 业务异常直接转换，保持异常链
            log.info("Insufficient funds: orderId={}, amount={}", 
                request.getOrderId(), request.getAmount());
            throw new BusinessException("INSUFFICIENT_FUNDS", 
                "余额不足", 
                "Insufficient funds for order: " + request.getOrderId(), e);
                
        } catch (PaymentGatewayException e) {
            // 网关异常转换为系统异常，保持异常链
            log.error("Payment gateway error: orderId={}, errorCode={}", 
                request.getOrderId(), e.getErrorCode(), e);
            throw new SystemException("PAYMENT_GATEWAY_ERROR", 
                "支付系统异常", 
                "Payment gateway error: " + e.getErrorCode(), e);
        }
    }
}
```

##### 4.9.2.3 资源清理检查

**1. 检测目标**

a. 异常发生时必须正确清理资源
b. 使用try-with-resources自动管理资源
c. finally块中的清理代码不能抛出异常
d. 资源清理要考虑异常情况
e. 避免资源泄漏

**2. 检测方法**

a. 代码审查：检查资源管理代码
b. 静态分析：检测资源泄漏风险
c. 内存分析：监控资源使用情况
d. 压力测试：验证异常情况下资源清理

**3. 错误示例**

```java
// ❌ 错误：资源没有正确清理
public class FileService {
    public String readFile(String path) throws IOException {
        FileInputStream fis = new FileInputStream(path);
        BufferedReader reader = new BufferedReader(new InputStreamReader(fis));
        
        // 如果这里抛出异常，资源不会被清理
        return reader.lines().collect(Collectors.joining("\n"));
    }
}

// ❌ 错误：finally块中抛出异常
public class DatabaseService {
    public void executeQuery(String sql) {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = dataSource.getConnection();
            stmt = conn.createStatement();
            stmt.execute(sql);
        } catch (SQLException e) {
            throw new RuntimeException("SQL执行失败", e);
        } finally {
            try {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                // finally块中抛出异常会掩盖原始异常
                throw new RuntimeException("资源清理失败", e);
            }
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：使用try-with-resources
@Service
public class FileService {
    private static final Logger log = LoggerFactory.getLogger(FileService.class);
    
    public String readFile(String path) {
        try (FileInputStream fis = new FileInputStream(path);
             BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {
            
            return reader.lines().collect(Collectors.joining("\n"));
            
        } catch (FileNotFoundException e) {
            log.warn("File not found: {}", path);
            throw new BusinessException("FILE_NOT_FOUND", "文件不存在");
            
        } catch (IOException e) {
            log.error("IO error reading file: {}", path, e);
            throw new SystemException("FILE_IO_ERROR", 
                "文件读取失败", 
                "IO error reading file: " + path, e);
        }
    }
    
    public void processLargeFile(String inputPath, String outputPath) {
        try (FileInputStream fis = new FileInputStream(inputPath);
             FileOutputStream fos = new FileOutputStream(outputPath);
             BufferedInputStream bis = new BufferedInputStream(fis);
             BufferedOutputStream bos = new BufferedOutputStream(fos)) {
            
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, bytesRead);
            }
            
        } catch (IOException e) {
            log.error("Error processing file: input={}, output={}", inputPath, outputPath, e);
            throw new SystemException("FILE_PROCESS_ERROR", 
                "文件处理失败", 
                "Error processing file: " + inputPath, e);
        }
    }
}

// ✅ 正确：安全的资源清理
@Repository
public class DatabaseService {
    private static final Logger log = LoggerFactory.getLogger(DatabaseService.class);
    
    public List<Map<String, Object>> executeQuery(String sql, Object... params) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            // 设置参数
            for (int i = 0; i < params.length; i++) {
                stmt.setObject(i + 1, params[i]);
            }
            
            try (ResultSet rs = stmt.executeQuery()) {
                List<Map<String, Object>> results = new ArrayList<>();
                ResultSetMetaData metaData = rs.getMetaData();
                int columnCount = metaData.getColumnCount();
                
                while (rs.next()) {
                    Map<String, Object> row = new HashMap<>();
                    for (int i = 1; i <= columnCount; i++) {
                        row.put(metaData.getColumnName(i), rs.getObject(i));
                    }
                    results.add(row);
                }
                
                return results;
            }
            
        } catch (SQLException e) {
            log.error("Database error executing query: sql={}", sql, e);
            throw new SystemException("DATABASE_ERROR", 
                "数据库查询失败", 
                "Database error executing query: " + sql, e);
        }
    }
    
    // 手动资源管理的安全方式
    public void executeWithManualCleanup(String sql) {
        Connection conn = null;
        PreparedStatement stmt = null;
        
        try {
            conn = dataSource.getConnection();
            stmt = conn.prepareStatement(sql);
            stmt.execute();
            
        } catch (SQLException e) {
            log.error("Database error: sql={}", sql, e);
            throw new SystemException("DATABASE_ERROR", 
                "数据库操作失败", 
                "Database error: " + sql, e);
        } finally {
            // 安全的资源清理，不抛出异常
            closeQuietly(stmt);
            closeQuietly(conn);
        }
    }
    
    private void closeQuietly(AutoCloseable resource) {
        if (resource != null) {
            try {
                resource.close();
            } catch (Exception e) {
                // 记录日志但不抛出异常
                log.warn("Error closing resource: {}", resource.getClass().getSimpleName(), e);
            }
        }
    }
}
```

#### 4.9.3 异常传播与转换 🟡

##### 4.9.3.1 异常转换规范检查

**1. 检测目标**

a. 异常转换必须保持语义一致性
b. 不同层次间异常转换要合理
c. 避免无意义的异常包装
d. 异常转换要保持原始异常信息
e. 转换后的异常要便于上层处理

**2. 检测方法**

a. 代码审查：检查异常转换逻辑
b. 架构审查：验证分层异常设计
c. 单元测试：验证异常转换正确性
d. 集成测试：验证端到端异常处理

**3. 错误示例**

```java
// ❌ 错误：无意义的异常包装
@Service
public class UserService {
    public User findUser(Long id) {
        try {
            return userRepository.findById(id);
        } catch (RuntimeException e) {
            // 无意义的包装，没有添加任何价值
            throw new RuntimeException(e);
        }
    }
}

// ❌ 错误：异常转换丢失语义
@Controller
public class UserController {
    public ResponseEntity<User> getUser(Long id) {
        try {
            User user = userService.findUser(id);
            return ResponseEntity.ok(user);
        } catch (UserNotFoundException e) {
            // 将业务异常转换为技术异常，丢失了业务语义
            throw new RuntimeException("系统错误");
        }
    }
}

// ❌ 错误：异常转换层次混乱
@Repository
public class UserRepository {
    public User save(User user) {
        try {
            return entityManager.persist(user);
        } catch (PersistenceException e) {
            // Repository层抛出Controller层异常，层次混乱
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, "用户保存失败");
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：合理的异常转换
@Repository
public class UserRepository {
    private static final Logger log = LoggerFactory.getLogger(UserRepository.class);
    
    public User findById(Long id) {
        try {
            return entityManager.find(User.class, id);
        } catch (PersistenceException e) {
            // Repository层：将JPA异常转换为数据访问异常
            log.error("Database error finding user: id={}", id, e);
            throw new DataAccessException("USER_FIND_ERROR", 
                "用户查询失败", 
                "Database error finding user: " + id, e);
        }
    }
    
    public User save(User user) {
        try {
            return entityManager.merge(user);
        } catch (ConstraintViolationException e) {
            // 约束违反转换为数据完整性异常
            log.warn("Data integrity violation saving user: username={}", 
                user.getUsername(), e);
            throw new DataIntegrityException("USER_CONSTRAINT_VIOLATION", 
                "用户数据约束违反", 
                "Constraint violation for user: " + user.getUsername(), e);
        } catch (PersistenceException e) {
            // 其他持久化异常转换为数据访问异常
            log.error("Database error saving user: username={}", 
                user.getUsername(), e);
            throw new DataAccessException("USER_SAVE_ERROR", 
                "用户保存失败", 
                "Database error saving user: " + user.getUsername(), e);
        }
    }
}

// ✅ 正确：Service层异常转换
@Service
public class UserService {
    private static final Logger log = LoggerFactory.getLogger(UserService.class);
    
    @Autowired
    private UserRepository userRepository;
    
    public User findUser(Long id) {
        try {
            User user = userRepository.findById(id);
            if (user == null) {
                throw new BusinessException("USER_NOT_FOUND", 
                    "用户不存在", 
                    "User not found: " + id);
            }
            return user;
        } catch (DataAccessException e) {
            // 数据访问异常转换为系统异常
            log.error("System error finding user: id={}", id, e);
            throw new SystemException("USER_SYSTEM_ERROR", 
                "用户查询系统异常", 
                "System error finding user: " + id, e);
        }
    }
    
    public User createUser(UserCreateRequest request) {
        try {
            // 业务验证
            validateUserRequest(request);
            
            User user = new User();
            user.setUsername(request.getUsername());
            user.setEmail(request.getEmail());
            
            return userRepository.save(user);
            
        } catch (DataIntegrityException e) {
            // 数据完整性异常转换为业务异常
            if (e.getMessage().contains("username")) {
                throw new BusinessException("USERNAME_EXISTS", 
                    "用户名已存在", 
                    "Username already exists: " + request.getUsername(), e);
            } else if (e.getMessage().contains("email")) {
                throw new BusinessException("EMAIL_EXISTS", 
                    "邮箱已存在", 
                    "Email already exists: " + request.getEmail(), e);
            } else {
                throw new BusinessException("USER_DATA_CONFLICT", 
                    "用户数据冲突", 
                    "Data conflict creating user: " + request.getUsername(), e);
            }
        } catch (DataAccessException e) {
            // 数据访问异常转换为系统异常
            log.error("System error creating user: username={}", 
                request.getUsername(), e);
            throw new SystemException("USER_CREATE_SYSTEM_ERROR", 
                "用户创建系统异常", 
                "System error creating user: " + request.getUsername(), e);
        }
    }
    
    private void validateUserRequest(UserCreateRequest request) {
        if (StringUtils.isBlank(request.getUsername())) {
            throw new BusinessException("INVALID_USERNAME", 
                "用户名不能为空", 
                "Username is required");
        }
        if (!EmailValidator.isValid(request.getEmail())) {
            throw new BusinessException("INVALID_EMAIL", 
                "邮箱格式不正确", 
                "Invalid email format: " + request.getEmail());
        }
    }
}

// ✅ 正确：Controller层异常转换
@RestController
@RequestMapping("/api/users")
public class UserController {
    private static final Logger log = LoggerFactory.getLogger(UserController.class);
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public ResponseEntity<UserResponse> getUser(@PathVariable Long id) {
        try {
            User user = userService.findUser(id);
            UserResponse response = UserResponse.from(user);
            return ResponseEntity.ok(response);
            
        } catch (BusinessException e) {
            // 业务异常转换为HTTP异常，保持业务语义
            log.info("Business error getting user: id={}, code={}", 
                id, e.getErrorCode());
            
            if ("USER_NOT_FOUND".equals(e.getErrorCode())) {
                throw new HttpNotFoundException("用户不存在", 
                    "User not found: " + id, e);
            } else {
                throw new HttpBadRequestException(e.getUserMessage(), 
                    e.getDetailMessage(), e);
            }
            
        } catch (SystemException e) {
            // 系统异常转换为HTTP服务器错误
            log.error("System error getting user: id={}", id, e);
            throw new HttpInternalServerErrorException("系统异常", 
                "System error getting user: " + id, e);
        }
    }
    
    @PostMapping
    public ResponseEntity<UserResponse> createUser(@RequestBody @Valid UserCreateRequest request) {
        try {
            User user = userService.createUser(request);
            UserResponse response = UserResponse.from(user);
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
            
        } catch (BusinessException e) {
            // 业务异常转换为相应的HTTP状态码
            log.info("Business error creating user: username={}, code={}", 
                request.getUsername(), e.getErrorCode());
            
            switch (e.getErrorCode()) {
                case "USERNAME_EXISTS":
                case "EMAIL_EXISTS":
                case "USER_DATA_CONFLICT":
                    throw new HttpConflictException(e.getUserMessage(), 
                        e.getDetailMessage(), e);
                case "INVALID_USERNAME":
                case "INVALID_EMAIL":
                    throw new HttpBadRequestException(e.getUserMessage(), 
                        e.getDetailMessage(), e);
                default:
                    throw new HttpBadRequestException(e.getUserMessage(), 
                        e.getDetailMessage(), e);
            }
            
        } catch (SystemException e) {
            // 系统异常转换为HTTP服务器错误
            log.error("System error creating user: username={}", 
                request.getUsername(), e);
            throw new HttpInternalServerErrorException("系统异常", 
                "System error creating user: " + request.getUsername(), e);
        }
    }
}
```

##### 4.9.3.2 边界异常处理检查

**1. 检测目标**

a. 系统边界处必须有异常处理
b. 外部调用异常要正确转换
c. 异步处理异常要妥善处理
d. 边界异常要有降级策略
e. 异常处理要考虑事务边界

**2. 检测方法**

a. 代码审查：检查边界异常处理
b. 集成测试：验证外部调用异常
c. 压力测试：验证异常情况下系统稳定性
d. 监控验证：确认异常监控覆盖

**3. 错误示例**

```java
// ❌ 错误：外部调用异常未处理
@Service
public class PaymentService {
    @Autowired
    private PaymentGatewayClient paymentGateway;
    
    public PaymentResult processPayment(PaymentRequest request) {
        // 直接调用外部服务，没有异常处理
        return paymentGateway.charge(request);
    }
}

// ❌ 错误：异步异常处理不当
@Service
public class NotificationService {
    @Async
    public void sendNotification(String message) {
        try {
            emailService.send(message);
        } catch (Exception e) {
            // 异步方法中的异常被吞掉，没有记录
            // 调用方无法知道异常发生
        }
    }
}

// ❌ 错误：事务边界异常处理不当
@Service
@Transactional
public class OrderService {
    public Order createOrder(OrderRequest request) {
        try {
            Order order = new Order(request);
            orderRepository.save(order);
            
            // 外部调用可能失败，但事务已经提交
            inventoryService.reserveItems(order.getItems());
            
            return order;
        } catch (Exception e) {
            // 异常处理不当，可能导致数据不一致
            throw new RuntimeException("订单创建失败");
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：外部调用异常处理
@Service
public class PaymentService {
    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);
    
    @Autowired
    private PaymentGatewayClient paymentGateway;
    
    @Autowired
    private CircuitBreaker circuitBreaker;
    
    public PaymentResult processPayment(PaymentRequest request) {
        return circuitBreaker.executeSupplier(() -> {
            try {
                // 外部调用异常处理
                PaymentResult result = paymentGateway.charge(request);
                log.info("Payment processed successfully: orderId={}, amount={}", 
                    request.getOrderId(), request.getAmount());
                return result;
                
            } catch (PaymentGatewayTimeoutException e) {
                // 超时异常 - 可重试
                log.warn("Payment gateway timeout: orderId={}", request.getOrderId(), e);
                throw new RetryableException("支付网关超时", 
                    "Payment gateway timeout for order: " + request.getOrderId(), e);
                    
            } catch (PaymentGatewayUnavailableException e) {
                // 服务不可用 - 熔断
                log.error("Payment gateway unavailable: orderId={}", request.getOrderId(), e);
                throw new CircuitBreakerException("支付网关不可用", 
                    "Payment gateway unavailable for order: " + request.getOrderId(), e);
                    
            } catch (InsufficientFundsException e) {
                // 业务异常 - 不重试
                log.info("Insufficient funds: orderId={}, amount={}", 
                    request.getOrderId(), request.getAmount());
                throw new BusinessException("INSUFFICIENT_FUNDS", 
                    "余额不足", 
                    "Insufficient funds for order: " + request.getOrderId(), e);
                    
            } catch (PaymentGatewayException e) {
                // 其他网关异常
                log.error("Payment gateway error: orderId={}, errorCode={}", 
                    request.getOrderId(), e.getErrorCode(), e);
                throw new SystemException("PAYMENT_GATEWAY_ERROR", 
                    "支付系统异常", 
                    "Payment gateway error: " + e.getErrorCode(), e);
                    
            } catch (Exception e) {
                // 未知异常
                log.error("Unexpected error processing payment: orderId={}", 
                    request.getOrderId(), e);
                throw new SystemException("PAYMENT_UNEXPECTED_ERROR", 
                    "支付处理异常", 
                    "Unexpected error processing payment for order: " + request.getOrderId(), e);
            }
        });
    }
}

// ✅ 正确：异步异常处理
@Service
public class NotificationService {
    private static final Logger log = LoggerFactory.getLogger(NotificationService.class);
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    @Async
    @Retryable(value = {Exception.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public CompletableFuture<Void> sendNotificationAsync(NotificationRequest request) {
        try {
            emailService.send(request.getEmail(), request.getSubject(), request.getContent());
            log.info("Notification sent successfully: email={}, subject={}", 
                request.getEmail(), request.getSubject());
            
            // 发布成功事件
            eventPublisher.publishEvent(new NotificationSentEvent(request));
            
            return CompletableFuture.completedFuture(null);
            
        } catch (EmailServiceException e) {
            log.error("Email service error: email={}, subject={}", 
                request.getEmail(), request.getSubject(), e);
            
            // 发布失败事件
            eventPublisher.publishEvent(new NotificationFailedEvent(request, e));
            
            // 重新抛出异常，触发重试
            throw new SystemException("EMAIL_SEND_ERROR", 
                "邮件发送失败", 
                "Email send error: " + request.getEmail(), e);
                
        } catch (Exception e) {
            log.error("Unexpected error sending notification: email={}", 
                request.getEmail(), e);
            
            // 发布失败事件
            eventPublisher.publishEvent(new NotificationFailedEvent(request, e));
            
            throw new SystemException("NOTIFICATION_UNEXPECTED_ERROR", 
                "通知发送异常", 
                "Unexpected error sending notification: " + request.getEmail(), e);
        }
    }
    
    @Recover
    public CompletableFuture<Void> recoverNotification(Exception e, NotificationRequest request) {
        log.error("All retry attempts failed for notification: email={}", 
            request.getEmail(), e);
        
        // 发布最终失败事件
        eventPublisher.publishEvent(new NotificationFinallyFailedEvent(request, e));
        
        return CompletableFuture.completedFuture(null);
    }
}

// ✅ 正确：事务边界异常处理
@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Transactional(rollbackFor = Exception.class)
    public Order createOrder(OrderRequest request) {
        try {
            // 1. 创建订单（事务内）
            Order order = new Order(request);
            order.setStatus(OrderStatus.PENDING);
            order = orderRepository.save(order);
            
            log.info("Order created: orderId={}, customerId={}", 
                order.getId(), request.getCustomerId());
            
            return order;
            
        } catch (DataIntegrityViolationException e) {
            log.warn("Data integrity violation creating order: customerId={}", 
                request.getCustomerId(), e);
            throw new BusinessException("ORDER_DATA_CONFLICT", 
                "订单数据冲突", 
                "Data conflict creating order for customer: " + request.getCustomerId(), e);
                
        } catch (Exception e) {
            log.error("Error creating order: customerId={}", 
                request.getCustomerId(), e);
            throw new SystemException("ORDER_CREATE_ERROR", 
                "订单创建失败", 
                "Error creating order for customer: " + request.getCustomerId(), e);
        }
    }
    
    // 分离外部调用，避免事务边界问题
    public OrderResult processOrder(OrderRequest request) {
        Order order = null;
        try {
            // 1. 创建订单（独立事务）
            order = createOrder(request);
            
            // 2. 库存预留（外部调用）
            InventoryReservation reservation = inventoryService.reserveItems(order.getItems());
            
            // 3. 处理支付（外部调用）
            PaymentResult paymentResult = paymentService.processPayment(
                new PaymentRequest(order.getId(), order.getTotalAmount()));
            
            // 4. 更新订单状态（独立事务）
            updateOrderStatus(order.getId(), OrderStatus.CONFIRMED);
            
            log.info("Order processed successfully: orderId={}", order.getId());
            
            return new OrderResult(order, reservation, paymentResult);
            
        } catch (BusinessException e) {
            // 业务异常，回滚订单
            if (order != null) {
                handleOrderFailure(order.getId(), e);
            }
            throw e;
            
        } catch (SystemException e) {
            // 系统异常，回滚订单
            if (order != null) {
                handleOrderFailure(order.getId(), e);
            }
            throw e;
            
        } catch (Exception e) {
            // 未知异常，回滚订单
            if (order != null) {
                handleOrderFailure(order.getId(), e);
            }
            log.error("Unexpected error processing order: customerId={}", 
                request.getCustomerId(), e);
            throw new SystemException("ORDER_PROCESS_ERROR", 
                "订单处理异常", 
                "Unexpected error processing order for customer: " + request.getCustomerId(), e);
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void updateOrderStatus(Long orderId, OrderStatus status) {
        try {
            Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new BusinessException("ORDER_NOT_FOUND", 
                    "订单不存在", "Order not found: " + orderId));
            
            order.setStatus(status);
            order.setUpdatedAt(LocalDateTime.now());
            orderRepository.save(order);
            
            log.info("Order status updated: orderId={}, status={}", orderId, status);
            
        } catch (Exception e) {
            log.error("Error updating order status: orderId={}, status={}", 
                orderId, status, e);
            throw new SystemException("ORDER_STATUS_UPDATE_ERROR", 
                "订单状态更新失败", 
                "Error updating order status: " + orderId, e);
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void handleOrderFailure(Long orderId, Exception cause) {
        try {
            updateOrderStatus(orderId, OrderStatus.FAILED);
            log.warn("Order marked as failed: orderId={}", orderId, cause);
        } catch (Exception e) {
            log.error("Error handling order failure: orderId={}", orderId, e);
        }
    }
}
```

##### 4.9.3.3 全局异常处理检查

**1. 检测目标**

a. 必须有全局异常处理器
b. 异常响应格式要统一
c. 敏感信息不能暴露给客户端
d. 异常要记录完整的上下文信息
e. 不同类型异常要有不同处理策略

**2. 检测方法**

a. 代码审查：检查全局异常处理器
b. 接口测试：验证异常响应格式
c. 安全测试：确认敏感信息不泄露
d. 日志分析：验证异常记录完整性

**3. 错误示例**

```java
// ❌ 错误：没有全局异常处理
@RestController
public class UserController {
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        // 异常直接抛出，没有统一处理
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
}

// ❌ 错误：异常信息暴露过多
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        // 直接返回异常信息，可能暴露敏感信息
        return ResponseEntity.status(500).body(e.getMessage());
    }
}

// ❌ 错误：异常处理不完整
@ControllerAdvice
public class SimpleExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        // 没有记录日志，没有traceId
        return ResponseEntity.badRequest()
            .body(new ErrorResponse(e.getMessage()));
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的全局异常处理
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(
            BusinessException e, HttpServletRequest request) {
        
        String traceId = MDC.get("traceId");
        String requestId = UUID.randomUUID().toString();
        
        // 记录业务异常（INFO级别）
        log.info("Business exception: code={}, message={}, path={}, traceId={}, requestId={}", 
            e.getErrorCode(), e.getUserMessage(), request.getRequestURI(), traceId, requestId);
        
        ErrorResponse response = ErrorResponse.builder()
            .code(e.getErrorCode())
            .message(e.getUserMessage())
            .traceId(traceId)
            .requestId(requestId)
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .build();
            
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }
    
    @ExceptionHandler(SystemException.class)
    public ResponseEntity<ErrorResponse> handleSystemException(
            SystemException e, HttpServletRequest request) {
        
        String traceId = MDC.get("traceId");
        String requestId = UUID.randomUUID().toString();
        
        // 记录系统异常（ERROR级别）
        log.error("System exception: code={}, message={}, path={}, traceId={}, requestId={}", 
            e.getErrorCode(), e.getUserMessage(), request.getRequestURI(), traceId, requestId, e);
        
        ErrorResponse response = ErrorResponse.builder()
            .code("SYSTEM_ERROR")
            .message("系统异常，请稍后重试")
            .traceId(traceId)
            .requestId(requestId)
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .build();
            
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
    
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            ValidationException e, HttpServletRequest request) {
        
        String traceId = MDC.get("traceId");
        String requestId = UUID.randomUUID().toString();
        
        // 记录参数验证异常（WARN级别）
        log.warn("Validation exception: message={}, path={}, traceId={}, requestId={}", 
            e.getMessage(), request.getRequestURI(), traceId, requestId);
        
        ErrorResponse response = ErrorResponse.builder()
            .code("VALIDATION_ERROR")
            .message("参数验证失败")
            .details(e.getValidationErrors())
            .traceId(traceId)
            .requestId(requestId)
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .build();
            
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }
    
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDeniedException(
            AccessDeniedException e, HttpServletRequest request) {
        
        String traceId = MDC.get("traceId");
        String requestId = UUID.randomUUID().toString();
        
        // 记录访问拒绝异常（WARN级别）
        log.warn("Access denied: path={}, user={}, traceId={}, requestId={}", 
            request.getRequestURI(), getCurrentUser(), traceId, requestId);
        
        ErrorResponse response = ErrorResponse.builder()
            .code("ACCESS_DENIED")
            .message("访问被拒绝")
            .traceId(traceId)
            .requestId(requestId)
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .build();
            
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
    }
    
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotSupported(
            HttpRequestMethodNotSupportedException e, HttpServletRequest request) {
        
        String traceId = MDC.get("traceId");
        String requestId = UUID.randomUUID().toString();
        
        log.warn("Method not supported: method={}, path={}, traceId={}, requestId={}", 
            request.getMethod(), request.getRequestURI(), traceId, requestId);
        
        ErrorResponse response = ErrorResponse.builder()
            .code("METHOD_NOT_SUPPORTED")
            .message("请求方法不支持")
            .traceId(traceId)
            .requestId(requestId)
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .build();
            
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(response);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleUnexpectedException(
            Exception e, HttpServletRequest request) {
        
        String traceId = MDC.get("traceId");
        String requestId = UUID.randomUUID().toString();
        
        // 记录未知异常（ERROR级别）
        log.error("Unexpected exception: type={}, message={}, path={}, traceId={}, requestId={}", 
            e.getClass().getSimpleName(), e.getMessage(), request.getRequestURI(), 
            traceId, requestId, e);
        
        ErrorResponse response = ErrorResponse.builder()
            .code("UNEXPECTED_ERROR")
            .message("系统异常，请稍后重试")
            .traceId(traceId)
            .requestId(requestId)
            .timestamp(LocalDateTime.now())
            .path(request.getRequestURI())
            .build();
            
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
    
    private String getCurrentUser() {
        try {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            return auth != null ? auth.getName() : "anonymous";
        } catch (Exception e) {
            return "unknown";
        }
    }
}

// ✅ 正确：统一的错误响应格式
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ErrorResponse {
    private String code;
    private String message;
    private Object details;
    private String traceId;
    private String requestId;
    private LocalDateTime timestamp;
    private String path;
    
    public static ErrorResponseBuilder builder() {
        return new ErrorResponseBuilder();
    }
}

// ✅ 正确：异常监控和告警
@Component
@Slf4j
public class ExceptionMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Counter businessExceptionCounter;
    private final Counter systemExceptionCounter;
    private final Timer exceptionProcessingTimer;
    
    public ExceptionMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.businessExceptionCounter = Counter.builder("exception.business")
            .description("Business exception count")
            .register(meterRegistry);
        this.systemExceptionCounter = Counter.builder("exception.system")
            .description("System exception count")
            .register(meterRegistry);
        this.exceptionProcessingTimer = Timer.builder("exception.processing.time")
            .description("Exception processing time")
            .register(meterRegistry);
    }
    
    @EventListener
    public void handleBusinessException(BusinessExceptionEvent event) {
        businessExceptionCounter.increment(
            Tags.of(
                "code", event.getErrorCode(),
                "service", event.getServiceName()
            )
        );
        
        // 高频业务异常告警
        if (isHighFrequencyException(event.getErrorCode())) {
            sendAlert("High frequency business exception: " + event.getErrorCode());
        }
    }
    
    @EventListener
    public void handleSystemException(SystemExceptionEvent event) {
        systemExceptionCounter.increment(
            Tags.of(
                "code", event.getErrorCode(),
                "service", event.getServiceName()
            )
        );
        
        // 系统异常立即告警
        sendAlert("System exception occurred: " + event.getErrorCode());
    }
    
    private boolean isHighFrequencyException(String errorCode) {
        // 检查异常频率逻辑
        return businessExceptionCounter.count() > 100; // 示例阈值
    }
    
    private void sendAlert(String message) {
        // 发送告警逻辑
        log.warn("ALERT: {}", message);
    }
}
```
e. 异常统计和告警机制完善

**2. 检测方法**

a. 日志审查：检查异常日志格式和内容
b. 安全检查：确认敏感信息不泄露
c. 监控验证：确认异常监控和告警有效
d. 链路追踪：验证异常在分布式系统中的追踪

**3. 错误示例**

```java
// ❌ 错误：日志信息不完整
@Service
public class PaymentService {
    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);
    
    public void processPayment(PaymentRequest request) {
        try {
            paymentGateway.charge(request);
        } catch (Exception e) {
            log.error("Payment failed"); // 缺少上下文信息
            throw e;
        }
    }
}

// ❌ 错误：敏感信息泄露
public class UserService {
    public void login(String username, String password) {
        try {
            authenticate(username, password);
        } catch (AuthenticationException e) {
            // 记录了敏感的密码信息
            log.error("Login failed: username={}, password={}", username, password);
            throw e;
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的异常日志记录
@Service
public class PaymentService {
    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);
    
    public PaymentResult processPayment(PaymentRequest request) {
        String traceId = MDC.get("traceId");
        
        try {
            log.info("Processing payment: orderId={}, amount={}, traceId={}", 
                request.getOrderId(), request.getAmount(), traceId);
                
            PaymentResult result = paymentGateway.charge(request);
            
            log.info("Payment processed successfully: orderId={}, transactionId={}, traceId={}", 
                request.getOrderId(), result.getTransactionId(), traceId);
                
            return result;
            
        } catch (PaymentGatewayException e) {
            // 业务异常使用WARN级别
            log.warn("Payment gateway error: orderId={}, errorCode={}, message={}, traceId={}", 
                request.getOrderId(), e.getErrorCode(), e.getMessage(), traceId);
            throw new BusinessException("PAYMENT_FAILED", 
                "支付失败: " + e.getMessage());
                
        } catch (Exception e) {
            // 系统异常使用ERROR级别，记录完整堆栈
            log.error("System error during payment: orderId={}, traceId={}", 
                request.getOrderId(), traceId, e);
            throw new SystemException("PAYMENT_SYSTEM_ERROR", 
                "支付系统异常", 
                "Payment system error for order: " + request.getOrderId(), e);
        }
    }
}

// ✅ 正确：安全的日志记录
@Service
public class UserService {
    private static final Logger log = LoggerFactory.getLogger(UserService.class);
    
    public LoginResult login(String username, String password) {
        String traceId = MDC.get("traceId");
        
        try {
            log.debug("User login attempt: username={}, traceId={}", username, traceId);
            
            LoginResult result = authenticationService.authenticate(username, password);
            
            log.info("User login successful: username={}, userId={}, traceId={}", 
                username, result.getUserId(), traceId);
                
            return result;
            
        } catch (InvalidCredentialsException e) {
            // 正确：不记录密码，记录失败原因
            log.warn("User login failed: username={}, reason={}, traceId={}", 
                username, e.getMessage(), traceId);
            throw e;
            
        } catch (Exception e) {
            // 正确：系统异常使用ERROR级别，记录完整堆栈
            log.error("System error during login: username={}, traceId={}", 
                username, traceId, e);
            throw new SystemException("Login system error", e);
        }
    }
}

// ✅ 正确：结构化日志配置
// logback-spring.xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/application.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>logs/application.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <mdc/>
                    <message/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>
        
        <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
            <appender-ref ref="FILE"/>
            <queueSize>1024</queueSize>
            <discardingThreshold>0</discardingThreshold>
        </appender>
        
        <root level="INFO">
            <appender-ref ref="ASYNC"/>
        </root>
    </springProfile>
</configuration>
```