# 4.5 数据处理检查

## 4.5.1 数据持久化和完整性检查

### 4.5.1.1 事务管理检查

**1. 检测目标**

a. 事务边界的正确性和完整性。
b. 事务隔离级别的合理性。
c. 事务回滚机制的有效性。
d. 分布式事务的一致性保证。

**2. 检测方法**

1. 事务注解检查（@Transactional使用是否正确）。
2. 事务边界分析（事务范围是否合理）。
3. 隔离级别验证（是否符合业务需求）。
4. 回滚测试（异常情况下的数据一致性）。

**3. 错误示例**

```java
// ❌ 错误：事务边界不当
@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private PaymentService paymentService;
    
    // 没有事务注解，可能导致数据不一致
    public void createOrder(Order order) {
        orderRepository.save(order);
        // 如果这里抛异常，订单已保存但支付未处理
        paymentService.processPayment(order);
    }
    
    // 事务边界过大，影响性能
    @Transactional
    public void processLargeOrderBatch(List<Order> orders) {
        for (Order order : orders) {
            // 长时间持有事务，可能导致锁等待
            complexBusinessLogic(order);
            orderRepository.save(order);
            // 外部服务调用不应在事务中
            externalNotificationService.sendEmail(order);
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：合理的事务管理
@Service
public class OrderService {
    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);
    
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private PaymentService paymentService;
    @Autowired
    private NotificationService notificationService;
    
    @Transactional(rollbackFor = Exception.class)
    public void createOrder(Order order) {
        try {
            // 在同一事务中保证数据一致性
            Order savedOrder = orderRepository.save(order);
            paymentService.createPaymentRecord(savedOrder);
            
            logger.info("订单创建成功: orderId={}", savedOrder.getId());
            
        } catch (Exception e) {
            logger.error("订单创建失败: {}", e.getMessage(), e);
            throw new OrderCreationException("订单创建失败", e);
        }
    }
    
    // 分离事务和非事务操作
    public void processOrderBatch(List<Order> orders) {
        List<Order> processedOrders = new ArrayList<>();
        
        for (Order order : orders) {
            try {
                // 每个订单单独事务
                Order processed = processOrderInTransaction(order);
                processedOrders.add(processed);
            } catch (Exception e) {
                logger.error("订单处理失败: orderId={}", order.getId(), e);
                // 继续处理其他订单
            }
        }
        
        // 事务外发送通知
        sendNotificationsAsync(processedOrders);
    }
    
    @Transactional(rollbackFor = Exception.class)
    private Order processOrderInTransaction(Order order) {
        // 事务内的核心业务逻辑
        order.setStatus(OrderStatus.PROCESSING);
        Order savedOrder = orderRepository.save(order);
        
        // 更新相关数据
        updateInventory(order);
        createShippingRecord(order);
        
        return savedOrder;
    }
    
    @Async
    private void sendNotificationsAsync(List<Order> orders) {
        // 异步发送通知，不影响主事务
        for (Order order : orders) {
            try {
                notificationService.sendOrderConfirmation(order);
            } catch (Exception e) {
                logger.warn("通知发送失败: orderId={}", order.getId(), e);
            }
        }
    }
    
    // 只读事务优化
    @Transactional(readOnly = true)
    public List<Order> findOrdersByStatus(OrderStatus status) {
        return orderRepository.findByStatus(status);
    }
    
    // 指定隔离级别
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void updateOrderWithLock(Long orderId, OrderStatus newStatus) {
        Order order = orderRepository.findByIdForUpdate(orderId)
            .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + orderId));
        
        if (order.getStatus() == newStatus) {
            return; // 状态未变化
        }
        
        order.setStatus(newStatus);
        order.setLastUpdated(LocalDateTime.now());
        orderRepository.save(order);
    }
}
```

### 4.5.1.2 数据验证检查

**1. 检测目标**

a. 输入数据的有效性验证。
b. 业务规则的数据约束检查。
c. 数据格式和类型的正确性。
d. 数据完整性约束的实施。

**2. 检测方法**

1. 参数验证注解检查（@Valid, @NotNull等）。
2. 自定义验证器的实现检查。
3. 数据库约束的一致性验证。
4. 边界值测试和异常数据测试。

**3. 错误示例**

```java
// ❌ 错误：缺少数据验证
@RestController
public class UserController {
    @Autowired
    private UserService userService;
    
    @PostMapping("/users")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // 没有验证用户输入
        User created = userService.createUser(user);
        return ResponseEntity.ok(created);
    }
}

@Service
public class UserService {
    public User createUser(User user) {
        // 没有业务规则验证
        return userRepository.save(user);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的数据验证
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 50, message = "用户名长度必须在3-50字符之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    private String username;
    
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 8, message = "密码长度至少8位")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$", 
             message = "密码必须包含大小写字母和数字")
    private String password;
    
    @Min(value = 18, message = "年龄不能小于18岁")
    @Max(value = 120, message = "年龄不能大于120岁")
    private Integer age;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    // 构造函数、getter、setter
}

@RestController
@Validated
public class UserController {
    private static final Logger logger = LoggerFactory.getLogger(UserController.class);
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/users")
    public ResponseEntity<User> createUser(@Valid @RequestBody CreateUserRequest request) {
        try {
            User created = userService.createUser(request);
            return ResponseEntity.ok(created);
        } catch (ValidationException e) {
            logger.warn("用户创建验证失败: {}", e.getMessage());
            return ResponseEntity.badRequest().build();
        }
    }
    
    @PutMapping("/users/{id}")
    public ResponseEntity<User> updateUser(
            @PathVariable @Min(1) Long id,
            @Valid @RequestBody UpdateUserRequest request) {
        
        User updated = userService.updateUser(id, request);
        return ResponseEntity.ok(updated);
    }
}

@Service
public class UserService {
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);
    
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private UserValidator userValidator;
    
    @Transactional
    public User createUser(CreateUserRequest request) {
        // 1. 基础验证（已通过@Valid完成）
        
        // 2. 业务规则验证
        userValidator.validateForCreation(request);
        
        // 3. 唯一性检查
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new ValidationException("用户名已存在: " + request.getUsername());
        }
        
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new ValidationException("邮箱已被使用: " + request.getEmail());
        }
        
        // 4. 创建用户
        User user = User.builder()
            .username(request.getUsername())
            .email(request.getEmail())
            .password(passwordEncoder.encode(request.getPassword()))
            .age(request.getAge())
            .phone(request.getPhone())
            .createdAt(LocalDateTime.now())
            .build();
        
        User saved = userRepository.save(user);
        logger.info("用户创建成功: userId={}, username={}", saved.getId(), saved.getUsername());
        
        return saved;
    }
}

@Component
public class UserValidator {
    @Autowired
    private UserRepository userRepository;
    
    public void validateForCreation(CreateUserRequest request) {
        // 密码强度检查
        validatePasswordStrength(request.getPassword());
        
        // 年龄合理性检查
        validateAge(request.getAge());
        
        // 手机号归属地检查（如果需要）
        validatePhoneNumber(request.getPhone());
    }
    
    private void validatePasswordStrength(String password) {
        if (password == null || password.length() < 8) {
            throw new ValidationException("密码长度至少8位");
        }
        
        if (!password.matches(".*[a-z].*")) {
            throw new ValidationException("密码必须包含小写字母");
        }
        
        if (!password.matches(".*[A-Z].*")) {
            throw new ValidationException("密码必须包含大写字母");
        }
        
        if (!password.matches(".*\\d.*")) {
            throw new ValidationException("密码必须包含数字");
        }
        
        // 检查常见弱密码
        List<String> weakPasswords = Arrays.asList(
            "12345678", "password", "qwerty123", "abc12345");
        
        if (weakPasswords.contains(password.toLowerCase())) {
            throw new ValidationException("密码过于简单，请使用更复杂的密码");
        }
    }
    
    private void validateAge(Integer age) {
        if (age != null) {
            LocalDate now = LocalDate.now();
            LocalDate birthYear = now.minusYears(age);
            
            if (birthYear.isAfter(now.minusYears(18))) {
                throw new ValidationException("用户年龄不能小于18岁");
            }
            
            if (birthYear.isBefore(now.minusYears(120))) {
                throw new ValidationException("用户年龄不能大于120岁");
            }
        }
    }
    
    private void validatePhoneNumber(String phone) {
        if (phone != null && !phone.matches("^1[3-9]\\d{9}$")) {
            throw new ValidationException("手机号格式不正确");
        }
    }
}
```

### 4.5.1.3 数据备份和恢复检查

**1. 检测目标**

a. 数据备份策略的完整性和可靠性。
b. 备份数据的一致性和完整性验证。
c. 数据恢复流程的有效性和及时性。
d. 备份和恢复的自动化程度。

**2. 检测方法**

1. 备份策略文档审查。
2. 备份数据完整性验证。
3. 恢复流程测试。
4. 备份监控和告警机制检查。

**3. 错误示例**

```java
// ❌ 错误：缺少备份机制
@Service
public class DataService {
    @Autowired
    private DataRepository dataRepository;
    
    public void deleteData(Long id) {
        // 直接删除，没有备份
        dataRepository.deleteById(id);
    }
    
    public void updateCriticalData(CriticalData data) {
        // 直接更新，没有备份原始数据
        dataRepository.save(data);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的数据备份和恢复机制
@Service
public class DataBackupService {
    private static final Logger logger = LoggerFactory.getLogger(DataBackupService.class);
    
    @Autowired
    private DataRepository dataRepository;
    @Autowired
    private DataBackupRepository backupRepository;
    @Autowired
    private BackupStorageService storageService;
    
    @Transactional
    public void deleteDataWithBackup(Long id) {
        // 1. 查找要删除的数据
        Data data = dataRepository.findById(id)
            .orElseThrow(() -> new DataNotFoundException("数据不存在: " + id));
        
        try {
            // 2. 创建备份记录
            DataBackup backup = DataBackup.builder()
                .originalId(data.getId())
                .originalData(JsonUtils.toJson(data))
                .backupType(BackupType.DELETE)
                .backupTime(LocalDateTime.now())
                .operator(SecurityUtils.getCurrentUser())
                .reason("数据删除备份")
                .build();
            
            backupRepository.save(backup);
            
            // 3. 执行删除
            dataRepository.deleteById(id);
            
            logger.info("数据删除成功，已创建备份: dataId={}, backupId={}", 
                id, backup.getId());
                
        } catch (Exception e) {
            logger.error("数据删除失败: dataId={}", id, e);
            throw new DataOperationException("数据删除失败", e);
        }
    }
    
    @Transactional
    public void updateCriticalDataWithBackup(CriticalData newData) {
        Long id = newData.getId();
        
        // 1. 获取原始数据
        CriticalData originalData = dataRepository.findById(id)
            .orElseThrow(() -> new DataNotFoundException("数据不存在: " + id));
        
        try {
            // 2. 创建更新前备份
            DataBackup backup = DataBackup.builder()
                .originalId(originalData.getId())
                .originalData(JsonUtils.toJson(originalData))
                .backupType(BackupType.UPDATE)
                .backupTime(LocalDateTime.now())
                .operator(SecurityUtils.getCurrentUser())
                .reason("关键数据更新备份")
                .build();
            
            backupRepository.save(backup);
            
            // 3. 执行更新
            newData.setLastUpdated(LocalDateTime.now());
            CriticalData updated = dataRepository.save(newData);
            
            // 4. 验证更新结果
            validateDataIntegrity(updated);
            
            logger.info("关键数据更新成功，已创建备份: dataId={}, backupId={}", 
                id, backup.getId());
                
        } catch (Exception e) {
            logger.error("关键数据更新失败: dataId={}", id, e);
            throw new DataOperationException("关键数据更新失败", e);
        }
    }
    
    // 数据恢复功能
    @Transactional
    public void restoreDataFromBackup(Long backupId) {
        DataBackup backup = backupRepository.findById(backupId)
            .orElseThrow(() -> new BackupNotFoundException("备份不存在: " + backupId));
        
        try {
            // 1. 解析备份数据
            Data originalData = JsonUtils.fromJson(backup.getOriginalData(), Data.class);
            
            // 2. 根据备份类型执行恢复
            switch (backup.getBackupType()) {
                case DELETE:
                    // 恢复已删除的数据
                    restoreDeletedData(originalData, backup);
                    break;
                case UPDATE:
                    // 恢复到更新前的状态
                    restoreUpdatedData(originalData, backup);
                    break;
                default:
                    throw new UnsupportedOperationException("不支持的备份类型: " + backup.getBackupType());
            }
            
            // 3. 标记备份为已恢复
            backup.setRestored(true);
            backup.setRestoredAt(LocalDateTime.now());
            backup.setRestoredBy(SecurityUtils.getCurrentUser());
            backupRepository.save(backup);
            
            logger.info("数据恢复成功: backupId={}, originalId={}", 
                backupId, backup.getOriginalId());
                
        } catch (Exception e) {
            logger.error("数据恢复失败: backupId={}", backupId, e);
            throw new DataRestoreException("数据恢复失败", e);
        }
    }
    
    private void restoreDeletedData(Data originalData, DataBackup backup) {
        // 检查是否已存在相同ID的数据
        if (dataRepository.existsById(originalData.getId())) {
            throw new DataRestoreException("数据已存在，无法恢复: " + originalData.getId());
        }
        
        // 恢复数据
        dataRepository.save(originalData);
    }
    
    private void restoreUpdatedData(Data originalData, DataBackup backup) {
        // 获取当前数据
        Data currentData = dataRepository.findById(backup.getOriginalId())
            .orElseThrow(() -> new DataNotFoundException("当前数据不存在: " + backup.getOriginalId()));
        
        // 创建当前数据的备份（用于回滚恢复操作）
        DataBackup rollbackBackup = DataBackup.builder()
            .originalId(currentData.getId())
            .originalData(JsonUtils.toJson(currentData))
            .backupType(BackupType.ROLLBACK)
            .backupTime(LocalDateTime.now())
            .operator(SecurityUtils.getCurrentUser())
            .reason("恢复操作的回滚备份")
            .build();
        
        backupRepository.save(rollbackBackup);
        
        // 恢复到原始状态
        originalData.setLastUpdated(LocalDateTime.now());
        dataRepository.save(originalData);
    }
    
    // 定期备份任务
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void performScheduledBackup() {
        logger.info("开始执行定期数据备份");
        
        try {
            // 1. 获取需要备份的数据
            LocalDateTime cutoffTime = LocalDateTime.now().minusDays(1);
            List<Data> dataToBackup = dataRepository.findModifiedSince(cutoffTime);
            
            // 2. 执行备份
            for (Data data : dataToBackup) {
                try {
                    createScheduledBackup(data);
                } catch (Exception e) {
                    logger.error("单个数据备份失败: dataId={}", data.getId(), e);
                }
            }
            
            // 3. 清理过期备份
            cleanupExpiredBackups();
            
            logger.info("定期数据备份完成，备份数量: {}", dataToBackup.size());
            
        } catch (Exception e) {
            logger.error("定期数据备份失败", e);
        }
    }
    
    private void createScheduledBackup(Data data) {
        DataBackup backup = DataBackup.builder()
            .originalId(data.getId())
            .originalData(JsonUtils.toJson(data))
            .backupType(BackupType.SCHEDULED)
            .backupTime(LocalDateTime.now())
            .operator("SYSTEM")
            .reason("定期自动备份")
            .build();
        
        backupRepository.save(backup);
        
        // 可选：将备份数据存储到外部存储
        storageService.storeBackup(backup);
    }
    
    private void cleanupExpiredBackups() {
        LocalDateTime expireTime = LocalDateTime.now().minusDays(30); // 保留30天
        List<DataBackup> expiredBackups = backupRepository.findExpiredBackups(expireTime);
        
        for (DataBackup backup : expiredBackups) {
            try {
                // 从外部存储删除
                storageService.deleteBackup(backup);
                // 从数据库删除
                backupRepository.delete(backup);
            } catch (Exception e) {
                logger.warn("清理过期备份失败: backupId={}", backup.getId(), e);
            }
        }
        
        logger.info("清理过期备份完成，清理数量: {}", expiredBackups.size());
    }
    
    private void validateDataIntegrity(Data data) {
        // 数据完整性验证逻辑
        if (data.getId() == null) {
            throw new DataIntegrityException("数据ID不能为空");
        }
        
        if (data.getChecksum() != null) {
            String calculatedChecksum = calculateChecksum(data);
            if (!data.getChecksum().equals(calculatedChecksum)) {
                throw new DataIntegrityException("数据校验和不匹配");
            }
        }
    }
    
    private String calculateChecksum(Data data) {
        // 计算数据校验和
        String dataString = JsonUtils.toJson(data);
        return DigestUtils.md5Hex(dataString);
    }
}
```

## 4.5.2 SQL查询优化检查

### 4.5.2.1 索引使用合理性检查

**1. 检测目标**

a. 查询条件字段是否有合适的索引覆盖。
b. 避免索引失效的情况。
c. 复合索引的字段顺序是否合理。
d. 索引的创建和使用是否与业务查询模式一致。

**2. 检测方法**

1. 执行计划分析（EXPLAIN命令）。
2. 索引使用情况监控。
3. 性能测试对比分析。
4. 数据库慢查询日志分析。

**3. 错误示例**

```java
// ❌ 错误：索引使用不当
@Repository
public class ProductRepository extends JpaRepository<Product, Long> {
    // 索引失效：使用函数导致索引失效
    @Query("SELECT p FROM Product p WHERE LOWER(p.name) = LOWER(:name)")
    List<Product> findByNameIgnoreCase(String name);
    
    // 未利用复合索引：索引顺序为(category, price)但查询条件顺序不匹配
    @Query("SELECT p FROM Product p WHERE p.price > :price AND p.category = :category")
    List<Product> findByCategoryAndPriceGreaterThan(String category, BigDecimal price);
    
    // 过滤性不足：在大字段上使用模糊查询
    @Query("SELECT p FROM Product p WHERE p.description LIKE %:keyword%")
    List<Product> findByDescriptionContaining(String keyword);
}

@Service
public class ProductService {
    @Autowired
    private EntityManager entityManager;
    
    // 没有利用索引的原生SQL
    public List<Product> findProductsInStock() {
        return entityManager.createNativeQuery(
            "SELECT * FROM products WHERE quantity > 0", Product.class)
            .getResultList();
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：高效利用索引
@Entity
@Table(name = "products", indexes = {
    @Index(name = "idx_product_category_price", columnList = "category, price"),
    @Index(name = "idx_product_name", columnList = "name"),
    @Index(name = "idx_product_sku", columnList = "sku", unique = true)
})
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    private String category;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;
    
    @Column(nullable = false, unique = true)
    private String sku;
    
    @Column(nullable = false)
    private Integer quantity;
    
    @Column(length = 2000)
    private String description;
    
    // getters and setters
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    // 使用索引字段的精确匹配
    Optional<Product> findBySku(String sku);
    
    // 符合复合索引顺序(category, price)
    List<Product> findByCategoryAndPriceGreaterThan(String category, BigDecimal price);
    
    // 对索引字段使用前缀匹配而非全文搜索
    List<Product> findByNameStartingWith(String namePrefix);
    
    // 明确排序，避免额外的排序操作
    @Query("SELECT p FROM Product p WHERE p.category = :category ORDER BY p.price ASC")
    List<Product> findByCategoryOrderByPriceAsc(String category);
}

@Service
public class ProductService {
    private static final Logger logger = LoggerFactory.getLogger(ProductService.class);
    
    @Autowired
    private ProductRepository productRepository;
    @Autowired
    private EntityManager entityManager;
    
    public List<Product> findProductsByFilters(ProductSearchCriteria criteria) {
        try {
            // 构建利用索引的查询
            CriteriaBuilder cb = entityManager.getCriteriaBuilder();
            CriteriaQuery<Product> query = cb.createQuery(Product.class);
            Root<Product> product = query.from(Product.class);
            
            List<Predicate> predicates = new ArrayList<>();
            
            // 优先使用精确匹配条件（利用索引）
            if (criteria.getCategory() != null) {
                predicates.add(cb.equal(product.get("category"), criteria.getCategory()));
            }
            
            if (criteria.getMinPrice() != null) {
                predicates.add(cb.greaterThanOrEqualTo(product.get("price"), criteria.getMinPrice()));
            }
            
            if (criteria.getMaxPrice() != null) {
                predicates.add(cb.lessThanOrEqualTo(product.get("price"), criteria.getMaxPrice()));
            }
            
            // 分词搜索名称，利用索引
            if (criteria.getNameKeyword() != null) {
                String[] keywords = criteria.getNameKeyword().split("\\s+");
                for (String keyword : keywords) {
                    predicates.add(cb.like(product.get("name"), keyword + "%"));
                }
            }
            
            query.where(predicates.toArray(new Predicate[0]));
            
            // 添加符合索引的排序，避免额外排序
            if ("price".equals(criteria.getSortBy())) {
                query.orderBy(criteria.isAscending() 
                    ? cb.asc(product.get("price")) 
                    : cb.desc(product.get("price")));
            } else {
                query.orderBy(cb.asc(product.get("category")), cb.asc(product.get("name")));
            }
            
            // 使用分页减少结果集大小
            TypedQuery<Product> typedQuery = entityManager.createQuery(query);
            typedQuery.setFirstResult(criteria.getOffset());
            typedQuery.setMaxResults(criteria.getLimit());
            
            return typedQuery.getResultList();
            
        } catch (Exception e) {
            logger.error("查询产品失败: {}", e.getMessage(), e);
            throw new ProductSearchException("查询产品失败", e);
        }
    }
    
    // 对于需要全文搜索的场景，使用专门的搜索引擎
    @Autowired
    private ProductSearchEngine searchEngine;
    
    public List<Product> fullTextSearch(String keyword, int page, int size) {
        // 使用搜索引擎进行全文搜索，而不是数据库索引
        SearchResult<Product> result = searchEngine.search(keyword, page, size);
        return result.getItems();
    }
    
    // 分析查询性能
    public void analyzeQueryPerformance(String category) {
        long startTime = System.currentTimeMillis();
        List<Product> products = productRepository.findByCategoryOrderByPriceAsc(category);
        long endTime = System.currentTimeMillis();
        
        logger.info("查询性能: category={}, 结果数量={}, 耗时={}ms", 
            category, products.size(), (endTime - startTime));
    }
}
```

### 4.5.2.2 大数据量查询优化检查

**1. 检测目标**

a. 分页查询的正确实现。
b. 大结果集的高效处理策略。
c. 长事务的合理拆分。
d. 避免一次性加载过多数据。

**2. 检测方法**

1. 性能测试（大数据量环境）。
2. 代码审查（分页实现、流式查询）。
3. 内存使用监控。
4. 查询超时和事务持有时间分析。

**3. 错误示例**

```java
// ❌ 错误：大数据量查询处理不当
@Service
public class ReportService {
    @Autowired
    private TransactionRepository transactionRepository;
    
    // 错误：一次性加载所有数据到内存
    public BigDecimal calculateTotalRevenue() {
        List<Transaction> allTransactions = transactionRepository.findAll();
        
        return allTransactions.stream()
            .map(Transaction::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    // 错误：没有分页处理，可能导致OOM
    public void exportTransactionReport(OutputStream output) {
        List<Transaction> transactions = transactionRepository.findByCreatedAtBetween(
            startDate, endDate);
        
        try (CSVPrinter printer = new CSVPrinter(
                new OutputStreamWriter(output), CSVFormat.DEFAULT)) {
            for (Transaction txn : transactions) {
                printer.printRecord(
                    txn.getId(), 
                    txn.getCreatedAt(), 
                    txn.getAmount(), 
                    txn.getCustomerName()
                );
            }
        }
    }
    
    // 错误：简单偏移分页，性能随页数增加而恶化
    public Page<Transaction> getTransactionHistory(int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return transactionRepository.findAll(pageable);
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：高效处理大数据量查询
@Service
public class ReportService {
    private static final Logger logger = LoggerFactory.getLogger(ReportService.class);
    private static final int BATCH_SIZE = 1000;
    
    @Autowired
    private TransactionRepository transactionRepository;
    @Autowired
    private EntityManager entityManager;
    
    // 使用流式查询计算聚合值
    @Transactional(readOnly = true)
    public BigDecimal calculateTotalRevenue() {
        logger.info("开始计算总收入");
        BigDecimal total = BigDecimal.ZERO;
        
        try (Stream<Transaction> stream = transactionRepository.streamAll()) {
            total = stream
                .map(Transaction::getAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        }
        
        logger.info("总收入计算完成: {}", total);
        return total;
    }
    
    // 使用批处理导出大量数据
    public void exportTransactionReport(OutputStream output, LocalDate startDate, LocalDate endDate) {
        logger.info("开始导出交易报告: startDate={}, endDate={}", startDate, endDate);
        
        try (CSVPrinter printer = new CSVPrinter(
                new OutputStreamWriter(output), CSVFormat.DEFAULT)) {
            
            // 打印表头
            printer.printRecord("ID", "日期", "金额", "客户");
            
            // 使用游标方式分批处理
            ScrollableResults cursor = entityManager
                .createQuery("SELECT t FROM Transaction t WHERE t.createdAt BETWEEN :start AND :end ORDER BY t.id")
                .setParameter("start", startDate.atStartOfDay())
                .setParameter("end", endDate.atTime(23, 59, 59))
                .setFetchSize(BATCH_SIZE)
                .scroll(ScrollMode.FORWARD_ONLY);
            
            int count = 0;
            while (cursor.next()) {
                Transaction txn = (Transaction) cursor.get(0);
                printer.printRecord(
                    txn.getId(), 
                    txn.getCreatedAt(), 
                    txn.getAmount(), 
                    txn.getCustomerName()
                );
                
                if (++count % BATCH_SIZE == 0) {
                    // 定期清理持久化上下文，防止内存溢出
                    entityManager.clear();
                    logger.debug("已导出 {} 条记录", count);
                }
            }
            
            logger.info("交易报告导出完成，总记录数: {}", count);
            
        } catch (Exception e) {
            logger.error("导出交易报告失败: {}", e.getMessage(), e);
            throw new ReportGenerationException("导出交易报告失败", e);
        }
    }
    
    // 使用基于主键的分页方法，避免深度分页问题
    public List<Transaction> getTransactionHistory(Long lastId, int limit) {
        if (lastId == null) {
            // 第一页
            return transactionRepository
                .findTop50ByOrderByIdDesc();
        } else {
            // 后续分页，基于上一页的最后一个ID
            return transactionRepository
                .findByIdLessThanOrderByIdDesc(lastId, PageRequest.of(0, limit));
        }
    }
    
    // 使用并行处理大数据集
    public void processLargeDataSet(LocalDate date) {
        logger.info("开始处理大数据集: date={}", date);
        
        // 1. 先获取需要处理的ID列表
        List<Long> ids = transactionRepository.findIdsByDate(date);
        int totalCount = ids.size();
        
        logger.info("需处理数据总量: {}", totalCount);
        
        // 2. 分批处理
        List<List<Long>> batches = Lists.partition(ids, BATCH_SIZE);
        
        AtomicInteger processedCount = new AtomicInteger(0);
        
        batches.parallelStream().forEach(batchIds -> {
            processBatch(batchIds);
            
            int current = processedCount.addAndGet(batchIds.size());
            logger.info("数据处理进度: {}/{} ({}%)", 
                current, totalCount, (current * 100 / totalCount));
        });
        
        logger.info("大数据集处理完成");
    }
    
    @Transactional
    public void processBatch(List<Long> batchIds) {
        try {
            List<Transaction> transactions = transactionRepository.findAllById(batchIds);
            
            for (Transaction txn : transactions) {
                // 处理单个交易
                processTransaction(txn);
            }
            
            // 清理持久化上下文
            entityManager.flush();
            entityManager.clear();
            
        } catch (Exception e) {
            logger.error("批处理失败: {}", e.getMessage(), e);
            throw new BatchProcessingException("批处理失败", e);
        }
    }
    
    // 复杂聚合查询优化
    public List<MonthlySummary> getMonthlySummaries(int year) {
        // 将聚合运算放在数据库端执行，而不是应用端
        return entityManager.createQuery(
            "SELECT new com.example.dto.MonthlySummary(" +
            "   MONTH(t.createdAt), " +
            "   COUNT(t), " +
            "   SUM(t.amount)) " +
            "FROM Transaction t " +
            "WHERE YEAR(t.createdAt) = :year " +
            "GROUP BY MONTH(t.createdAt) " +
            "ORDER BY MONTH(t.createdAt)",
            MonthlySummary.class)
            .setParameter("year", year)
            .getResultList();
    }
}

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    // 流式查询
    @QueryHints(value = @QueryHint(name = HINT_FETCH_SIZE, value = "1000"))
    Stream<Transaction> streamAll();
    
    // ID列表查询
    @Query("SELECT t.id FROM Transaction t WHERE DATE(t.createdAt) = :date")
    List<Long> findIdsByDate(LocalDate date);
    
    // 基于主键的高效分页
    List<Transaction> findTop50ByOrderByIdDesc();
    
    List<Transaction> findByIdLessThanOrderByIdDesc(Long id, Pageable pageable);
}
```

### 4.5.2.3 N+1查询问题检查

**1. 检测目标**

a. 识别并消除N+1查询模式。
b. 合理使用延迟加载和急切加载。
c. 批量获取关联数据。
d. 优化关联实体的查询。

**2. 检测方法**

1. SQL日志分析。
2. 性能测试和监控。
3. 代码审查（特别关注循环中的数据库查询）。
4. ORM映射配置检查。

**3. 错误示例**

```java
// ❌ 错误：典型的N+1查询问题
@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private ProductRepository productRepository;
    
    // N+1问题：首先查询所有订单，然后每个订单单独查询商品
    public List<OrderDTO> getRecentOrders() {
        List<Order> orders = orderRepository.findTop10ByOrderByCreatedAtDesc();
        List<OrderDTO> result = new ArrayList<>();
        
        for (Order order : orders) {
            OrderDTO dto = new OrderDTO();
            dto.setId(order.getId());
            dto.setOrderNumber(order.getOrderNumber());
            dto.setTotalAmount(order.getTotalAmount());
            
            // 每个订单都需要额外查询，导致N+1问题
            List<OrderItem> items = order.getItems(); // 触发懒加载，产生额外查询
            List<OrderItemDTO> itemDTOs = new ArrayList<>();
            
            for (OrderItem item : items) {
                OrderItemDTO itemDTO = new OrderItemDTO();
                itemDTO.setId(item.getId());
                itemDTO.setQuantity(item.getQuantity());
                
                // 再次触发懒加载，产生额外查询
                Product product = item.getProduct();
                itemDTO.setProductId(product.getId());
                itemDTO.setProductName(product.getName());
                itemDTO.setProductPrice(product.getPrice());
                
                itemDTOs.add(itemDTO);
            }
            
            dto.setItems(itemDTOs);
            result.add(dto);
        }
        
        return result;
    }
    
    // 循环中执行查询
    public void processOrderItems(Long orderId) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + orderId));
        
        List<OrderItem> items = order.getItems();
        
        for (OrderItem item : items) {
            // 在循环中查询，导致N+1问题
            Product product = productRepository.findById(item.getProductId())
                .orElseThrow(() -> new ProductNotFoundException("商品不存在: " + item.getProductId()));
                
            processOrderItem(item, product);
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：解决N+1查询问题
@Service
public class OrderService {
    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);
    
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private ProductRepository productRepository;
    
    // 使用JOIN FETCH解决N+1问题
    public List<OrderDTO> getRecentOrders() {
        logger.debug("获取最近订单及其明细");
        
        // 一次性查询订单及其关联数据
        List<Order> orders = orderRepository.findRecentOrdersWithDetails();
        List<OrderDTO> result = new ArrayList<>();
        
        for (Order order : orders) {
            OrderDTO dto = new OrderDTO();
            dto.setId(order.getId());
            dto.setOrderNumber(order.getOrderNumber());
            dto.setTotalAmount(order.getTotalAmount());
            
            // 不会触发额外查询，因为数据已经预加载
            List<OrderItemDTO> itemDTOs = order.getItems().stream()
                .map(item -> {
                    OrderItemDTO itemDTO = new OrderItemDTO();
                    itemDTO.setId(item.getId());
                    itemDTO.setQuantity(item.getQuantity());
                    
                    // 不会触发额外查询
                    Product product = item.getProduct();
                    itemDTO.setProductId(product.getId());
                    itemDTO.setProductName(product.getName());
                    itemDTO.setProductPrice(product.getPrice());
                    
                    return itemDTO;
                })
                .collect(Collectors.toList());
            
            dto.setItems(itemDTOs);
            result.add(dto);
        }
        
        return result;
    }
    
    // 使用批量查询替代循环查询
    public void processOrderItems(Long orderId) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + orderId));
        
        List<OrderItem> items = order.getItems();
        
        // 提取商品ID
        Set<Long> productIds = items.stream()
            .map(OrderItem::getProductId)
            .collect(Collectors.toSet());
        
        // 一次性批量查询所有商品
        Map<Long, Product> productMap = productRepository.findAllById(productIds)
            .stream()
            .collect(Collectors.toMap(Product::getId, Function.identity()));
        
        // 处理订单项
        for (OrderItem item : items) {
            Product product = productMap.get(item.getProductId());
            if (product == null) {
                logger.warn("商品不存在: productId={}, orderItemId={}", 
                    item.getProductId(), item.getId());
                continue;
            }
            
            processOrderItem(item, product);
        }
    }
    
    // DTO投影，只查询需要的字段
    public List<OrderSummaryDTO> getOrderSummaries(LocalDate date) {
        return orderRepository.findOrderSummariesByDate(date);
    }
}

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    // 使用JOIN FETCH预加载关联实体
    @Query("SELECT o FROM Order o " +
           "JOIN FETCH o.items i " +
           "JOIN FETCH i.product " +
           "WHERE o.status = 'COMPLETED' " +
           "ORDER BY o.createdAt DESC")
    List<Order> findRecentOrdersWithDetails();
    
    // 使用命名实体图预加载
    @EntityGraph(attributePaths = {"items", "items.product"})
    List<Order> findTop10ByStatusOrderByCreatedAtDesc(OrderStatus status);
    
    // 使用DTO投影优化查询
    @Query("SELECT new com.example.dto.OrderSummaryDTO(" +
           "   o.id, o.orderNumber, o.totalAmount, COUNT(i), " +
           "   SUM(i.quantity), MAX(p.name)) " +
           "FROM Order o " +
           "JOIN o.items i " +
           "JOIN i.product p " +
           "WHERE DATE(o.createdAt) = :date " +
           "GROUP BY o.id, o.orderNumber, o.totalAmount")
    List<OrderSummaryDTO> findOrderSummariesByDate(LocalDate date);
}

@Entity
@Table(name = "orders")
@NamedEntityGraph(
    name = "Order.withItemsAndProducts",
    attributeNodes = {
        @NamedAttributeNode(value = "items", subgraph = "items-subgraph")
    },
    subgraphs = {
        @NamedSubgraph(
            name = "items-subgraph",
            attributeNodes = @NamedAttributeNode("product")
        )
    }
)
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String orderNumber;
    
    @Column(nullable = false)
    private BigDecimal totalAmount;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private OrderStatus status;
    
    @Column(nullable = false)
    private LocalDateTime createdAt;
    
    // 根据访问模式选择合适的加载策略
    // 如果订单几乎总是需要查看明细，设为EAGER
    // 如果大多数场景只查看订单，不查看明细，设为LAZY
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List<OrderItem> items;
    
    // getters and setters
}

@Service
public class ProductBatchService {
    private static final Logger logger = LoggerFactory.getLogger(ProductBatchService.class);
    private static final int BATCH_SIZE = 100;
    
    @Autowired
    private ProductRepository productRepository;
    @Autowired
    private PriceCalculationService priceService;
    
    // 批量处理大量商品更新
    @Transactional
    public void updateProductPrices(List<Long> productIds) {
        logger.info("开始批量更新商品价格，共 {} 个商品", productIds.size());
        
        // 分批处理，避免一次性加载太多数据
        Lists.partition(productIds, BATCH_SIZE).forEach(batchIds -> {
            List<Product> products = productRepository.findAllById(batchIds);
            
            // 一次获取所有所需的外部数据
            Map<String, ExchangeRate> exchangeRates = 
                priceService.getExchangeRates(products.stream()
                    .map(Product::getCurrency)
                    .collect(Collectors.toSet()));
                    
            Map<String, TaxRate> taxRates = 
                priceService.getTaxRates(products.stream()
                    .map(Product::getCategory)
                    .collect(Collectors.toSet()));
            
            // 批量处理产品
            for (Product product : products) {
                ExchangeRate rate = exchangeRates.get(product.getCurrency());
                TaxRate tax = taxRates.get(product.getCategory());
                
                // 计算新价格
                BigDecimal newPrice = priceService.calculatePrice(
                    product, rate, tax);
                    
                product.setPrice(newPrice);
                product.setLastUpdated(LocalDateTime.now());
            }
            
            // 批量保存
            productRepository.saveAll(products);
            logger.debug("已更新 {} 个商品价格", products.size());
        });
        
        logger.info("商品价格批量更新完成");
    }
}