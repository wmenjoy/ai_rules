# 4.21 逻辑完整性检查

## 4.21.1 业务逻辑完整性

### 4.21.1.1 业务流程完整性检查 🔴

**1. 检测目标**

a. 验证业务流程的完整性和正确性
b. 确保所有业务场景都被正确处理
c. 检查业务规则的一致性实现

**2. 检测方法**

1. 业务流程图对照检查
2. 状态机验证
3. 业务规则测试
4. 端到端测试

**3. 错误示例**

```java
// ❌ 业务流程不完整，缺少关键步骤
public class OrderProcessService {
    
    public void processOrder(Long orderId) {
        Order order = orderRepository.findById(orderId).orElse(null);
        
        // 直接处理订单，缺少状态检查
        order.setStatus(OrderStatus.PROCESSING);
        orderRepository.save(order);
        
        // 缺少：订单状态验证
        // 缺少：库存再次确认
        // 缺少：支付状态检查
        // 缺少：业务规则验证
        // 缺少：异常情况处理
    }
    
    public void completeOrder(Long orderId) {
        Order order = orderRepository.findById(orderId).orElse(null);
        order.setStatus(OrderStatus.COMPLETED);
        orderRepository.save(order);
        
        // 缺少完整的业务流程
        // 缺少：发货确认
        // 缺少：用户通知
        // 缺少：积分奖励
        // 缺少：数据统计更新
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的业务流程处理
public class OrderProcessService {
    
    /**
     * 处理订单 - 完整的业务流程
     */
    @Transactional
    public void processOrder(Long orderId) {
        // 1. 获取并验证订单
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + orderId));
            
        // 2. 验证订单状态
        validateOrderCanBeProcessed(order);
        
        // 3. 验证支付状态
        PaymentStatus paymentStatus = paymentService.getPaymentStatus(order.getPaymentId());
        if (paymentStatus != PaymentStatus.PAID) {
            throw new OrderProcessException("订单未支付，无法处理");
        }
        
        // 4. 再次确认库存
        boolean stockAvailable = inventoryService.confirmStock(order.getItems());
        if (!stockAvailable) {
            handleStockShortage(order);
            return;
        }
        
        // 5. 应用业务规则
        applyBusinessRules(order);
        
        // 6. 更新订单状态
        order.setStatus(OrderStatus.PROCESSING);
        order.setProcessedAt(Instant.now());
        orderRepository.save(order);
        
        // 7. 扣减库存
        inventoryService.deductStock(order.getItems());
        
        // 8. 发布订单处理事件
        eventPublisher.publishEvent(new OrderProcessedEvent(orderId));
        
        // 9. 记录操作日志
        auditService.logOrderOperation(orderId, "ORDER_PROCESSED", getCurrentUser());
    }
    
    /**
     * 完成订单 - 包含所有必要的业务步骤
     */
    @Transactional
    public void completeOrder(Long orderId, String trackingNumber) {
        // 1. 验证订单状态
        Order order = getOrderAndValidateStatus(orderId, OrderStatus.SHIPPED);
        
        // 2. 验证发货信息
        validateShippingInfo(order, trackingNumber);
        
        // 3. 更新订单状态
        order.setStatus(OrderStatus.COMPLETED);
        order.setCompletedAt(Instant.now());
        order.setTrackingNumber(trackingNumber);
        
        // 4. 处理用户积分奖励
        rewardService.processOrderReward(order.getUserId(), order.getTotalAmount());
        
        // 5. 更新用户统计信息
        userStatisticsService.updateOrderStatistics(order.getUserId());
        
        // 6. 发送完成通知
        notificationService.sendOrderCompletionNotification(order);
        
        // 7. 更新商品销量统计
        productStatisticsService.updateSalesStatistics(order.getItems());
        
        // 8. 保存订单
        orderRepository.save(order);
        
        // 9. 发布订单完成事件
        eventPublisher.publishEvent(new OrderCompletedEvent(orderId));
    }
    
    private void validateOrderCanBeProcessed(Order order) {
        if (order.getStatus() != OrderStatus.PENDING_PAYMENT && 
            order.getStatus() != OrderStatus.PAID) {
            throw new OrderProcessException(
                String.format("订单状态不允许处理: %s", order.getStatus()));
        }
    }
    
    private void applyBusinessRules(Order order) {
        // VIP用户优先处理
        if (userService.isVipUser(order.getUserId())) {
            order.setPriority(OrderPriority.HIGH);
        }
        
        // 大额订单需要额外审核
        if (order.getTotalAmount().compareTo(new BigDecimal("10000")) > 0) {
            order.setRequiresApproval(true);
        }
    }
}
```

### 4.21.1.2 边界条件处理检查 🔴

**1. 检测目标**

a. 确保所有输入参数的边界值都被正确处理
b. 验证数组、集合等数据结构的边界访问安全
c. 检查数值计算中的边界情况处理
d. 确保时间、日期等特殊类型的边界处理

**2. 检测方法**

1. 边界值测试（Boundary Value Testing）
2. 等价类划分测试
3. 静态代码分析工具检测
4. 单元测试覆盖边界条件

**3. 错误示例**

```java
// ❌ 缺少边界条件检查
public class UserService {
    
    public User getUserById(Long userId) {
        // 没有检查null值
        return userRepository.findById(userId).get();
    }
    
    public List<User> getUsersByPage(int page, int size) {
        // 没有检查负数和零值
        int offset = page * size;
        return userRepository.findUsers(offset, size);
    }
    
    public String getFirstName(String fullName) {
        // 没有检查空字符串和null
        return fullName.split(" ")[0];
    }
    
    public BigDecimal calculateDiscount(BigDecimal amount, double rate) {
        // 没有检查rate的范围（可能超过100%或为负数）
        return amount.multiply(BigDecimal.valueOf(rate));
    }
    
    public int[] getTopScores(int[] scores, int count) {
        // 没有检查数组长度和count的关系
        Arrays.sort(scores);
        int[] result = new int[count];
        for (int i = 0; i < count; i++) {
            result[i] = scores[scores.length - 1 - i];
        }
        return result;
    }
    
    public LocalDate addWorkingDays(LocalDate startDate, int days) {
        // 没有检查日期边界和天数范围
        LocalDate result = startDate;
        for (int i = 0; i < days; i++) {
            result = result.plusDays(1);
            if (result.getDayOfWeek() == DayOfWeek.SATURDAY) {
                result = result.plusDays(2);
            }
        }
        return result;
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的边界条件处理
public class UserService {
    
    public User getUserById(Long userId) {
        // 检查null值
        if (userId == null) {
            throw new IllegalArgumentException("用户ID不能为空");
        }
        
        // 检查ID的有效范围
        if (userId <= 0) {
            throw new IllegalArgumentException("用户ID必须大于0");
        }
        
        return userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
    }
    
    public List<User> getUsersByPage(int page, int size) {
        // 检查页码边界
        if (page < 0) {
            throw new IllegalArgumentException("页码不能为负数");
        }
        
        // 检查页面大小边界
        if (size <= 0) {
            throw new IllegalArgumentException("页面大小必须大于0");
        }
        
        if (size > 1000) {
            throw new IllegalArgumentException("页面大小不能超过1000");
        }
        
        // 检查计算溢出
        try {
            int offset = Math.multiplyExact(page, size);
            return userRepository.findUsers(offset, size);
        } catch (ArithmeticException e) {
            throw new IllegalArgumentException("页码和页面大小的乘积过大", e);
        }
    }
    
    public String getFirstName(String fullName) {
        // 检查null和空字符串
        if (fullName == null || fullName.trim().isEmpty()) {
            throw new IllegalArgumentException("姓名不能为空");
        }
        
        String trimmedName = fullName.trim();
        
        // 检查是否包含空格
        if (!trimmedName.contains(" ")) {
            return trimmedName; // 只有一个名字
        }
        
        String[] parts = trimmedName.split("\\s+");
        return parts[0];
    }
    
    public BigDecimal calculateDiscount(BigDecimal amount, double rate) {
        // 检查amount边界
        if (amount == null) {
            throw new IllegalArgumentException("金额不能为空");
        }
        
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("金额不能为负数");
        }
        
        // 检查rate边界
        if (rate < 0) {
            throw new IllegalArgumentException("折扣率不能为负数");
        }
        
        if (rate > 1.0) {
            throw new IllegalArgumentException("折扣率不能超过100%");
        }
        
        // 检查计算结果精度
        BigDecimal rateDecimal = BigDecimal.valueOf(rate);
        return amount.multiply(rateDecimal).setScale(2, RoundingMode.HALF_UP);
    }
    
    public int[] getTopScores(int[] scores, int count) {
        // 检查数组边界
        if (scores == null) {
            throw new IllegalArgumentException("分数数组不能为空");
        }
        
        if (scores.length == 0) {
            return new int[0];
        }
        
        // 检查count边界
        if (count < 0) {
            throw new IllegalArgumentException("数量不能为负数");
        }
        
        if (count == 0) {
            return new int[0];
        }
        
        // 调整count不超过数组长度
        int actualCount = Math.min(count, scores.length);
        
        // 复制数组避免修改原数组
        int[] sortedScores = Arrays.copyOf(scores, scores.length);
        Arrays.sort(sortedScores);
        
        int[] result = new int[actualCount];
        for (int i = 0; i < actualCount; i++) {
            result[i] = sortedScores[sortedScores.length - 1 - i];
        }
        
        return result;
    }
    
    public LocalDate addWorkingDays(LocalDate startDate, int days) {
        // 检查日期边界
        if (startDate == null) {
            throw new IllegalArgumentException("开始日期不能为空");
        }
        
        // 检查天数边界
        if (days < 0) {
            throw new IllegalArgumentException("工作日天数不能为负数");
        }
        
        if (days == 0) {
            return startDate;
        }
        
        // 检查日期计算边界（避免溢出）
        if (days > 10000) { // 合理的上限
            throw new IllegalArgumentException("工作日天数过大");
        }
        
        LocalDate result = startDate;
        int addedDays = 0;
        
        while (addedDays < days) {
            result = result.plusDays(1);
            
            // 检查日期是否超出合理范围
            if (result.getYear() > 9999) {
                throw new IllegalArgumentException("计算结果日期超出范围");
            }
            
            // 跳过周末
            if (result.getDayOfWeek() != DayOfWeek.SATURDAY && 
                result.getDayOfWeek() != DayOfWeek.SUNDAY) {
                addedDays++;
            }
        }
        
        return result;
    }
    
    /**
     * 安全的字符串截取，处理各种边界情况
     */
    public String safeSubstring(String str, int start, int end) {
        if (str == null) {
            return null;
        }
        
        if (str.isEmpty()) {
            return "";
        }
        
        int length = str.length();
        
        // 调整start边界
        int safeStart = Math.max(0, Math.min(start, length));
        
        // 调整end边界
        int safeEnd = Math.max(safeStart, Math.min(end, length));
        
        return str.substring(safeStart, safeEnd);
    }
    
    /**
     * 安全的除法运算，处理除零和溢出
     */
    public BigDecimal safeDivide(BigDecimal dividend, BigDecimal divisor, int scale) {
        if (dividend == null || divisor == null) {
            throw new IllegalArgumentException("被除数和除数都不能为空");
        }
        
        if (divisor.compareTo(BigDecimal.ZERO) == 0) {
            throw new ArithmeticException("除数不能为零");
        }
        
        if (scale < 0) {
            throw new IllegalArgumentException("精度不能为负数");
        }
        
        return dividend.divide(divisor, scale, RoundingMode.HALF_UP);
    }
}
```

### 4.21.1.3 并发安全业务逻辑检查 🟡

**1. 检测目标**

a. 确保共享资源的线程安全访问
b. 检测和防止业务逻辑中的竞态条件
c. 验证分布式环境下的并发控制
d. 检查事务隔离级别对业务逻辑的影响

**2. 检测方法**

1. 并发测试工具（JMeter、Gatling）
2. 静态代码分析（FindBugs、SpotBugs）
3. 线程安全性分析工具
4. 分布式锁测试
5. 数据库并发测试

**3. 错误示例**

```java
// ❌ 存在并发安全问题
public class OrderService {
    
    private int orderCounter = 0; // 非线程安全的计数器
    private Map<String, Order> orderCache = new HashMap<>(); // 非线程安全的缓存
    
    // ❌ 竞态条件：检查和更新不是原子操作
    public boolean reserveInventory(String productId, int quantity) {
        Product product = productRepository.findById(productId);
        if (product.getStock() >= quantity) {
            // 在这里可能被其他线程修改
            product.setStock(product.getStock() - quantity);
            productRepository.save(product);
            return true;
        }
        return false;
    }
    
    // ❌ 非线程安全的订单号生成
    public String generateOrderNumber() {
        orderCounter++; // 可能导致重复订单号
        return "ORDER_" + orderCounter;
    }
    
    // ❌ 缓存操作非线程安全
    public Order getOrderFromCache(String orderId) {
        if (!orderCache.containsKey(orderId)) {
            Order order = orderRepository.findById(orderId);
            orderCache.put(orderId, order); // 可能导致数据不一致
        }
        return orderCache.get(orderId);
    }
    
    // ❌ 双重检查锁定模式实现错误
    private static OrderService instance;
    
    public static OrderService getInstance() {
        if (instance == null) {
            synchronized (OrderService.class) {
                if (instance == null) {
                    instance = new OrderService(); // 可能存在指令重排序问题
                }
            }
        }
        return instance;
    }
    
    // ❌ 不安全的余额扣减
    public boolean deductBalance(String userId, BigDecimal amount) {
        User user = userRepository.findById(userId);
        BigDecimal currentBalance = user.getBalance();
        
        if (currentBalance.compareTo(amount) >= 0) {
            // 在这里可能被其他线程修改余额
            user.setBalance(currentBalance.subtract(amount));
            userRepository.save(user);
            return true;
        }
        return false;
    }
    
    // ❌ 批量操作中的并发问题
    public void processBatchOrders(List<Order> orders) {
        for (Order order : orders) {
            // 每个订单的处理可能影响其他订单
            if (reserveInventory(order.getProductId(), order.getQuantity())) {
                order.setStatus(OrderStatus.CONFIRMED);
                orderRepository.save(order);
            }
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：线程安全的业务逻辑实现
@Service
public class OrderService {
    
    private final AtomicLong orderCounter = new AtomicLong(0);
    private final ConcurrentHashMap<String, Order> orderCache = new ConcurrentHashMap<>();
    private final RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    public OrderService(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    
    // ✅ 使用数据库乐观锁防止竞态条件
    @Transactional
    public boolean reserveInventory(String productId, int quantity) {
        try {
            Product product = productRepository.findByIdWithLock(productId);
            
            if (product.getStock() >= quantity) {
                product.setStock(product.getStock() - quantity);
                product.setVersion(product.getVersion() + 1); // 乐观锁版本控制
                productRepository.save(product);
                return true;
            }
            return false;
            
        } catch (OptimisticLockingFailureException e) {
            // 重试机制
            return retryReserveInventory(productId, quantity, 3);
        }
    }
    
    // ✅ 使用分布式锁确保库存扣减的原子性
    public boolean reserveInventoryWithDistributedLock(String productId, int quantity) {
        String lockKey = "inventory_lock_" + productId;
        String lockValue = UUID.randomUUID().toString();
        
        try {
            // 获取分布式锁
            Boolean lockAcquired = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(10));
                
            if (Boolean.TRUE.equals(lockAcquired)) {
                return reserveInventory(productId, quantity);
            } else {
                throw new ConcurrentModificationException("库存正在被其他操作修改");
            }
            
        } finally {
            // 释放锁
            releaseLock(lockKey, lockValue);
        }
    }
    
    // ✅ 线程安全的订单号生成
    public String generateOrderNumber() {
        long counter = orderCounter.incrementAndGet();
        return "ORDER_" + System.currentTimeMillis() + "_" + counter;
    }
    
    // ✅ 使用分布式ID生成器
    public String generateDistributedOrderNumber() {
        // 使用雪花算法或其他分布式ID生成策略
        return snowflakeIdGenerator.nextId();
    }
    
    // ✅ 线程安全的缓存操作
    public Order getOrderFromCache(String orderId) {
        return orderCache.computeIfAbsent(orderId, id -> {
            return orderRepository.findById(id)
                .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + id));
        });
    }
    
    // ✅ 正确的双重检查锁定模式
    private static volatile OrderService instance;
    
    public static OrderService getInstance() {
        if (instance == null) {
            synchronized (OrderService.class) {
                if (instance == null) {
                    instance = new OrderService();
                }
            }
        }
        return instance;
    }
    
    // ✅ 使用数据库行锁确保余额扣减安全
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public boolean deductBalance(String userId, BigDecimal amount) {
        try {
            // 使用SELECT FOR UPDATE获取行锁
            User user = userRepository.findByIdForUpdate(userId);
            
            if (user.getBalance().compareTo(amount) >= 0) {
                user.setBalance(user.getBalance().subtract(amount));
                userRepository.save(user);
                
                // 记录余额变动日志
                balanceLogService.recordDeduction(userId, amount);
                return true;
            }
            return false;
            
        } catch (Exception e) {
            // 事务会自动回滚
            log.error("余额扣减失败: userId={}, amount={}", userId, amount, e);
            throw new BalanceDeductionException("余额扣减失败", e);
        }
    }
    
    // ✅ 使用分布式锁处理批量操作
    public void processBatchOrders(List<Order> orders) {
        // 按产品ID分组，减少锁竞争
        Map<String, List<Order>> ordersByProduct = orders.stream()
            .collect(Collectors.groupingBy(Order::getProductId));
            
        // 并行处理不同产品的订单
        ordersByProduct.entrySet().parallelStream().forEach(entry -> {
            String productId = entry.getKey();
            List<Order> productOrders = entry.getValue();
            
            String lockKey = "batch_process_" + productId;
            String lockValue = UUID.randomUUID().toString();
            
            try {
                if (acquireDistributedLock(lockKey, lockValue, Duration.ofMinutes(5))) {
                    processOrdersForProduct(productOrders);
                }
            } finally {
                releaseLock(lockKey, lockValue);
            }
        });
    }
    
    // ✅ 使用CompletableFuture处理异步并发
    public CompletableFuture<OrderResult> processOrderAsync(Order order) {
        return CompletableFuture
            .supplyAsync(() -> validateOrder(order))
            .thenCompose(validOrder -> 
                CompletableFuture.supplyAsync(() -> reserveInventory(validOrder.getProductId(), validOrder.getQuantity()))
                    .thenApply(reserved -> new OrderProcessContext(validOrder, reserved))
            )
            .thenCompose(context -> {
                if (context.isInventoryReserved()) {
                    return CompletableFuture.supplyAsync(() -> processPayment(context.getOrder()))
                        .thenApply(paymentResult -> new OrderResult(context.getOrder(), paymentResult));
                } else {
                    return CompletableFuture.completedFuture(
                        new OrderResult(context.getOrder(), PaymentResult.failed("库存不足"))
                    );
                }
            })
            .exceptionally(throwable -> {
                log.error("订单处理异常", throwable);
                return new OrderResult(order, PaymentResult.failed("系统异常"));
            });
    }
    
    // ✅ 重试机制处理并发冲突
    private boolean retryReserveInventory(String productId, int quantity, int maxRetries) {
        for (int i = 0; i < maxRetries; i++) {
            try {
                Thread.sleep(100 * (i + 1)); // 指数退避
                return reserveInventory(productId, quantity);
            } catch (OptimisticLockingFailureException e) {
                if (i == maxRetries - 1) {
                    throw new ConcurrentModificationException("库存预留失败，请稍后重试", e);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("操作被中断", e);
            }
        }
        return false;
    }
    
    // ✅ 分布式锁的获取和释放
    private boolean acquireDistributedLock(String lockKey, String lockValue, Duration timeout) {
        return Boolean.TRUE.equals(
            redisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, timeout)
        );
    }
    
    private void releaseLock(String lockKey, String lockValue) {
        String script = 
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "    return redis.call('del', KEYS[1]) " +
            "else " +
            "    return 0 " +
            "end";
            
        redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(lockKey),
            lockValue
        );
    }
    
    // ✅ 使用线程池控制并发度
    private final ThreadPoolExecutor orderProcessingExecutor = new ThreadPoolExecutor(
        10, // 核心线程数
        50, // 最大线程数
        60L, TimeUnit.SECONDS, // 空闲时间
        new LinkedBlockingQueue<>(1000), // 队列大小
        new ThreadFactoryBuilder().setNameFormat("order-processing-%d").build(),
        new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
    );
    
    public void submitOrderProcessing(Order order) {
        orderProcessingExecutor.submit(() -> {
            try {
                processOrder(order);
            } catch (Exception e) {
                log.error("订单处理失败: orderId={}", order.getId(), e);
            }
        });
    }
}
```

## 4.21.2 异常处理完整性

### 4.21.2.1 异常捕获完整性检查 🔴

**1. 检测目标**

a. 确保所有可能的异常都被适当的try-catch块处理
b. 验证异常类型捕获的精确性和完整性
c. 检查第三方库调用的异常处理
d. 确保异步操作中的异常处理

**2. 检测方法**

1. 静态代码分析工具（SonarQube、CheckStyle）
2. 异常路径覆盖测试
3. 代码审查检查异常处理覆盖率
4. 运行时异常监控和日志分析

**3. 错误示例**

```java
// ❌ 异常捕获不完整
public class FileProcessService {
    
    // ❌ 没有处理所有可能的异常
    public String readFileContent(String filePath) {
        try {
            return Files.readString(Paths.get(filePath));
        } catch (IOException e) {
            // 只捕获了IOException，忽略了其他可能的异常
            return "";
        }
        // 没有处理InvalidPathException、SecurityException等
    }
    
    // ❌ 异常类型过于宽泛
    public void processData(String data) {
        try {
            parseJson(data);
            validateData(data);
            saveToDatabase(data);
        } catch (Exception e) {
            // 捕获所有异常，无法区分具体问题
            log.error("处理失败", e);
        }
    }
    
    // ❌ 忽略了第三方库的异常
    public void sendEmail(String to, String subject, String body) {
        EmailSender sender = new EmailSender();
        sender.send(to, subject, body); // 可能抛出多种异常但未处理
    }
    
    // ❌ 异步操作异常处理缺失
    public void processAsync(List<String> items) {
        CompletableFuture.runAsync(() -> {
            for (String item : items) {
                processItem(item); // 异常会被忽略
            }
        });
    }
    
    // ❌ 资源泄漏风险
    public String readFromDatabase(String query) {
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        
        try {
            conn = dataSource.getConnection();
            stmt = conn.prepareStatement(query);
            rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getString(1);
            }
        } catch (SQLException e) {
            log.error("数据库查询失败", e);
        }
        // 没有在finally块中关闭资源
        return null;
    }
    
    // ❌ 嵌套异常处理不当
    public void complexOperation(String input) {
        try {
            String processed = preProcess(input);
            try {
                String validated = validate(processed);
                save(validated);
            } catch (ValidationException e) {
                // 内层异常处理可能掩盖外层问题
                throw new ProcessingException("验证失败");
            }
        } catch (PreProcessException e) {
            log.error("预处理失败", e);
        }
    }
    
    // ❌ 异常信息丢失
    public void handleRequest(HttpServletRequest request) {
        try {
            String data = extractData(request);
            processBusinessLogic(data);
        } catch (DataExtractionException | BusinessLogicException e) {
            // 只记录了异常类型，丢失了具体错误信息
            throw new RuntimeException("请求处理失败");
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的异常捕获处理
public class FileProcessService {
    
    private static final Logger log = LoggerFactory.getLogger(FileProcessService.class);
    
    // ✅ 处理所有可能的异常
    public String readFileContent(String filePath) {
        if (filePath == null || filePath.trim().isEmpty()) {
            throw new IllegalArgumentException("文件路径不能为空");
        }
        
        try {
            Path path = Paths.get(filePath);
            return Files.readString(path, StandardCharsets.UTF_8);
            
        } catch (InvalidPathException e) {
            log.error("无效的文件路径: {}", filePath, e);
            throw new FileProcessException("文件路径格式错误: " + filePath, e);
            
        } catch (NoSuchFileException e) {
            log.error("文件不存在: {}", filePath, e);
            throw new FileProcessException("文件不存在: " + filePath, e);
            
        } catch (AccessDeniedException e) {
            log.error("文件访问被拒绝: {}", filePath, e);
            throw new FileProcessException("没有权限访问文件: " + filePath, e);
            
        } catch (IOException e) {
            log.error("文件读取IO异常: {}", filePath, e);
            throw new FileProcessException("文件读取失败: " + filePath, e);
            
        } catch (OutOfMemoryError e) {
            log.error("文件过大导致内存不足: {}", filePath, e);
            throw new FileProcessException("文件过大，无法读取: " + filePath, e);
            
        } catch (SecurityException e) {
            log.error("安全管理器禁止文件访问: {}", filePath, e);
            throw new FileProcessException("安全限制，无法访问文件: " + filePath, e);
        }
    }
    
    // ✅ 精确的异常类型捕获
    public ProcessResult processData(String data) {
        if (data == null) {
            throw new IllegalArgumentException("数据不能为空");
        }
        
        try {
            // 解析JSON
            JsonNode jsonNode = parseJson(data);
            log.debug("JSON解析成功");
            
            // 验证数据
            ValidationResult validationResult = validateData(jsonNode);
            if (!validationResult.isValid()) {
                return ProcessResult.validationFailed(validationResult.getErrors());
            }
            log.debug("数据验证通过");
            
            // 保存到数据库
            String recordId = saveToDatabase(jsonNode);
            log.info("数据保存成功，记录ID: {}", recordId);
            
            return ProcessResult.success(recordId);
            
        } catch (JsonParseException e) {
            log.error("JSON格式错误: {}", data, e);
            return ProcessResult.jsonParseError("JSON格式错误: " + e.getMessage());
            
        } catch (JsonMappingException e) {
            log.error("JSON映射错误: {}", data, e);
            return ProcessResult.jsonMappingError("JSON结构错误: " + e.getMessage());
            
        } catch (ValidationException e) {
            log.warn("数据验证失败: {}", e.getMessage());
            return ProcessResult.validationFailed(e.getValidationErrors());
            
        } catch (DataAccessException e) {
            log.error("数据库访问异常", e);
            return ProcessResult.databaseError("数据保存失败，请稍后重试");
            
        } catch (DataIntegrityViolationException e) {
            log.error("数据完整性约束违反", e);
            return ProcessResult.dataIntegrityError("数据违反完整性约束");
            
        } catch (Exception e) {
            // 捕获未预期的异常
            log.error("处理数据时发生未预期异常: {}", data, e);
            return ProcessResult.unexpectedError("系统异常，请联系管理员");
        }
    }
    
    // ✅ 第三方库异常的完整处理
    public EmailResult sendEmail(String to, String subject, String body) {
        if (to == null || to.trim().isEmpty()) {
            throw new IllegalArgumentException("收件人地址不能为空");
        }
        
        EmailSender sender = null;
        try {
            sender = emailSenderFactory.createSender();
            
            EmailMessage message = EmailMessage.builder()
                .to(to)
                .subject(subject)
                .body(body)
                .build();
                
            String messageId = sender.send(message);
            log.info("邮件发送成功: to={}, messageId={}", to, messageId);
            
            return EmailResult.success(messageId);
            
        } catch (EmailAddressException e) {
            log.error("邮件地址格式错误: {}", to, e);
            return EmailResult.addressError("邮件地址格式错误: " + to);
            
        } catch (EmailAuthenticationException e) {
            log.error("邮件服务器认证失败", e);
            return EmailResult.authError("邮件服务器认证失败");
            
        } catch (EmailConnectionException e) {
            log.error("邮件服务器连接失败", e);
            return EmailResult.connectionError("无法连接到邮件服务器");
            
        } catch (EmailQuotaExceededException e) {
            log.error("邮件发送配额超限", e);
            return EmailResult.quotaError("邮件发送配额已用完");
            
        } catch (EmailContentException e) {
            log.error("邮件内容格式错误", e);
            return EmailResult.contentError("邮件内容格式错误: " + e.getMessage());
            
        } catch (EmailTimeoutException e) {
            log.error("邮件发送超时", e);
            return EmailResult.timeoutError("邮件发送超时，请稍后重试");
            
        } catch (Exception e) {
            log.error("邮件发送时发生未知异常: to={}", to, e);
            return EmailResult.unknownError("邮件发送失败，请联系管理员");
            
        } finally {
            // 确保资源清理
            if (sender != null) {
                try {
                    sender.close();
                } catch (Exception e) {
                    log.warn("关闭邮件发送器时发生异常", e);
                }
            }
        }
    }
    
    // ✅ 异步操作的异常处理
    public CompletableFuture<List<ProcessResult>> processAsync(List<String> items) {
        if (items == null || items.isEmpty()) {
            return CompletableFuture.completedFuture(Collections.emptyList());
        }
        
        List<CompletableFuture<ProcessResult>> futures = items.stream()
            .map(item -> CompletableFuture
                .supplyAsync(() -> {
                    try {
                        return processItem(item);
                    } catch (ProcessingException e) {
                        log.error("处理项目失败: {}", item, e);
                        return ProcessResult.failed(item, e.getMessage());
                    } catch (Exception e) {
                        log.error("处理项目时发生未预期异常: {}", item, e);
                        return ProcessResult.failed(item, "系统异常");
                    }
                }, asyncExecutor)
                .exceptionally(throwable -> {
                    log.error("异步处理项目时发生异常: {}", item, throwable);
                    return ProcessResult.failed(item, "异步处理异常");
                })
            )
            .collect(Collectors.toList());
            
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList())
            )
            .exceptionally(throwable -> {
                log.error("批量异步处理时发生异常", throwable);
                return items.stream()
                    .map(item -> ProcessResult.failed(item, "批量处理异常"))
                    .collect(Collectors.toList());
            });
    }
    
    // ✅ 使用try-with-resources确保资源清理
    public String readFromDatabase(String query) {
        if (query == null || query.trim().isEmpty()) {
            throw new IllegalArgumentException("查询语句不能为空");
        }
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query);
             ResultSet rs = stmt.executeQuery()) {
             
            if (rs.next()) {
                return rs.getString(1);
            }
            return null;
            
        } catch (SQLTimeoutException e) {
            log.error("数据库查询超时: {}", query, e);
            throw new DatabaseException("查询超时，请稍后重试", e);
            
        } catch (SQLSyntaxErrorException e) {
            log.error("SQL语法错误: {}", query, e);
            throw new DatabaseException("查询语句语法错误", e);
            
        } catch (SQLException e) {
            log.error("数据库查询异常: {}", query, e);
            throw new DatabaseException("数据库查询失败: " + e.getMessage(), e);
            
        } catch (Exception e) {
            log.error("查询数据库时发生未预期异常: {}", query, e);
            throw new DatabaseException("数据库操作异常", e);
        }
    }
    
    // ✅ 合理的异常链处理
    public void complexOperation(String input) {
        if (input == null) {
            throw new IllegalArgumentException("输入不能为空");
        }
        
        String processed = null;
        String validated = null;
        
        try {
            // 预处理阶段
            try {
                processed = preProcess(input);
                log.debug("预处理完成: {}", processed);
                
            } catch (PreProcessException e) {
                log.error("预处理失败: input={}", input, e);
                throw new ComplexOperationException("预处理阶段失败", e);
            }
            
            // 验证阶段
            try {
                validated = validate(processed);
                log.debug("验证完成: {}", validated);
                
            } catch (ValidationException e) {
                log.error("验证失败: processed={}", processed, e);
                throw new ComplexOperationException("验证阶段失败", e);
            }
            
            // 保存阶段
            try {
                save(validated);
                log.info("复杂操作完成: input={}", input);
                
            } catch (SaveException e) {
                log.error("保存失败: validated={}", validated, e);
                throw new ComplexOperationException("保存阶段失败", e);
            }
            
        } catch (ComplexOperationException e) {
            // 重新抛出业务异常
            throw e;
            
        } catch (Exception e) {
            log.error("复杂操作时发生未预期异常: input={}", input, e);
            throw new ComplexOperationException("操作失败，发生未预期异常", e);
        }
    }
    
    // ✅ 保留异常信息的处理
    public ResponseEntity<String> handleRequest(HttpServletRequest request) {
        try {
            String data = extractData(request);
            ProcessResult result = processBusinessLogic(data);
            
            return ResponseEntity.ok(result.toJson());
            
        } catch (DataExtractionException e) {
            log.error("数据提取失败: uri={}", request.getRequestURI(), e);
            return ResponseEntity.badRequest()
                .body(createErrorResponse("DATA_EXTRACTION_ERROR", e.getMessage(), e.getErrorCode()));
                
        } catch (BusinessLogicException e) {
            log.error("业务逻辑处理失败: uri={}", request.getRequestURI(), e);
            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY)
                .body(createErrorResponse("BUSINESS_LOGIC_ERROR", e.getMessage(), e.getErrorCode()));
                
        } catch (ValidationException e) {
            log.warn("请求数据验证失败: uri={}", request.getRequestURI(), e);
            return ResponseEntity.badRequest()
                .body(createErrorResponse("VALIDATION_ERROR", e.getMessage(), e.getValidationErrors()));
                
        } catch (Exception e) {
            log.error("处理请求时发生未预期异常: uri={}", request.getRequestURI(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("INTERNAL_ERROR", "系统内部错误", null));
        }
    }
    
    // ✅ 异常重试机制
    @Retryable(value = {TransientException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public String callExternalService(String request) {
        try {
            return externalServiceClient.call(request);
            
        } catch (ConnectionTimeoutException e) {
            log.warn("外部服务连接超时，将重试: {}", e.getMessage());
            throw new TransientException("连接超时", e);
            
        } catch (ServiceUnavailableException e) {
            log.warn("外部服务不可用，将重试: {}", e.getMessage());
            throw new TransientException("服务不可用", e);
            
        } catch (AuthenticationException e) {
            log.error("外部服务认证失败，不会重试: {}", e.getMessage());
            throw new PermanentException("认证失败", e);
            
        } catch (Exception e) {
            log.error("调用外部服务时发生未知异常: {}", e.getMessage(), e);
            throw new PermanentException("外部服务调用失败", e);
        }
    }
    
    @Recover
    public String recoverFromExternalServiceFailure(TransientException e, String request) {
        log.error("外部服务调用最终失败，启用降级方案: request={}", request, e);
        return fallbackService.getDefaultResponse(request);
    }
}
```

### 4.21.2.2 异常处理策略检查 🔴

**1. 检测目标**

a. 验证异常处理策略的选择是否合适
b. 检查异常信息的记录和传播机制
c. 确保用户友好的错误消息展示
d. 区分系统异常和业务异常的处理方式

**2. 检测方法**

1. 异常处理策略审查
2. 日志记录完整性检查
3. 用户体验测试
4. 异常监控和告警机制验证

**3. 错误示例**

```java
// ❌ 异常处理策略不当
public class UserService {
    
    // ❌ 吞掉异常，不记录不处理
    public User createUser(UserRequest request) {
        try {
            return userRepository.save(convertToUser(request));
        } catch (Exception e) {
            // 静默忽略异常
            return null;
        }
    }
    
    // ❌ 异常信息暴露给用户
    public ResponseEntity<String> getUserById(Long id) {
        try {
            User user = userRepository.findById(id);
            return ResponseEntity.ok(user.toJson());
        } catch (SQLException e) {
            // 直接暴露数据库异常信息
            return ResponseEntity.status(500)
                .body("Database error: " + e.getMessage());
        }
    }
    
    // ❌ 异常处理过于粗糙
    public void processUserData(List<UserData> dataList) {
        for (UserData data : dataList) {
            try {
                processData(data);
            } catch (Exception e) {
                // 记录异常但继续处理，可能导致数据不一致
                log.error("处理失败", e);
            }
        }
    }
    
    // ❌ 异常转换丢失信息
    public void updateUser(Long id, UserRequest request) {
        try {
            User user = userRepository.findById(id);
            user.update(request);
            userRepository.save(user);
        } catch (DataIntegrityViolationException e) {
            // 丢失了具体的约束违反信息
            throw new RuntimeException("更新失败");
        }
    }
    
    // ❌ 没有区分业务异常和系统异常
    public void transferMoney(String fromAccount, String toAccount, BigDecimal amount) {
        try {
            accountService.debit(fromAccount, amount);
            accountService.credit(toAccount, amount);
        } catch (Exception e) {
            // 所有异常都按系统异常处理
            log.error("转账失败", e);
            throw new SystemException("系统异常，请稍后重试");
        }
    }
    
    // ❌ 异常重试策略不当
    public String callExternalAPI(String request) {
        for (int i = 0; i < 5; i++) {
            try {
                return externalClient.call(request);
            } catch (Exception e) {
                // 对所有异常都重试，包括不应该重试的
                if (i == 4) {
                    throw e;
                }
            }
        }
        return null;
    }
    
    // ❌ 异常日志记录不充分
    public void importUsers(InputStream inputStream) {
        try {
            List<User> users = parseUsers(inputStream);
            userRepository.saveAll(users);
        } catch (Exception e) {
            // 日志信息不足，无法定位问题
            log.error("导入失败");
            throw new ImportException("导入失败");
        }
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：合理的异常处理策略
@Service
public class UserService {
    
    private static final Logger log = LoggerFactory.getLogger(UserService.class);
    private final UserRepository userRepository;
    private final NotificationService notificationService;
    private final AuditService auditService;
    
    // ✅ 完整的异常处理和记录
    public CreateUserResult createUser(UserRequest request) {
        // 参数验证
        if (request == null) {
            throw new IllegalArgumentException("用户请求不能为空");
        }
        
        try {
            // 业务验证
            validateUserRequest(request);
            
            // 转换和保存
            User user = convertToUser(request);
            User savedUser = userRepository.save(user);
            
            // 记录审计日志
            auditService.recordUserCreation(savedUser.getId(), request.getOperatorId());
            
            log.info("用户创建成功: userId={}, email={}", savedUser.getId(), savedUser.getEmail());
            
            return CreateUserResult.success(savedUser);
            
        } catch (ValidationException e) {
            log.warn("用户创建验证失败: email={}, errors={}", request.getEmail(), e.getErrors());
            return CreateUserResult.validationFailed(e.getErrors());
            
        } catch (DuplicateEmailException e) {
            log.warn("邮箱已存在: email={}", request.getEmail());
            return CreateUserResult.emailExists("该邮箱已被注册");
            
        } catch (DataIntegrityViolationException e) {
            log.error("数据完整性约束违反: email={}", request.getEmail(), e);
            return CreateUserResult.dataIntegrityError("数据约束冲突，请检查输入");
            
        } catch (DataAccessException e) {
            log.error("数据库访问异常: email={}", request.getEmail(), e);
            return CreateUserResult.systemError("系统暂时不可用，请稍后重试");
            
        } catch (Exception e) {
            log.error("创建用户时发生未预期异常: email={}", request.getEmail(), e);
            return CreateUserResult.systemError("系统异常，请联系管理员");
        }
    }
    
    // ✅ 用户友好的异常信息
    public ResponseEntity<ApiResponse<User>> getUserById(Long id) {
        try {
            if (id == null || id <= 0) {
                return ResponseEntity.badRequest()
                    .body(ApiResponse.error("INVALID_PARAMETER", "用户ID无效"));
            }
            
            User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + id));
                
            return ResponseEntity.ok(ApiResponse.success(user));
            
        } catch (UserNotFoundException e) {
            log.warn("用户不存在: id={}", id);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(ApiResponse.error("USER_NOT_FOUND", "用户不存在"));
                
        } catch (DataAccessException e) {
            log.error("查询用户时数据库异常: id={}", id, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("DATABASE_ERROR", "系统暂时不可用"));
                
        } catch (Exception e) {
            log.error("查询用户时发生未预期异常: id={}", id, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("INTERNAL_ERROR", "系统内部错误"));
        }
    }
    
    // ✅ 批量处理的异常策略
    public BatchProcessResult processUserData(List<UserData> dataList) {
        if (dataList == null || dataList.isEmpty()) {
            return BatchProcessResult.empty();
        }
        
        List<ProcessResult> results = new ArrayList<>();
        List<String> criticalErrors = new ArrayList<>();
        int successCount = 0;
        int failureCount = 0;
        
        for (int i = 0; i < dataList.size(); i++) {
            UserData data = dataList.get(i);
            try {
                ProcessResult result = processData(data);
                results.add(result);
                
                if (result.isSuccess()) {
                    successCount++;
                } else {
                    failureCount++;
                }
                
            } catch (CriticalSystemException e) {
                // 关键系统异常，停止处理
                log.error("处理用户数据时发生关键系统异常，停止批量处理: index={}", i, e);
                criticalErrors.add("关键系统异常，批量处理已停止");
                break;
                
            } catch (BusinessException e) {
                // 业务异常，记录但继续处理
                log.warn("处理用户数据业务异常: index={}, data={}", i, data.getId(), e);
                results.add(ProcessResult.businessError(data.getId(), e.getMessage()));
                failureCount++;
                
            } catch (Exception e) {
                // 其他异常，记录并继续
                log.error("处理用户数据时发生异常: index={}, data={}", i, data.getId(), e);
                results.add(ProcessResult.systemError(data.getId(), "系统异常"));
                failureCount++;
            }
        }
        
        log.info("批量处理完成: total={}, success={}, failure={}", 
                dataList.size(), successCount, failureCount);
                
        return BatchProcessResult.builder()
            .results(results)
            .successCount(successCount)
            .failureCount(failureCount)
            .criticalErrors(criticalErrors)
            .build();
    }
    
    // ✅ 保留异常信息的转换
    public void updateUser(Long id, UserRequest request) {
        try {
            User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + id));
                
            // 记录更新前的状态
            String oldState = user.toAuditString();
            
            user.update(request);
            User updatedUser = userRepository.save(user);
            
            // 记录审计日志
            auditService.recordUserUpdate(id, oldState, updatedUser.toAuditString(), request.getOperatorId());
            
            log.info("用户更新成功: userId={}", id);
            
        } catch (UserNotFoundException e) {
            log.warn("更新用户失败，用户不存在: id={}", id);
            throw e;
            
        } catch (DataIntegrityViolationException e) {
            log.error("更新用户时数据完整性约束违反: id={}", id, e);
            
            // 分析具体的约束违反类型
            String constraintName = extractConstraintName(e);
            String userMessage = mapConstraintToUserMessage(constraintName);
            
            throw new UserUpdateException(userMessage, e);
            
        } catch (OptimisticLockingFailureException e) {
            log.warn("更新用户时发生乐观锁冲突: id={}", id, e);
            throw new ConcurrentUpdateException("用户信息已被其他操作修改，请刷新后重试", e);
            
        } catch (DataAccessException e) {
            log.error("更新用户时数据库异常: id={}", id, e);
            throw new SystemException("系统暂时不可用，请稍后重试", e);
            
        } catch (Exception e) {
            log.error("更新用户时发生未预期异常: id={}", id, e);
            throw new SystemException("系统异常，请联系管理员", e);
        }
    }
    
    // ✅ 区分业务异常和系统异常
    @Transactional
    public TransferResult transferMoney(String fromAccount, String toAccount, BigDecimal amount) {
        try {
            // 业务验证
            validateTransferRequest(fromAccount, toAccount, amount);
            
            // 检查余额（业务逻辑）
            if (!accountService.hasSufficientBalance(fromAccount, amount)) {
                log.warn("转账失败，余额不足: from={}, amount={}", fromAccount, amount);
                return TransferResult.insufficientBalance("账户余额不足");
            }
            
            // 检查账户状态（业务逻辑）
            if (!accountService.isAccountActive(fromAccount) || !accountService.isAccountActive(toAccount)) {
                log.warn("转账失败，账户状态异常: from={}, to={}", fromAccount, toAccount);
                return TransferResult.accountInactive("账户状态异常，无法转账");
            }
            
            // 执行转账
            String transactionId = UUID.randomUUID().toString();
            accountService.debit(fromAccount, amount, transactionId);
            accountService.credit(toAccount, amount, transactionId);
            
            // 记录转账日志
            auditService.recordTransfer(fromAccount, toAccount, amount, transactionId);
            
            log.info("转账成功: from={}, to={}, amount={}, transactionId={}", 
                    fromAccount, toAccount, amount, transactionId);
                    
            return TransferResult.success(transactionId);
            
        } catch (InsufficientBalanceException e) {
            // 业务异常
            log.warn("转账失败，余额不足: from={}, to={}, amount={}", fromAccount, toAccount, amount);
            return TransferResult.insufficientBalance("账户余额不足");
            
        } catch (AccountNotFoundException e) {
            // 业务异常
            log.warn("转账失败，账户不存在: from={}, to={}", fromAccount, toAccount);
            return TransferResult.accountNotFound("账户不存在");
            
        } catch (AccountFrozenException e) {
            // 业务异常
            log.warn("转账失败，账户被冻结: account={}", e.getAccountId());
            return TransferResult.accountFrozen("账户已被冻结");
            
        } catch (TransferLimitExceededException e) {
            // 业务异常
            log.warn("转账失败，超出限额: from={}, amount={}, limit={}", 
                    fromAccount, amount, e.getLimit());
            return TransferResult.limitExceeded("转账金额超出限额");
            
        } catch (DataAccessException e) {
            // 系统异常
            log.error("转账时数据库异常: from={}, to={}, amount={}", fromAccount, toAccount, amount, e);
            return TransferResult.systemError("系统暂时不可用，请稍后重试");
            
        } catch (Exception e) {
            // 系统异常
            log.error("转账时发生未预期异常: from={}, to={}, amount={}", fromAccount, toAccount, amount, e);
            return TransferResult.systemError("系统异常，请联系管理员");
        }
    }
    
    // ✅ 智能重试策略
    @Retryable(
        value = {TransientException.class, ConnectTimeoutException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public ApiResponse<String> callExternalAPI(String request) {
        try {
            String response = externalClient.call(request);
            log.debug("外部API调用成功: request={}", request);
            return ApiResponse.success(response);
            
        } catch (AuthenticationException e) {
            // 认证异常，不重试
            log.error("外部API认证失败: {}", e.getMessage());
            throw new PermanentException("API认证失败", e);
            
        } catch (BadRequestException e) {
            // 请求格式错误，不重试
            log.error("外部API请求格式错误: request={}", request, e);
            throw new PermanentException("请求格式错误", e);
            
        } catch (ConnectTimeoutException e) {
            // 连接超时，可重试
            log.warn("外部API连接超时，将重试: attempt={}", getCurrentAttempt());
            throw new TransientException("连接超时", e);
            
        } catch (ServiceUnavailableException e) {
            // 服务不可用，可重试
            log.warn("外部API服务不可用，将重试: attempt={}", getCurrentAttempt());
            throw new TransientException("服务不可用", e);
            
        } catch (Exception e) {
            log.error("调用外部API时发生未知异常: request={}", request, e);
            throw new PermanentException("外部API调用失败", e);
        }
    }
    
    @Recover
    public ApiResponse<String> recoverFromExternalAPIFailure(TransientException e, String request) {
        log.error("外部API调用最终失败，启用降级方案: request={}", request, e);
        
        // 尝试从缓存获取
        String cachedResponse = cacheService.getCachedResponse(request);
        if (cachedResponse != null) {
            log.info("使用缓存响应作为降级方案: request={}", request);
            return ApiResponse.success(cachedResponse);
        }
        
        // 返回默认响应
        return ApiResponse.error("EXTERNAL_SERVICE_UNAVAILABLE", "外部服务暂时不可用");
    }
    
    // ✅ 详细的异常日志记录
    public ImportResult importUsers(InputStream inputStream, String fileName, String operatorId) {
        if (inputStream == null) {
            throw new IllegalArgumentException("输入流不能为空");
        }
        
        ImportContext context = ImportContext.builder()
            .fileName(fileName)
            .operatorId(operatorId)
            .startTime(Instant.now())
            .build();
            
        try {
            log.info("开始导入用户: fileName={}, operatorId={}", fileName, operatorId);
            
            List<User> users = parseUsers(inputStream, context);
            log.info("解析用户完成: count={}, fileName={}", users.size(), fileName);
            
            List<User> savedUsers = userRepository.saveAll(users);
            
            // 记录审计日志
            auditService.recordUserImport(savedUsers.size(), fileName, operatorId);
            
            log.info("用户导入成功: count={}, fileName={}, duration={}ms", 
                    savedUsers.size(), fileName, 
                    Duration.between(context.getStartTime(), Instant.now()).toMillis());
                    
            return ImportResult.success(savedUsers.size());
            
        } catch (InvalidFileFormatException e) {
            log.error("导入失败，文件格式无效: fileName={}, error={}", fileName, e.getMessage());
            return ImportResult.formatError("文件格式无效: " + e.getMessage());
            
        } catch (DataValidationException e) {
            log.error("导入失败，数据验证错误: fileName={}, errors={}", fileName, e.getErrors());
            return ImportResult.validationError(e.getErrors());
            
        } catch (DuplicateDataException e) {
            log.error("导入失败，存在重复数据: fileName={}, duplicates={}", fileName, e.getDuplicates());
            return ImportResult.duplicateError(e.getDuplicates());
            
        } catch (DataAccessException e) {
            log.error("导入失败，数据库异常: fileName={}, operatorId={}", fileName, operatorId, e);
            return ImportResult.systemError("数据库异常，请稍后重试");
            
        } catch (Exception e) {
            log.error("导入失败，发生未预期异常: fileName={}, operatorId={}", fileName, operatorId, e);
            return ImportResult.systemError("系统异常，请联系管理员");
            
        } finally {
            // 清理资源
            try {
                inputStream.close();
            } catch (IOException e) {
                log.warn("关闭输入流时发生异常: fileName={}", fileName, e);
            }
        }
    }
    
    // ✅ 异常信息映射
    private String mapConstraintToUserMessage(String constraintName) {
        switch (constraintName) {
            case "uk_user_email":
                return "邮箱地址已存在";
            case "uk_user_phone":
                return "手机号码已存在";
            case "chk_user_age":
                return "年龄必须在合理范围内";
            default:
                return "数据约束冲突";
        }
    }
    
    // ✅ 异常监控和告警
    @EventListener
    public void handleCriticalException(CriticalExceptionEvent event) {
        log.error("检测到关键异常: type={}, message={}", 
                event.getExceptionType(), event.getMessage());
                
        // 发送告警
        alertService.sendCriticalAlert(
            "关键异常告警",
            String.format("异常类型: %s, 消息: %s, 时间: %s", 
                event.getExceptionType(), 
                event.getMessage(), 
                event.getTimestamp())
        );
        
        // 记录到监控系统
        metricsService.incrementCounter("critical.exception", 
            "type", event.getExceptionType());
    }
}
```

### 4.21.2.3 资源清理完整性检查 🟡

**1. 检测目标**

a. 确保所有资源（文件、网络连接、数据库连接等）正确关闭
b. 验证try-with-resources语句的正确使用
c. 检查finally块中的资源清理逻辑
d. 确保异常情况下的资源释放

**2. 检测方法**

1. 静态代码分析工具（SpotBugs、SonarQube）
2. 资源泄漏检测工具
3. 内存分析工具（MAT、JProfiler）
4. 单元测试和集成测试

**3. 错误示例**

```java
// ❌ 资源清理不完整
public class FileService {
    
    // ❌ 没有关闭文件流
    public String readFile(String fileName) {
        try {
            FileInputStream fis = new FileInputStream(fileName);
            BufferedReader reader = new BufferedReader(new InputStreamReader(fis));
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
            return content.toString();
        } catch (IOException e) {
            throw new RuntimeException("读取文件失败", e);
        }
        // 文件流没有关闭，造成资源泄漏
    }
    
    // ❌ finally块中的资源清理不安全
    public void writeFile(String fileName, String content) {
        FileOutputStream fos = null;
        BufferedWriter writer = null;
        try {
            fos = new FileOutputStream(fileName);
            writer = new BufferedWriter(new OutputStreamWriter(fos));
            writer.write(content);
        } catch (IOException e) {
            throw new RuntimeException("写入文件失败", e);
        } finally {
            // ❌ 没有检查null，可能抛出NullPointerException
            writer.close();
            fos.close();
        }
    }
    
    // ❌ 数据库连接没有正确关闭
    public List<User> getUsers() {
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        List<User> users = new ArrayList<>();
        
        try {
            conn = dataSource.getConnection();
            stmt = conn.prepareStatement("SELECT * FROM users");
            rs = stmt.executeQuery();
            
            while (rs.next()) {
                users.add(mapToUser(rs));
            }
            
            return users;
        } catch (SQLException e) {
            throw new DataAccessException("查询用户失败", e);
        }
        // ❌ 没有在finally块中关闭资源
    }
    
    // ❌ 网络连接资源泄漏
    public String callAPI(String url) {
        try {
            URL apiUrl = new URL(url);
            HttpURLConnection connection = (HttpURLConnection) apiUrl.openConnection();
            connection.setRequestMethod("GET");
            connection.setConnectTimeout(5000);
            connection.setReadTimeout(10000);
            
            BufferedReader reader = new BufferedReader(
                new InputStreamReader(connection.getInputStream()));
            StringBuilder response = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                response.append(line);
            }
            
            return response.toString();
        } catch (IOException e) {
            throw new RuntimeException("API调用失败", e);
        }
        // ❌ 连接和流没有关闭
    }
    
    // ❌ 线程池没有正确关闭
    public void processDataAsync(List<Data> dataList) {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        for (Data data : dataList) {
            executor.submit(() -> {
                processData(data);
            });
        }
        
        // ❌ 没有关闭线程池，线程会一直存在
    }
    
    // ❌ 缓存资源没有清理
    public class CacheManager {
        private Map<String, Object> cache = new HashMap<>();
        private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        public void startCleanupTask() {
            scheduler.scheduleAtFixedRate(() -> {
                cleanExpiredEntries();
            }, 0, 1, TimeUnit.HOURS);
        }
        
        // ❌ 没有提供关闭方法，调度器会一直运行
    }
    
    // ❌ 临时文件没有清理
    public String processLargeData(byte[] data) {
        try {
            File tempFile = File.createTempFile("process", ".tmp");
            FileOutputStream fos = new FileOutputStream(tempFile);
            fos.write(data);
            fos.close();
            
            // 处理文件
            String result = processFile(tempFile);
            
            return result;
        } catch (IOException e) {
            throw new RuntimeException("处理数据失败", e);
        }
        // ❌ 临时文件没有删除
    }
    
    // ❌ 锁资源没有释放
    private final ReentrantLock lock = new ReentrantLock();
    
    public void updateSharedResource() {
        lock.lock();
        try {
            // 更新共享资源
            updateResource();
            
            if (someCondition()) {
                // ❌ 提前返回，锁没有释放
                return;
            }
            
            // 其他操作
        } catch (Exception e) {
            // ❌ 异常情况下锁没有释放
            throw new RuntimeException("更新失败", e);
        }
        lock.unlock();
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的资源清理
@Service
public class FileService {
    
    private static final Logger log = LoggerFactory.getLogger(FileService.class);
    
    // ✅ 使用try-with-resources自动关闭资源
    public String readFile(String fileName) {
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("文件名不能为空");
        }
        
        try (FileInputStream fis = new FileInputStream(fileName);
             BufferedReader reader = new BufferedReader(new InputStreamReader(fis, StandardCharsets.UTF_8))) {
            
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append(System.lineSeparator());
            }
            
            log.debug("文件读取成功: fileName={}, size={}", fileName, content.length());
            return content.toString();
            
        } catch (FileNotFoundException e) {
            log.error("文件不存在: fileName={}", fileName, e);
            throw new FileProcessException("文件不存在: " + fileName, e);
            
        } catch (IOException e) {
            log.error("读取文件失败: fileName={}", fileName, e);
            throw new FileProcessException("读取文件失败: " + fileName, e);
        }
    }
    
    // ✅ 多个资源的正确管理
    public void writeFile(String fileName, String content) {
        if (fileName == null || content == null) {
            throw new IllegalArgumentException("文件名和内容不能为空");
        }
        
        try (FileOutputStream fos = new FileOutputStream(fileName);
             BufferedWriter writer = new BufferedWriter(
                 new OutputStreamWriter(fos, StandardCharsets.UTF_8))) {
            
            writer.write(content);
            writer.flush(); // 确保数据写入
            
            log.debug("文件写入成功: fileName={}, size={}", fileName, content.length());
            
        } catch (IOException e) {
            log.error("写入文件失败: fileName={}", fileName, e);
            throw new FileProcessException("写入文件失败: " + fileName, e);
        }
    }
    
    // ✅ 传统方式的安全资源清理
    public void copyFile(String sourcePath, String targetPath) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        FileChannel sourceChannel = null;
        FileChannel targetChannel = null;
        
        try {
            fis = new FileInputStream(sourcePath);
            fos = new FileOutputStream(targetPath);
            sourceChannel = fis.getChannel();
            targetChannel = fos.getChannel();
            
            long size = sourceChannel.size();
            long transferred = 0;
            
            while (transferred < size) {
                transferred += targetChannel.transferFrom(sourceChannel, transferred, size - transferred);
            }
            
            log.info("文件复制成功: from={}, to={}, size={}", sourcePath, targetPath, size);
            
        } catch (IOException e) {
            log.error("文件复制失败: from={}, to={}", sourcePath, targetPath, e);
            throw new FileProcessException("文件复制失败", e);
            
        } finally {
            // ✅ 安全地关闭所有资源
            closeQuietly(targetChannel, "target channel");
            closeQuietly(sourceChannel, "source channel");
            closeQuietly(fos, "file output stream");
            closeQuietly(fis, "file input stream");
        }
    }
    
    // ✅ 安全的资源关闭工具方法
    private void closeQuietly(Closeable resource, String resourceName) {
        if (resource != null) {
            try {
                resource.close();
                log.debug("资源关闭成功: {}", resourceName);
            } catch (IOException e) {
                log.warn("关闭资源时发生异常: {}", resourceName, e);
            }
        }
    }
    
    // ✅ 数据库资源的正确管理
    @Repository
    public class UserRepository {
        
        private final DataSource dataSource;
        
        public List<User> findUsers(String namePattern) {
            String sql = "SELECT id, name, email, created_at FROM users WHERE name LIKE ? ORDER BY created_at DESC";
            
            try (Connection conn = dataSource.getConnection();
                 PreparedStatement stmt = conn.prepareStatement(sql)) {
                
                stmt.setString(1, "%" + namePattern + "%");
                
                try (ResultSet rs = stmt.executeQuery()) {
                    List<User> users = new ArrayList<>();
                    
                    while (rs.next()) {
                        User user = User.builder()
                            .id(rs.getLong("id"))
                            .name(rs.getString("name"))
                            .email(rs.getString("email"))
                            .createdAt(rs.getTimestamp("created_at").toLocalDateTime())
                            .build();
                        users.add(user);
                    }
                    
                    log.debug("查询用户成功: pattern={}, count={}", namePattern, users.size());
                    return users;
                }
                
            } catch (SQLException e) {
                log.error("查询用户失败: pattern={}", namePattern, e);
                throw new DataAccessException("查询用户失败", e);
            }
        }
        
        // ✅ 批量操作的资源管理
        @Transactional
        public int batchUpdateUsers(List<UserUpdateRequest> requests) {
            String sql = "UPDATE users SET name = ?, email = ?, updated_at = ? WHERE id = ?";
            
            try (Connection conn = dataSource.getConnection();
                 PreparedStatement stmt = conn.prepareStatement(sql)) {
                
                conn.setAutoCommit(false);
                
                for (UserUpdateRequest request : requests) {
                    stmt.setString(1, request.getName());
                    stmt.setString(2, request.getEmail());
                    stmt.setTimestamp(3, Timestamp.valueOf(LocalDateTime.now()));
                    stmt.setLong(4, request.getId());
                    stmt.addBatch();
                }
                
                int[] results = stmt.executeBatch();
                conn.commit();
                
                int totalUpdated = Arrays.stream(results).sum();
                log.info("批量更新用户成功: count={}", totalUpdated);
                
                return totalUpdated;
                
            } catch (SQLException e) {
                log.error("批量更新用户失败: count={}", requests.size(), e);
                throw new DataAccessException("批量更新用户失败", e);
            }
        }
    }
    
    // ✅ HTTP连接的正确管理
    @Component
    public class ApiClient {
        
        private final ObjectMapper objectMapper;
        private final int connectTimeout = 5000;
        private final int readTimeout = 10000;
        
        public <T> ApiResponse<T> callAPI(String url, Object request, Class<T> responseType) {
            HttpURLConnection connection = null;
            
            try {
                URL apiUrl = new URL(url);
                connection = (HttpURLConnection) apiUrl.openConnection();
                
                // 配置连接
                connection.setRequestMethod("POST");
                connection.setRequestProperty("Content-Type", "application/json");
                connection.setRequestProperty("Accept", "application/json");
                connection.setConnectTimeout(connectTimeout);
                connection.setReadTimeout(readTimeout);
                connection.setDoOutput(true);
                
                // 发送请求
                try (OutputStream os = connection.getOutputStream();
                     BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, StandardCharsets.UTF_8))) {
                    
                    String requestJson = objectMapper.writeValueAsString(request);
                    writer.write(requestJson);
                    writer.flush();
                }
                
                // 读取响应
                int responseCode = connection.getResponseCode();
                
                try (InputStream is = (responseCode >= 200 && responseCode < 300) 
                        ? connection.getInputStream() 
                        : connection.getErrorStream();
                     BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
                    
                    StringBuilder response = new StringBuilder();
                    String line;
                    while ((line = reader.readLine()) != null) {
                        response.append(line);
                    }
                    
                    if (responseCode >= 200 && responseCode < 300) {
                        T responseData = objectMapper.readValue(response.toString(), responseType);
                        log.debug("API调用成功: url={}, responseCode={}", url, responseCode);
                        return ApiResponse.success(responseData);
                    } else {
                        log.warn("API调用失败: url={}, responseCode={}, response={}", 
                                url, responseCode, response.toString());
                        return ApiResponse.error("API_ERROR", "API调用失败: " + responseCode);
                    }
                }
                
            } catch (MalformedURLException e) {
                log.error("无效的URL: {}", url, e);
                return ApiResponse.error("INVALID_URL", "无效的URL");
                
            } catch (SocketTimeoutException e) {
                log.error("API调用超时: url={}", url, e);
                return ApiResponse.error("TIMEOUT", "API调用超时");
                
            } catch (IOException e) {
                log.error("API调用IO异常: url={}", url, e);
                return ApiResponse.error("IO_ERROR", "网络异常");
                
            } catch (Exception e) {
                log.error("API调用异常: url={}", url, e);
                return ApiResponse.error("UNKNOWN_ERROR", "未知异常");
                
            } finally {
                // ✅ 确保连接被关闭
                if (connection != null) {
                    try {
                        connection.disconnect();
                        log.debug("HTTP连接已关闭: url={}", url);
                    } catch (Exception e) {
                        log.warn("关闭HTTP连接时发生异常: url={}", url, e);
                    }
                }
            }
        }
    }
    
    // ✅ 线程池的正确管理
    @Component
    public class AsyncTaskProcessor {
        
        private final ExecutorService executor;
        private final ScheduledExecutorService scheduler;
        
        public AsyncTaskProcessor() {
            this.executor = Executors.newFixedThreadPool(10, 
                new ThreadFactoryBuilder()
                    .setNameFormat("async-task-%d")
                    .setDaemon(true)
                    .build());
                    
            this.scheduler = Executors.newScheduledThreadPool(2,
                new ThreadFactoryBuilder()
                    .setNameFormat("scheduler-%d")
                    .setDaemon(true)
                    .build());
        }
        
        public CompletableFuture<Void> processDataAsync(List<Data> dataList) {
            List<CompletableFuture<Void>> futures = dataList.stream()
                .map(data -> CompletableFuture.runAsync(() -> {
                    try {
                        processData(data);
                        log.debug("数据处理完成: id={}", data.getId());
                    } catch (Exception e) {
                        log.error("数据处理失败: id={}", data.getId(), e);
                        throw new RuntimeException(e);
                    }
                }, executor))
                .collect(Collectors.toList());
                
            return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
        }
        
        public void scheduleCleanupTask() {
            scheduler.scheduleAtFixedRate(() -> {
                try {
                    cleanupExpiredData();
                    log.debug("定期清理任务执行完成");
                } catch (Exception e) {
                    log.error("定期清理任务执行失败", e);
                }
            }, 0, 1, TimeUnit.HOURS);
        }
        
        // ✅ 提供关闭方法
        @PreDestroy
        public void shutdown() {
            log.info("开始关闭异步任务处理器");
            
            // 关闭调度器
            scheduler.shutdown();
            try {
                if (!scheduler.awaitTermination(30, TimeUnit.SECONDS)) {
                    log.warn("调度器未能在30秒内正常关闭，强制关闭");
                    scheduler.shutdownNow();
                }
            } catch (InterruptedException e) {
                log.warn("等待调度器关闭时被中断");
                scheduler.shutdownNow();
                Thread.currentThread().interrupt();
            }
            
            // 关闭执行器
            executor.shutdown();
            try {
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    log.warn("执行器未能在60秒内正常关闭，强制关闭");
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                log.warn("等待执行器关闭时被中断");
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
            
            log.info("异步任务处理器关闭完成");
        }
    }
    
    // ✅ 临时文件的正确管理
    public String processLargeData(byte[] data) {
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("数据不能为空");
        }
        
        Path tempFile = null;
        try {
            // 创建临时文件
            tempFile = Files.createTempFile("process", ".tmp");
            log.debug("创建临时文件: {}", tempFile);
            
            // 写入数据
            Files.write(tempFile, data, StandardOpenOption.WRITE);
            
            // 处理文件
            String result = processFile(tempFile.toFile());
            
            log.debug("数据处理完成: size={}, result={}", data.length, result.length());
            return result;
            
        } catch (IOException e) {
            log.error("处理大数据时IO异常: size={}", data.length, e);
            throw new DataProcessException("处理数据失败", e);
            
        } catch (Exception e) {
            log.error("处理大数据时发生异常: size={}", data.length, e);
            throw new DataProcessException("处理数据失败", e);
            
        } finally {
            // ✅ 确保临时文件被删除
            if (tempFile != null) {
                try {
                    Files.deleteIfExists(tempFile);
                    log.debug("临时文件已删除: {}", tempFile);
                } catch (IOException e) {
                    log.warn("删除临时文件失败: {}", tempFile, e);
                }
            }
        }
    }
    
    // ✅ 锁资源的正确管理
    @Component
    public class SharedResourceManager {
        
        private final ReentrantLock lock = new ReentrantLock();
        private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
        private volatile String sharedData;
        
        public void updateSharedResource(String newData) {
            lock.lock();
            try {
                log.debug("开始更新共享资源");
                
                // 验证数据
                if (newData == null) {
                    throw new IllegalArgumentException("数据不能为空");
                }
                
                // 更新资源
                String oldData = this.sharedData;
                this.sharedData = newData;
                
                log.info("共享资源更新成功: old={}, new={}", oldData, newData);
                
            } catch (Exception e) {
                log.error("更新共享资源失败: data={}", newData, e);
                throw e;
            } finally {
                // ✅ 确保锁被释放
                lock.unlock();
                log.debug("共享资源锁已释放");
            }
        }
        
        public String readSharedResource() {
            rwLock.readLock().lock();
            try {
                log.debug("读取共享资源");
                return this.sharedData;
            } finally {
                // ✅ 确保读锁被释放
                rwLock.readLock().unlock();
                log.debug("共享资源读锁已释放");
            }
        }
        
        // ✅ 带超时的锁获取
        public boolean tryUpdateWithTimeout(String newData, long timeoutMs) {
            try {
                if (lock.tryLock(timeoutMs, TimeUnit.MILLISECONDS)) {
                    try {
                        this.sharedData = newData;
                        log.info("带超时的共享资源更新成功: data={}", newData);
                        return true;
                    } finally {
                        lock.unlock();
                    }
                } else {
                    log.warn("获取锁超时: timeout={}ms", timeoutMs);
                    return false;
                }
            } catch (InterruptedException e) {
                log.warn("等待锁时被中断");
                Thread.currentThread().interrupt();
                return false;
            }
        }
    }
    
    // ✅ 缓存资源的正确管理
    @Component
    public class CacheManager {
        
        private final Map<String, CacheEntry> cache = new ConcurrentHashMap<>();
        private final ScheduledExecutorService cleanupScheduler;
        private volatile boolean shutdown = false;
        
        public CacheManager() {
            this.cleanupScheduler = Executors.newSingleThreadScheduledExecutor(
                new ThreadFactoryBuilder()
                    .setNameFormat("cache-cleanup-%d")
                    .setDaemon(true)
                    .build());
                    
            startCleanupTask();
        }
        
        public void put(String key, Object value, Duration ttl) {
            if (shutdown) {
                throw new IllegalStateException("缓存管理器已关闭");
            }
            
            CacheEntry entry = new CacheEntry(value, Instant.now().plus(ttl));
            cache.put(key, entry);
            log.debug("缓存项已添加: key={}, ttl={}", key, ttl);
        }
        
        public Optional<Object> get(String key) {
            if (shutdown) {
                return Optional.empty();
            }
            
            CacheEntry entry = cache.get(key);
            if (entry == null || entry.isExpired()) {
                cache.remove(key);
                return Optional.empty();
            }
            
            return Optional.of(entry.getValue());
        }
        
        private void startCleanupTask() {
            cleanupScheduler.scheduleAtFixedRate(() -> {
                if (shutdown) {
                    return;
                }
                
                try {
                    cleanExpiredEntries();
                } catch (Exception e) {
                    log.error("清理过期缓存项时发生异常", e);
                }
            }, 1, 1, TimeUnit.MINUTES);
        }
        
        private void cleanExpiredEntries() {
            int removedCount = 0;
            Iterator<Map.Entry<String, CacheEntry>> iterator = cache.entrySet().iterator();
            
            while (iterator.hasNext()) {
                Map.Entry<String, CacheEntry> entry = iterator.next();
                if (entry.getValue().isExpired()) {
                    iterator.remove();
                    removedCount++;
                }
            }
            
            if (removedCount > 0) {
                log.debug("清理过期缓存项: count={}, remaining={}", removedCount, cache.size());
            }
        }
        
        // ✅ 提供关闭方法
        @PreDestroy
        public void shutdown() {
            log.info("开始关闭缓存管理器");
            
            shutdown = true;
            
            // 关闭清理调度器
            cleanupScheduler.shutdown();
            try {
                if (!cleanupScheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                    log.warn("清理调度器未能在10秒内正常关闭，强制关闭");
                    cleanupScheduler.shutdownNow();
                }
            } catch (InterruptedException e) {
                log.warn("等待清理调度器关闭时被中断");
                cleanupScheduler.shutdownNow();
                Thread.currentThread().interrupt();
            }
            
            // 清空缓存
            int cacheSize = cache.size();
            cache.clear();
            
            log.info("缓存管理器关闭完成: 清理了{}个缓存项", cacheSize);
        }
        
        private static class CacheEntry {
            private final Object value;
            private final Instant expireTime;
            
            public CacheEntry(Object value, Instant expireTime) {
                this.value = value;
                this.expireTime = expireTime;
            }
            
            public Object getValue() {
                return value;
            }
            
            public boolean isExpired() {
                return Instant.now().isAfter(expireTime);
            }
        }
    }
}
```

## 4.21.3 数据一致性检查

### 4.21.3.1 事务一致性检查 🔴

**1. 检测目标**

a. 确保事务边界正确定义，避免事务范围过大或过小
b. 验证事务隔离级别设置合理，防止脏读、不可重复读、幻读
c. 检查分布式事务的一致性保证
d. 确保事务回滚机制正确实现

**2. 检测方法**

1. 事务边界分析工具
2. 数据库事务日志分析
3. 分布式事务监控工具
4. 并发测试和压力测试

**3. 错误示例**

```java
// ❌ 事务一致性问题
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private NotificationService notificationService;
    
    // ❌ 事务边界过大，包含不必要的操作
    @Transactional
    public void processOrder(OrderRequest request) {
        // 验证订单（不需要事务）
        validateOrder(request);
        
        // 创建订单
        Order order = createOrder(request);
        
        // 扣减库存
        inventoryService.reduceStock(request.getProductId(), request.getQuantity());
        
        // 处理支付
        paymentService.processPayment(order.getId(), request.getPaymentInfo());
        
        // ❌ 发送通知不应该在事务中，可能导致事务长时间占用
        notificationService.sendOrderConfirmation(order.getId());
        
        // ❌ 外部API调用在事务中，可能导致超时
        externalApiService.syncOrderToThirdParty(order);
    }
    
    // ❌ 事务边界过小，数据一致性无法保证
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // ❌ 两个操作分别在不同事务中，可能导致数据不一致
        debitAccount(fromAccountId, amount);
        creditAccount(toAccountId, amount);
    }
    
    @Transactional
    private void debitAccount(Long accountId, BigDecimal amount) {
        Account account = accountRepository.findById(accountId);
        account.setBalance(account.getBalance().subtract(amount));
        accountRepository.save(account);
    }
    
    @Transactional
    private void creditAccount(Long accountId, BigDecimal amount) {
        Account account = accountRepository.findById(accountId);
        account.setBalance(account.getBalance().add(amount));
        accountRepository.save(account);
    }
    
    // ❌ 事务隔离级别不当
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public OrderSummary getOrderSummary(Long orderId) {
        // ❌ 可能读取到未提交的数据，导致脏读
        Order order = orderRepository.findById(orderId);
        List<OrderItem> items = orderItemRepository.findByOrderId(orderId);
        
        return buildOrderSummary(order, items);
    }
    
    // ❌ 没有正确处理事务回滚
    @Transactional
    public void processPayment(Long orderId, PaymentInfo paymentInfo) {
        try {
            Order order = orderRepository.findById(orderId);
            
            // 处理支付
            PaymentResult result = paymentGateway.charge(paymentInfo, order.getAmount());
            
            if (result.isSuccess()) {
                order.setStatus(OrderStatus.PAID);
                orderRepository.save(order);
            } else {
                // ❌ 没有抛出异常，事务不会回滚
                order.setStatus(OrderStatus.PAYMENT_FAILED);
                orderRepository.save(order);
            }
            
        } catch (PaymentException e) {
            // ❌ 捕获异常但没有重新抛出，事务不会回滚
            log.error("支付失败", e);
        }
    }
    
    // ❌ 分布式事务一致性问题
    @Transactional
    public void createOrderWithInventory(OrderRequest request) {
        // 本地事务：创建订单
        Order order = createOrder(request);
        
        // ❌ 远程服务调用，不在同一事务中
        try {
            inventoryService.reserveStock(request.getProductId(), request.getQuantity());
        } catch (Exception e) {
            // ❌ 远程调用失败，但本地事务已提交，数据不一致
            throw new OrderProcessException("库存预留失败", e);
        }
    }
    
    // ❌ 嵌套事务处理不当
    @Transactional
    public void processComplexOrder(OrderRequest request) {
        Order order = createOrder(request);
        
        for (OrderItem item : request.getItems()) {
            // ❌ 嵌套事务可能导致部分提交
            processOrderItem(order.getId(), item);
        }
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    private void processOrderItem(Long orderId, OrderItem item) {
        // ❌ 每个item在独立事务中，如果后续item失败，前面的item已提交
        orderItemRepository.save(item);
        inventoryService.reduceStock(item.getProductId(), item.getQuantity());
    }
    
    // ❌ 只读事务中进行写操作
    @Transactional(readOnly = true)
    public OrderStatistics calculateOrderStatistics(Date startDate, Date endDate) {
        List<Order> orders = orderRepository.findByDateRange(startDate, endDate);
        
        OrderStatistics stats = new OrderStatistics();
        stats.setTotalOrders(orders.size());
        stats.setTotalAmount(orders.stream()
            .map(Order::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add));
        
        // ❌ 在只读事务中保存统计结果
        statisticsRepository.save(stats);
        
        return stats;
    }
    
    // ❌ 事务超时设置不合理
    @Transactional(timeout = 1) // 1秒超时太短
    public void batchProcessOrders(List<OrderRequest> requests) {
        for (OrderRequest request : requests) {
            // ❌ 批量处理可能需要较长时间，1秒超时不合理
            processOrder(request);
        }
    }
    
    // ❌ 异步操作在事务中
    @Transactional
    public void processOrderAsync(OrderRequest request) {
        Order order = createOrder(request);
        
        // ❌ 异步操作不在事务范围内
        CompletableFuture.runAsync(() -> {
            inventoryService.reduceStock(request.getProductId(), request.getQuantity());
        });
    }
    
    // ❌ 事务传播行为不当
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void updateOrderStatus(Long orderId, OrderStatus status) {
        // ❌ 不支持事务，可能导致数据不一致
        Order order = orderRepository.findById(orderId);
        order.setStatus(status);
        order.setUpdatedAt(LocalDateTime.now());
        orderRepository.save(order);
        
        // 同时更新相关表
        orderHistoryRepository.save(new OrderHistory(orderId, status, LocalDateTime.now()));
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：事务一致性保证
@Service
@Slf4j
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    // ✅ 合理的事务边界
    @Transactional(rollbackFor = Exception.class)
    public OrderResult processOrder(OrderRequest request) {
        try {
            // 1. 验证订单（在事务外进行）
            validateOrderRequest(request);
            
            // 2. 创建订单
            Order order = createOrder(request);
            
            // 3. 扣减库存
            inventoryService.reduceStock(request.getProductId(), request.getQuantity());
            
            // 4. 处理支付
            PaymentResult paymentResult = paymentService.processPayment(
                order.getId(), request.getPaymentInfo());
            
            if (!paymentResult.isSuccess()) {
                throw new PaymentException("支付失败: " + paymentResult.getErrorMessage());
            }
            
            // 5. 更新订单状态
            order.setStatus(OrderStatus.PAID);
            order.setPaymentId(paymentResult.getPaymentId());
            orderRepository.save(order);
            
            log.info("订单处理成功: orderId={}, amount={}", order.getId(), order.getAmount());
            
            // 6. 发布事件（事务提交后异步处理通知）
            eventPublisher.publishEvent(new OrderProcessedEvent(order.getId()));
            
            return OrderResult.success(order.getId());
            
        } catch (ValidationException e) {
            log.warn("订单验证失败: {}", e.getMessage());
            throw e;
        } catch (InsufficientStockException e) {
            log.warn("库存不足: productId={}, requested={}", 
                    request.getProductId(), request.getQuantity());
            throw e;
        } catch (PaymentException e) {
            log.error("支付处理失败: orderId={}", request.getProductId(), e);
            throw e;
        } catch (Exception e) {
            log.error("订单处理异常: request={}", request, e);
            throw new OrderProcessException("订单处理失败", e);
        }
    }
    
    // ✅ 原子性转账操作
    @Transactional(rollbackFor = Exception.class, isolation = Isolation.READ_COMMITTED)
    public TransferResult transferMoney(TransferRequest request) {
        validateTransferRequest(request);
        
        try {
            // 1. 加锁防止并发问题
            Account fromAccount = accountRepository.findByIdForUpdate(request.getFromAccountId());
            Account toAccount = accountRepository.findByIdForUpdate(request.getToAccountId());
            
            if (fromAccount == null || toAccount == null) {
                throw new AccountNotFoundException("账户不存在");
            }
            
            // 2. 检查余额
            if (fromAccount.getBalance().compareTo(request.getAmount()) < 0) {
                throw new InsufficientBalanceException("余额不足");
            }
            
            // 3. 执行转账
            fromAccount.setBalance(fromAccount.getBalance().subtract(request.getAmount()));
            toAccount.setBalance(toAccount.getBalance().add(request.getAmount()));
            
            // 4. 保存账户状态
            accountRepository.save(fromAccount);
            accountRepository.save(toAccount);
            
            // 5. 记录转账历史
            TransferHistory history = TransferHistory.builder()
                .fromAccountId(request.getFromAccountId())
                .toAccountId(request.getToAccountId())
                .amount(request.getAmount())
                .status(TransferStatus.SUCCESS)
                .createdAt(LocalDateTime.now())
                .build();
            transferHistoryRepository.save(history);
            
            log.info("转账成功: from={}, to={}, amount={}", 
                    request.getFromAccountId(), request.getToAccountId(), request.getAmount());
            
            return TransferResult.success(history.getId());
            
        } catch (Exception e) {
            log.error("转账失败: request={}", request, e);
            throw e;
        }
    }
    
    // ✅ 合适的事务隔离级别
    @Transactional(readOnly = true, isolation = Isolation.READ_COMMITTED)
    public OrderSummary getOrderSummary(Long orderId) {
        try {
            Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + orderId));
            
            List<OrderItem> items = orderItemRepository.findByOrderId(orderId);
            
            PaymentInfo paymentInfo = null;
            if (order.getPaymentId() != null) {
                paymentInfo = paymentService.getPaymentInfo(order.getPaymentId());
            }
            
            return OrderSummary.builder()
                .order(order)
                .items(items)
                .paymentInfo(paymentInfo)
                .build();
                
        } catch (Exception e) {
            log.error("获取订单摘要失败: orderId={}", orderId, e);
            throw new OrderQueryException("获取订单摘要失败", e);
        }
    }
    
    // ✅ 正确的事务回滚处理
    @Transactional(rollbackFor = Exception.class)
    public PaymentResult processPayment(Long orderId, PaymentInfo paymentInfo) {
        try {
            Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + orderId));
            
            if (order.getStatus() != OrderStatus.PENDING) {
                throw new InvalidOrderStatusException(
                    "订单状态不允许支付: " + order.getStatus());
            }
            
            // 处理支付
            PaymentResult result = paymentGateway.charge(paymentInfo, order.getAmount());
            
            if (result.isSuccess()) {
                order.setStatus(OrderStatus.PAID);
                order.setPaymentId(result.getPaymentId());
                order.setPaidAt(LocalDateTime.now());
                orderRepository.save(order);
                
                log.info("支付成功: orderId={}, paymentId={}", orderId, result.getPaymentId());
                return result;
            } else {
                // ✅ 支付失败时抛出异常，触发事务回滚
                throw new PaymentFailedException(
                    "支付失败: " + result.getErrorMessage(), result.getErrorCode());
            }
            
        } catch (PaymentException e) {
            log.error("支付处理异常: orderId={}", orderId, e);
            // ✅ 重新抛出异常，确保事务回滚
            throw e;
        } catch (Exception e) {
            log.error("支付处理未知异常: orderId={}", orderId, e);
            throw new PaymentProcessException("支付处理失败", e);
        }
    }
    
    // ✅ 分布式事务一致性（使用Saga模式）
    @Transactional(rollbackFor = Exception.class)
    public OrderResult createOrderWithSaga(OrderRequest request) {
        try {
            // 1. 创建订单（本地事务）
            Order order = createOrder(request);
            
            // 2. 创建Saga事务
            SagaTransaction saga = sagaManager.begin("CREATE_ORDER_" + order.getId());
            
            try {
                // 3. 预留库存（补偿操作：释放库存）
                InventoryReservation reservation = inventoryService.reserveStock(
                    request.getProductId(), request.getQuantity());
                saga.addCompensation(() -> 
                    inventoryService.releaseReservation(reservation.getId()));
                
                // 4. 预授权支付（补偿操作：取消预授权）
                PaymentPreAuth preAuth = paymentService.preAuthorize(
                    request.getPaymentInfo(), order.getAmount());
                saga.addCompensation(() -> 
                    paymentService.cancelPreAuth(preAuth.getId()));
                
                // 5. 确认订单
                order.setStatus(OrderStatus.CONFIRMED);
                order.setInventoryReservationId(reservation.getId());
                order.setPaymentPreAuthId(preAuth.getId());
                orderRepository.save(order);
                
                // 6. 提交Saga事务
                saga.commit();
                
                log.info("订单创建成功（Saga）: orderId={}", order.getId());
                return OrderResult.success(order.getId());
                
            } catch (Exception e) {
                // ✅ Saga事务回滚，执行补偿操作
                saga.rollback();
                throw e;
            }
            
        } catch (Exception e) {
            log.error("订单创建失败（Saga）: request={}", request, e);
            throw new OrderProcessException("订单创建失败", e);
        }
    }
    
    // ✅ 正确的嵌套事务处理
    @Transactional(rollbackFor = Exception.class)
    public void processComplexOrder(OrderRequest request) {
        try {
            Order order = createOrder(request);
            
            List<OrderItemResult> itemResults = new ArrayList<>();;
            
            // ✅ 所有item在同一事务中处理
            for (OrderItem item : request.getItems()) {
                OrderItemResult result = processOrderItemInSameTransaction(order.getId(), item);
                itemResults.add(result);
            }
            
            // 验证所有item处理结果
            boolean allSuccess = itemResults.stream().allMatch(OrderItemResult::isSuccess);
            if (!allSuccess) {
                throw new OrderItemProcessException("部分订单项处理失败");
            }
            
            order.setStatus(OrderStatus.PROCESSED);
            orderRepository.save(order);
            
            log.info("复杂订单处理成功: orderId={}, itemCount={}", 
                    order.getId(), itemResults.size());
                    
        } catch (Exception e) {
            log.error("复杂订单处理失败: request={}", request, e);
            throw e;
        }
    }
    
    // ✅ 在同一事务中处理订单项
    private OrderItemResult processOrderItemInSameTransaction(Long orderId, OrderItem item) {
        try {
            // 保存订单项
            item.setOrderId(orderId);
            orderItemRepository.save(item);
            
            // 扣减库存
            inventoryService.reduceStock(item.getProductId(), item.getQuantity());
            
            return OrderItemResult.success(item.getId());
            
        } catch (Exception e) {
            log.error("订单项处理失败: orderId={}, item={}", orderId, item, e);
            return OrderItemResult.failure(e.getMessage());
        }
    }
    
    // ✅ 分离读写操作
    @Transactional(readOnly = true)
    public OrderStatistics calculateOrderStatistics(Date startDate, Date endDate) {
        try {
            List<Order> orders = orderRepository.findByDateRange(startDate, endDate);
            
            OrderStatistics stats = OrderStatistics.builder()
                .totalOrders(orders.size())
                .totalAmount(orders.stream()
                    .map(Order::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add))
                .averageAmount(calculateAverageAmount(orders))
                .startDate(startDate)
                .endDate(endDate)
                .calculatedAt(LocalDateTime.now())
                .build();
            
            log.debug("订单统计计算完成: period={} to {}, totalOrders={}", 
                    startDate, endDate, stats.getTotalOrders());
            
            return stats;
            
        } catch (Exception e) {
            log.error("计算订单统计失败: startDate={}, endDate={}", startDate, endDate, e);
            throw new StatisticsCalculationException("计算订单统计失败", e);
        }
    }
    
    // ✅ 单独的写操作
    @Transactional(rollbackFor = Exception.class)
    public void saveOrderStatistics(OrderStatistics statistics) {
        try {
            statisticsRepository.save(statistics);
            log.info("订单统计保存成功: period={} to {}", 
                    statistics.getStartDate(), statistics.getEndDate());
        } catch (Exception e) {
            log.error("保存订单统计失败: statistics={}", statistics, e);
            throw new StatisticsSaveException("保存订单统计失败", e);
        }
    }
    
    // ✅ 合理的事务超时设置
    @Transactional(rollbackFor = Exception.class, timeout = 300) // 5分钟
    public BatchProcessResult batchProcessOrders(List<OrderRequest> requests) {
        if (requests.size() > 1000) {
            throw new IllegalArgumentException("批量处理订单数量不能超过1000");
        }
        
        try {
            List<OrderResult> results = new ArrayList<>();
            int successCount = 0;
            int failureCount = 0;
            
            for (OrderRequest request : requests) {
                try {
                    OrderResult result = processOrderInBatch(request);
                    results.add(result);
                    if (result.isSuccess()) {
                        successCount++;
                    } else {
                        failureCount++;
                    }
                } catch (Exception e) {
                    log.warn("批量处理中单个订单失败: request={}", request, e);
                    results.add(OrderResult.failure(e.getMessage()));
                    failureCount++;
                }
            }
            
            log.info("批量订单处理完成: total={}, success={}, failure={}", 
                    requests.size(), successCount, failureCount);
            
            return BatchProcessResult.builder()
                .totalCount(requests.size())
                .successCount(successCount)
                .failureCount(failureCount)
                .results(results)
                .build();
                
        } catch (Exception e) {
            log.error("批量订单处理异常: count={}", requests.size(), e);
            throw new BatchProcessException("批量订单处理失败", e);
        }
    }
    
    // ✅ 事务外异步处理
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderProcessedEvent(OrderProcessedEvent event) {
        // ✅ 事务提交后异步处理通知
        CompletableFuture.runAsync(() -> {
            try {
                notificationService.sendOrderConfirmation(event.getOrderId());
                externalApiService.syncOrderToThirdParty(event.getOrderId());
                log.info("订单后续处理完成: orderId={}", event.getOrderId());
            } catch (Exception e) {
                log.error("订单后续处理失败: orderId={}", event.getOrderId(), e);
            }
        });
    }
    
    // ✅ 正确的事务传播行为
    @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED)
    public void updateOrderStatus(Long orderId, OrderStatus status, String reason) {
        try {
            Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + orderId));
            
            OrderStatus oldStatus = order.getStatus();
            
            // 验证状态转换是否合法
            if (!isValidStatusTransition(oldStatus, status)) {
                throw new InvalidStatusTransitionException(
                    String.format("无效的状态转换: %s -> %s", oldStatus, status));
            }
            
            // 更新订单状态
            order.setStatus(status);
            order.setUpdatedAt(LocalDateTime.now());
            orderRepository.save(order);
            
            // 记录状态变更历史
            OrderStatusHistory history = OrderStatusHistory.builder()
                .orderId(orderId)
                .fromStatus(oldStatus)
                .toStatus(status)
                .reason(reason)
                .createdAt(LocalDateTime.now())
                .build();
            orderStatusHistoryRepository.save(history);
            
            log.info("订单状态更新成功: orderId={}, {} -> {}, reason={}", 
                    orderId, oldStatus, status, reason);
                    
        } catch (Exception e) {
            log.error("订单状态更新失败: orderId={}, status={}", orderId, status, e);
            throw e;
        }
    }
    
    // ✅ 乐观锁处理并发更新
    @Transactional(rollbackFor = Exception.class)
    public void updateOrderWithOptimisticLock(Long orderId, OrderUpdateRequest request) {
        int maxRetries = 3;
        int retryCount = 0;
        
        while (retryCount < maxRetries) {
            try {
                Order order = orderRepository.findById(orderId)
                    .orElseThrow(() -> new OrderNotFoundException("订单不存在: " + orderId));
                
                // 更新订单信息
                order.setDeliveryAddress(request.getDeliveryAddress());
                order.setRemark(request.getRemark());
                order.setUpdatedAt(LocalDateTime.now());
                
                orderRepository.save(order);
                
                log.info("订单更新成功: orderId={}, version={}", orderId, order.getVersion());
                return;
                
            } catch (OptimisticLockingFailureException e) {
                retryCount++;
                if (retryCount >= maxRetries) {
                    log.error("订单更新失败，超过最大重试次数: orderId={}, retries={}", 
                            orderId, retryCount);
                    throw new ConcurrentUpdateException("订单正在被其他用户修改，请稍后重试");
                }
                
                log.warn("订单更新冲突，准备重试: orderId={}, retry={}", orderId, retryCount);
                
                try {
                    Thread.sleep(100 * retryCount); // 退避重试
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("重试被中断", ie);
                }
            }
        }
    }
    
    // 辅助方法
    private void validateOrderRequest(OrderRequest request) {
        if (request == null) {
            throw new ValidationException("订单请求不能为空");
        }
        if (request.getProductId() == null) {
            throw new ValidationException("产品ID不能为空");
        }
        if (request.getQuantity() <= 0) {
            throw new ValidationException("数量必须大于0");
        }
        if (request.getPaymentInfo() == null) {
            throw new ValidationException("支付信息不能为空");
        }
    }
    
    private boolean isValidStatusTransition(OrderStatus from, OrderStatus to) {
        // 定义合法的状态转换规则
        Map<OrderStatus, Set<OrderStatus>> validTransitions = Map.of(
            OrderStatus.PENDING, Set.of(OrderStatus.CONFIRMED, OrderStatus.CANCELLED),
            OrderStatus.CONFIRMED, Set.of(OrderStatus.PAID, OrderStatus.CANCELLED),
            OrderStatus.PAID, Set.of(OrderStatus.SHIPPED, OrderStatus.REFUNDED),
            OrderStatus.SHIPPED, Set.of(OrderStatus.DELIVERED, OrderStatus.RETURNED),
            OrderStatus.DELIVERED, Set.of(OrderStatus.COMPLETED, OrderStatus.RETURNED)
        );
        
        return validTransitions.getOrDefault(from, Set.of()).contains(to);
    }
}
```

### 4.21.3.2 数据校验完整性检查 🔴

**1. 检测目标**

a. 确保输入数据的完整性和有效性验证
b. 验证业务规则约束的正确实现
c. 检查数据库层面的一致性约束
d. 确保跨系统数据一致性验证

**2. 检测方法**

1. 数据验证框架检查（Bean Validation）
2. 业务规则测试
3. 数据库约束验证
4. 集成测试和端到端测试

**3. 错误示例**

```java
// ❌ 数据校验完整性问题
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // ❌ 缺少输入验证
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody UserCreateRequest request) {
        // ❌ 没有验证请求参数
        User user = userService.createUser(request);
        return ResponseEntity.ok(user);
    }
    
    // ❌ 验证不完整
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id, 
            @RequestBody UserUpdateRequest request) {
        // ❌ 只验证了部分字段
        if (request.getEmail() == null) {
            throw new ValidationException("邮箱不能为空");
        }
        
        User user = userService.updateUser(id, request);
        return ResponseEntity.ok(user);
    }
}

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    // ❌ 业务规则验证不完整
    public User createUser(UserCreateRequest request) {
        // ❌ 没有验证邮箱格式
        // ❌ 没有验证用户名唯一性
        // ❌ 没有验证密码强度
        
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setPassword(request.getPassword()); // ❌ 明文密码
        user.setAge(request.getAge());
        
        return userRepository.save(user);
    }
    
    // ❌ 数据一致性检查缺失
    public void transferUserData(Long fromUserId, Long toUserId) {
        User fromUser = userRepository.findById(fromUserId);
        User toUser = userRepository.findById(toUserId);
        
        // ❌ 没有验证用户是否存在
        // ❌ 没有验证业务规则（如用户状态）
        
        fromUser.setStatus(UserStatus.INACTIVE);
        toUser.setPoints(toUser.getPoints() + fromUser.getPoints());
        fromUser.setPoints(0);
        
        userRepository.save(fromUser);
        userRepository.save(toUser);
    }
    
    // ❌ 批量操作缺少验证
    public void batchUpdateUsers(List<UserUpdateRequest> requests) {
        for (UserUpdateRequest request : requests) {
            // ❌ 没有验证每个请求的有效性
            User user = userRepository.findById(request.getId());
            user.setEmail(request.getEmail());
            user.setPhone(request.getPhone());
            userRepository.save(user);
        }
    }
    
    // ❌ 跨系统数据同步缺少验证
    public void syncUserToExternalSystem(Long userId) {
        User user = userRepository.findById(userId);
        
        // ❌ 没有验证用户数据完整性
        // ❌ 没有验证外部系统的响应
        
        ExternalUserDto externalUser = new ExternalUserDto();
        externalUser.setId(user.getId());
        externalUser.setName(user.getUsername());
        externalUser.setEmail(user.getEmail());
        
        externalSystemClient.createUser(externalUser);
    }
    
    // ❌ 数据删除缺少完整性检查
    public void deleteUser(Long userId) {
        // ❌ 没有检查关联数据
        // ❌ 没有验证删除权限
        userRepository.deleteById(userId);
    }
    
    // ❌ 数据查询缺少边界检查
    public List<User> getUsersByAge(int minAge, int maxAge) {
        // ❌ 没有验证年龄范围的合理性
        return userRepository.findByAgeBetween(minAge, maxAge);
    }
    
    // ❌ 文件上传缺少验证
    public String uploadUserAvatar(Long userId, MultipartFile file) {
        // ❌ 没有验证文件类型
        // ❌ 没有验证文件大小
        // ❌ 没有验证文件内容
        
        String fileName = file.getOriginalFilename();
        String filePath = "/uploads/" + fileName;
        
        try {
            file.transferTo(new File(filePath));
        } catch (IOException e) {
            throw new RuntimeException("文件上传失败", e);
        }
        
        User user = userRepository.findById(userId);
        user.setAvatarUrl(filePath);
        userRepository.save(user);
        
        return filePath;
    }
    
    // ❌ 金额计算缺少精度验证
    public void updateUserBalance(Long userId, BigDecimal amount) {
        User user = userRepository.findById(userId);
        
        // ❌ 没有验证金额精度
        // ❌ 没有验证余额不能为负
        
        BigDecimal newBalance = user.getBalance().add(amount);
        user.setBalance(newBalance);
        userRepository.save(user);
    }
    
    // ❌ 日期处理缺少验证
    public void updateUserBirthday(Long userId, String birthday) {
        User user = userRepository.findById(userId);
        
        // ❌ 没有验证日期格式
        // ❌ 没有验证日期合理性（如未来日期）
        
        try {
            LocalDate birthDate = LocalDate.parse(birthday);
            user.setBirthday(birthDate);
            userRepository.save(user);
        } catch (DateTimeParseException e) {
            // ❌ 异常处理不当
            user.setBirthday(null);
            userRepository.save(user);
        }
    }
    
    // ❌ 枚举值缺少验证
    public void updateUserRole(Long userId, String roleName) {
        User user = userRepository.findById(userId);
        
        // ❌ 没有验证角色名称是否有效
        user.setRole(UserRole.valueOf(roleName)); // 可能抛出IllegalArgumentException
        userRepository.save(user);
    }
    
    // ❌ 集合数据缺少验证
    public void updateUserTags(Long userId, List<String> tags) {
        User user = userRepository.findById(userId);
        
        // ❌ 没有验证标签数量限制
        // ❌ 没有验证标签内容
        // ❌ 没有去重处理
        
        user.setTags(tags);
        userRepository.save(user);
    }
    
    // ❌ 关联数据缺少验证
    public void assignUserToGroup(Long userId, Long groupId) {
        User user = userRepository.findById(userId);
        Group group = groupRepository.findById(groupId);
        
        // ❌ 没有验证用户和组是否存在
        // ❌ 没有验证用户是否已在组中
        // ❌ 没有验证组的容量限制
        
        user.setGroupId(groupId);
        userRepository.save(user);
    }
}

// ❌ 实体类缺少验证注解
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // ❌ 缺少验证注解
    private String username;
    
    // ❌ 缺少邮箱格式验证
    private String email;
    
    // ❌ 缺少密码强度验证
    private String password;
    
    // ❌ 缺少年龄范围验证
    private Integer age;
    
    // ❌ 缺少余额精度验证
    private BigDecimal balance;
    
    // ❌ 缺少电话号码格式验证
    private String phone;
    
    // ❌ 缺少URL格式验证
    private String avatarUrl;
    
    // ❌ 缺少日期验证
    private LocalDate birthday;
    
    // ❌ 缺少枚举验证
    private UserRole role;
    
    // ❌ 缺少集合大小验证
    private List<String> tags;
    
    // getter和setter省略
}
```

**4. 正确示例**

```java
// ✅ 正确：完整的数据校验
@RestController
@RequestMapping("/api/users")
@Validated
@Slf4j
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // ✅ 完整的输入验证
    @PostMapping
    public ResponseEntity<UserResponse> createUser(
            @Valid @RequestBody UserCreateRequest request) {
        try {
            User user = userService.createUser(request);
            UserResponse response = UserResponse.from(user);
            
            log.info("用户创建成功: userId={}, username={}", user.getId(), user.getUsername());
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
            
        } catch (ValidationException e) {
            log.warn("用户创建验证失败: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("用户创建失败: request={}", request, e);
            throw new UserCreationException("用户创建失败", e);
        }
    }
    
    // ✅ 路径参数和请求体验证
    @PutMapping("/{id}")
    public ResponseEntity<UserResponse> updateUser(
            @PathVariable @Positive Long id,
            @Valid @RequestBody UserUpdateRequest request) {
        try {
            User user = userService.updateUser(id, request);
            UserResponse response = UserResponse.from(user);
            
            log.info("用户更新成功: userId={}", id);
            return ResponseEntity.ok(response);
            
        } catch (UserNotFoundException e) {
            log.warn("用户不存在: userId={}", id);
            throw e;
        } catch (ValidationException e) {
            log.warn("用户更新验证失败: userId={}, error={}", id, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("用户更新失败: userId={}, request={}", id, request, e);
            throw new UserUpdateException("用户更新失败", e);
        }
    }
    
    // ✅ 查询参数验证
    @GetMapping
    public ResponseEntity<PageResponse<UserResponse>> getUsers(
            @RequestParam(defaultValue = "0") @Min(0) int page,
            @RequestParam(defaultValue = "20") @Min(1) @Max(100) int size,
            @RequestParam(required = false) @Min(0) @Max(150) Integer minAge,
            @RequestParam(required = false) @Min(0) @Max(150) Integer maxAge) {
        try {
            PageRequest pageRequest = PageRequest.of(page, size);
            Page<User> users = userService.getUsers(pageRequest, minAge, maxAge);
            
            List<UserResponse> userResponses = users.getContent().stream()
                .map(UserResponse::from)
                .collect(Collectors.toList());
            
            PageResponse<UserResponse> response = PageResponse.<UserResponse>builder()
                .content(userResponses)
                .page(page)
                .size(size)
                .totalElements(users.getTotalElements())
                .totalPages(users.getTotalPages())
                .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("查询用户失败: page={}, size={}, minAge={}, maxAge={}", 
                    page, size, minAge, maxAge, e);
            throw new UserQueryException("查询用户失败", e);
        }
    }
    
    // ✅ 文件上传验证
    @PostMapping("/{id}/avatar")
    public ResponseEntity<String> uploadAvatar(
            @PathVariable @Positive Long id,
            @RequestParam("file") @NotNull MultipartFile file) {
        try {
            String avatarUrl = userService.uploadUserAvatar(id, file);
            
            log.info("头像上传成功: userId={}, avatarUrl={}", id, avatarUrl);
            return ResponseEntity.ok(avatarUrl);
            
        } catch (InvalidFileException e) {
            log.warn("无效文件: userId={}, fileName={}, error={}", 
                    id, file.getOriginalFilename(), e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("头像上传失败: userId={}, fileName={}", 
                    id, file.getOriginalFilename(), e);
            throw new FileUploadException("头像上传失败", e);
        }
    }
}

@Service
@Transactional
@Slf4j
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private GroupRepository groupRepository;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private FileStorageService fileStorageService;
    
    @Autowired
    private ExternalSystemClient externalSystemClient;
    
    @Autowired
    private Validator validator;
    
    // ✅ 完整的业务规则验证
    public User createUser(UserCreateRequest request) {
        try {
            // 1. 基础验证（通过@Valid已完成）
            
            // 2. 业务规则验证
            validateUserCreationRules(request);
            
            // 3. 创建用户
            User user = User.builder()
                .username(request.getUsername().trim())
                .email(request.getEmail().toLowerCase().trim())
                .password(passwordEncoder.encode(request.getPassword()))
                .age(request.getAge())
                .phone(request.getPhone())
                .role(UserRole.USER)
                .status(UserStatus.ACTIVE)
                .balance(BigDecimal.ZERO)
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();
            
            // 4. 保存用户
            User savedUser = userRepository.save(user);
            
            // 5. 发送欢迎邮件（异步）
            emailService.sendWelcomeEmailAsync(savedUser.getEmail(), savedUser.getUsername());
            
            log.info("用户创建成功: userId={}, username={}, email={}", 
                    savedUser.getId(), savedUser.getUsername(), savedUser.getEmail());
            
            return savedUser;
            
        } catch (ValidationException e) {
            log.warn("用户创建验证失败: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("用户创建异常: request={}", request, e);
            throw new UserCreationException("用户创建失败", e);
        }
    }
    
    // ✅ 业务规则验证方法
    private void validateUserCreationRules(UserCreateRequest request) {
        // 验证用户名唯一性
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new ValidationException("用户名已存在: " + request.getUsername());
        }
        
        // 验证邮箱唯一性
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new ValidationException("邮箱已被注册: " + request.getEmail());
        }
        
        // 验证手机号唯一性（如果提供）
        if (request.getPhone() != null && userRepository.existsByPhone(request.getPhone())) {
            throw new ValidationException("手机号已被注册: " + request.getPhone());
        }
        
        // 验证密码强度
        validatePasswordStrength(request.getPassword());
        
        // 验证年龄合理性
        if (request.getAge() != null) {
            LocalDate birthDate = LocalDate.now().minusYears(request.getAge());
            if (birthDate.isAfter(LocalDate.now()) || birthDate.isBefore(LocalDate.of(1900, 1, 1))) {
                throw new ValidationException("年龄不合理: " + request.getAge());
            }
        }
    }
    
    // ✅ 密码强度验证
    private void validatePasswordStrength(String password) {
        if (password.length() < 8) {
            throw new ValidationException("密码长度至少8位");
        }
        
        boolean hasUpper = password.chars().anyMatch(Character::isUpperCase);
        boolean hasLower = password.chars().anyMatch(Character::isLowerCase);
        boolean hasDigit = password.chars().anyMatch(Character::isDigit);
        boolean hasSpecial = password.chars().anyMatch(ch -> "!@#$%^&*()_+-=[]{}|;:,.<>?".indexOf(ch) >= 0);
        
        int strengthScore = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSpecial ? 1 : 0);
        
        if (strengthScore < 3) {
            throw new ValidationException("密码强度不足，需要包含大写字母、小写字母、数字、特殊字符中的至少3种");
        }
    }
    
    // ✅ 数据一致性检查
    @Transactional(rollbackFor = Exception.class)
    public void transferUserData(TransferUserDataRequest request) {
        try {
            // 1. 验证请求参数
            validateTransferRequest(request);
            
            // 2. 获取用户（加锁防止并发）
            User fromUser = userRepository.findByIdForUpdate(request.getFromUserId())
                .orElseThrow(() -> new UserNotFoundException("源用户不存在: " + request.getFromUserId()));
            
            User toUser = userRepository.findByIdForUpdate(request.getToUserId())
                .orElseThrow(() -> new UserNotFoundException("目标用户不存在: " + request.getToUserId()));
            
            // 3. 验证业务规则
            validateTransferBusinessRules(fromUser, toUser, request);
            
            // 4. 执行数据转移
            BigDecimal transferAmount = request.getAmount();
            
            if (fromUser.getBalance().compareTo(transferAmount) < 0) {
                throw new InsufficientBalanceException("余额不足");
            }
            
            fromUser.setBalance(fromUser.getBalance().subtract(transferAmount));
            toUser.setBalance(toUser.getBalance().add(transferAmount));
            
            // 5. 转移积分
            if (request.isTransferPoints()) {
                toUser.setPoints(toUser.getPoints() + fromUser.getPoints());
                fromUser.setPoints(0);
            }
            
            // 6. 更新状态
            fromUser.setStatus(UserStatus.INACTIVE);
            fromUser.setUpdatedAt(LocalDateTime.now());
            toUser.setUpdatedAt(LocalDateTime.now());
            
            // 7. 保存更改
            userRepository.save(fromUser);
            userRepository.save(toUser);
            
            // 8. 记录转移历史
            UserTransferHistory history = UserTransferHistory.builder()
                .fromUserId(request.getFromUserId())
                .toUserId(request.getToUserId())
                .amount(transferAmount)
                .pointsTransferred(request.isTransferPoints() ? fromUser.getPoints() : 0)
                .reason(request.getReason())
                .createdAt(LocalDateTime.now())
                .build();
            
            userTransferHistoryRepository.save(history);
            
            log.info("用户数据转移成功: from={}, to={}, amount={}, points={}", 
                    request.getFromUserId(), request.getToUserId(), 
                    transferAmount, request.isTransferPoints());
                    
        } catch (Exception e) {
            log.error("用户数据转移失败: request={}", request, e);
            throw e;
        }
    }
    
    // ✅ 批量操作验证
    @Transactional(rollbackFor = Exception.class)
    public BatchUpdateResult batchUpdateUsers(List<UserUpdateRequest> requests) {
        if (requests == null || requests.isEmpty()) {
            throw new ValidationException("批量更新请求不能为空");
        }
        
        if (requests.size() > 1000) {
            throw new ValidationException("批量更新数量不能超过1000");
        }
        
        try {
            List<BatchUpdateResult.Item> results = new ArrayList<>();
            int successCount = 0;
            int failureCount = 0;
            
            for (UserUpdateRequest request : requests) {
                try {
                    // 验证单个请求
                    validateSingleUpdateRequest(request);
                    
                    // 执行更新
                    User user = updateUserInternal(request);
                    
                    results.add(BatchUpdateResult.Item.success(request.getId(), user.getVersion()));
                    successCount++;
                    
                } catch (Exception e) {
                    log.warn("批量更新中单个用户失败: userId={}, error={}", 
                            request.getId(), e.getMessage());
                    
                    results.add(BatchUpdateResult.Item.failure(request.getId(), e.getMessage()));
                    failureCount++;
                }
            }
            
            log.info("批量用户更新完成: total={}, success={}, failure={}", 
                    requests.size(), successCount, failureCount);
            
            return BatchUpdateResult.builder()
                .totalCount(requests.size())
                .successCount(successCount)
                .failureCount(failureCount)
                .items(results)
                .build();
                
        } catch (Exception e) {
            log.error("批量用户更新异常: count={}", requests.size(), e);
            throw new BatchUpdateException("批量用户更新失败", e);
        }
    }
    
    // ✅ 跨系统数据同步验证
    public void syncUserToExternalSystem(Long userId) {
        try {
            // 1. 获取用户
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
            
            // 2. 验证用户数据完整性
            validateUserDataIntegrity(user);
            
            // 3. 构建外部系统数据
            ExternalUserDto externalUser = ExternalUserDto.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(user.getEmail())
                .phone(user.getPhone())
                .status(mapUserStatus(user.getStatus()))
                .createdAt(user.getCreatedAt())
                .updatedAt(user.getUpdatedAt())
                .build();
            
            // 4. 验证外部数据
            validateExternalUserData(externalUser);
            
            // 5. 同步到外部系统
            ExternalSyncResult result = externalSystemClient.syncUser(externalUser);
            
            // 6. 验证同步结果
            if (!result.isSuccess()) {
                throw new ExternalSyncException("外部系统同步失败: " + result.getErrorMessage());
            }
            
            // 7. 更新同步状态
            user.setLastSyncAt(LocalDateTime.now());
            user.setExternalSystemId(result.getExternalId());
            userRepository.save(user);
            
            log.info("用户同步到外部系统成功: userId={}, externalId={}", 
                    userId, result.getExternalId());
                    
        } catch (Exception e) {
            log.error("用户同步到外部系统失败: userId={}", userId, e);
            throw new ExternalSyncException("用户同步失败", e);
        }
    }
    
    // ✅ 数据删除完整性检查
    @Transactional(rollbackFor = Exception.class)
    public void deleteUser(Long userId, String reason) {
        try {
            // 1. 获取用户
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
            
            // 2. 验证删除权限
            validateDeletePermission(user);
            
            // 3. 检查关联数据
            validateUserDeletionConstraints(userId);
            
            // 4. 软删除用户
            user.setStatus(UserStatus.DELETED);
            user.setDeletedAt(LocalDateTime.now());
            user.setDeleteReason(reason);
            user.setUpdatedAt(LocalDateTime.now());
            
            userRepository.save(user);
            
            // 5. 处理关联数据
            handleUserDeletionCleanup(userId);
            
            log.info("用户删除成功: userId={}, reason={}", userId, reason);
            
        } catch (Exception e) {
            log.error("用户删除失败: userId={}, reason={}", userId, reason, e);
            throw e;
        }
    }
    
    // ✅ 文件上传完整验证
    public String uploadUserAvatar(Long userId, MultipartFile file) {
        try {
            // 1. 验证用户存在
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
            
            // 2. 验证文件
            validateUploadFile(file);
            
            // 3. 上传文件
            String fileName = generateAvatarFileName(userId, file.getOriginalFilename());
            String avatarUrl = fileStorageService.uploadFile(file, "avatars", fileName);
            
            // 4. 更新用户头像
            String oldAvatarUrl = user.getAvatarUrl();
            user.setAvatarUrl(avatarUrl);
            user.setUpdatedAt(LocalDateTime.now());
            userRepository.save(user);
            
            // 5. 删除旧头像（异步）
            if (oldAvatarUrl != null && !oldAvatarUrl.isEmpty()) {
                fileStorageService.deleteFileAsync(oldAvatarUrl);
            }
            
            log.info("用户头像上传成功: userId={}, avatarUrl={}", userId, avatarUrl);
            return avatarUrl;
            
        } catch (Exception e) {
            log.error("用户头像上传失败: userId={}, fileName={}", 
                    userId, file.getOriginalFilename(), e);
            throw e;
        }
    }
    
    // ✅ 金额计算精度验证
    @Transactional(rollbackFor = Exception.class)
    public void updateUserBalance(Long userId, BigDecimal amount, String reason) {
        try {
            // 1. 验证参数
            if (amount == null) {
                throw new ValidationException("金额不能为空");
            }
            
            // 验证金额精度（最多2位小数）
            if (amount.scale() > 2) {
                throw new ValidationException("金额精度不能超过2位小数");
            }
            
            // 验证金额范围
            if (amount.abs().compareTo(new BigDecimal("999999999.99")) > 0) {
                throw new ValidationException("金额超出允许范围");
            }
            
            // 2. 获取用户（加锁）
            User user = userRepository.findByIdForUpdate(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
            
            // 3. 计算新余额
            BigDecimal oldBalance = user.getBalance();
            BigDecimal newBalance = oldBalance.add(amount);
            
            // 4. 验证余额不能为负
            if (newBalance.compareTo(BigDecimal.ZERO) < 0) {
                throw new InsufficientBalanceException(
                    String.format("余额不足: 当前余额=%s, 变动金额=%s", oldBalance, amount));
            }
            
            // 5. 更新余额
            user.setBalance(newBalance);
            user.setUpdatedAt(LocalDateTime.now());
            userRepository.save(user);
            
            // 6. 记录余额变动历史
            BalanceHistory history = BalanceHistory.builder()
                .userId(userId)
                .oldBalance(oldBalance)
                .newBalance(newBalance)
                .amount(amount)
                .reason(reason)
                .createdAt(LocalDateTime.now())
                .build();
            
            balanceHistoryRepository.save(history);
            
            log.info("用户余额更新成功: userId={}, oldBalance={}, newBalance={}, amount={}, reason={}", 
                    userId, oldBalance, newBalance, amount, reason);
                    
        } catch (Exception e) {
            log.error("用户余额更新失败: userId={}, amount={}, reason={}", 
                    userId, amount, reason, e);
            throw e;
        }
    }
    
    // ✅ 日期处理验证
    public void updateUserBirthday(Long userId, String birthday) {
        try {
            // 1. 获取用户
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
            
            // 2. 验证日期格式和合理性
            LocalDate birthDate = validateAndParseBirthday(birthday);
            
            // 3. 更新生日
            user.setBirthday(birthDate);
            user.setAge(calculateAge(birthDate));
            user.setUpdatedAt(LocalDateTime.now());
            
            userRepository.save(user);
            
            log.info("用户生日更新成功: userId={}, birthday={}, age={}", 
                    userId, birthDate, user.getAge());
                    
        } catch (Exception e) {
            log.error("用户生日更新失败: userId={}, birthday={}", userId, birthday, e);
            throw e;
        }
    }
    
    // ✅ 枚举值验证
    public void updateUserRole(Long userId, String roleName) {
        try {
            // 1. 验证角色名称
            UserRole role = validateAndParseUserRole(roleName);
            
            // 2. 获取用户
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
            
            // 3. 验证角色变更权限
            validateRoleChangePermission(user.getRole(), role);
            
            // 4. 更新角色
            UserRole oldRole = user.getRole();
            user.setRole(role);
            user.setUpdatedAt(LocalDateTime.now());
            
            userRepository.save(user);
            
            // 5. 记录角色变更历史
            RoleChangeHistory history = RoleChangeHistory.builder()
                .userId(userId)
                .oldRole(oldRole)
                .newRole(role)
                .createdAt(LocalDateTime.now())
                .build();
            
            roleChangeHistoryRepository.save(history);
            
            log.info("用户角色更新成功: userId={}, oldRole={}, newRole={}", 
                    userId, oldRole, role);
                    
        } catch (Exception e) {
            log.error("用户角色更新失败: userId={}, roleName={}", userId, roleName, e);
            throw e;
        }
    }
    
    // ✅ 集合数据验证
    public void updateUserTags(Long userId, List<String> tags) {
        try {
            // 1. 获取用户
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
            
            // 2. 验证和处理标签
            List<String> validatedTags = validateAndProcessTags(tags);
            
            // 3. 更新标签
            user.setTags(validatedTags);
            user.setUpdatedAt(LocalDateTime.now());
            
            userRepository.save(user);
            
            log.info("用户标签更新成功: userId={}, tagCount={}", userId, validatedTags.size());
            
        } catch (Exception e) {
            log.error("用户标签更新失败: userId={}, tags={}", userId, tags, e);
            throw e;
        }
    }
    
    // ✅ 关联数据验证
    @Transactional(rollbackFor = Exception.class)
    public void assignUserToGroup(Long userId, Long groupId) {
        try {
            // 1. 获取用户和组
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在: " + userId));
            
            Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new GroupNotFoundException("组不存在: " + groupId));
            
            // 2. 验证分配规则
            validateUserGroupAssignment(user, group);
            
            // 3. 检查组容量
            int currentMemberCount = userRepository.countByGroupId(groupId);
            if (currentMemberCount >= group.getMaxMembers()) {
                throw new GroupCapacityExceededException(
                    String.format("组容量已满: 当前成员=%d, 最大容量=%d", 
                            currentMemberCount, group.getMaxMembers()));
            }
            
            // 4. 分配用户到组
            Long oldGroupId = user.getGroupId();
            user.setGroupId(groupId);
            user.setUpdatedAt(LocalDateTime.now());
            
            userRepository.save(user);
            
            // 5. 记录分配历史
            GroupAssignmentHistory history = GroupAssignmentHistory.builder()
                .userId(userId)
                .oldGroupId(oldGroupId)
                .newGroupId(groupId)
                .createdAt(LocalDateTime.now())
                .build();
            
            groupAssignmentHistoryRepository.save(history);
            
            log.info("用户分配到组成功: userId={}, oldGroupId={}, newGroupId={}", 
                    userId, oldGroupId, groupId);
                    
        } catch (Exception e) {
            log.error("用户分配到组失败: userId={}, groupId={}", userId, groupId, e);
            throw e;
        }
    }
    
    // 辅助验证方法
    private void validateUploadFile(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            throw new InvalidFileException("文件不能为空");
        }
        
        // 验证文件大小（最大5MB）
        long maxSize = 5 * 1024 * 1024;
        if (file.getSize() > maxSize) {
            throw new InvalidFileException("文件大小不能超过5MB");
        }
        
        // 验证文件类型
        String contentType = file.getContentType();
        List<String> allowedTypes = Arrays.asList("image/jpeg", "image/png", "image/gif");
        if (!allowedTypes.contains(contentType)) {
            throw new InvalidFileException("不支持的文件类型: " + contentType);
        }
        
        // 验证文件扩展名
        String fileName = file.getOriginalFilename();
        if (fileName == null || fileName.isEmpty()) {
            throw new InvalidFileException("文件名不能为空");
        }
        
        String extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();
        List<String> allowedExtensions = Arrays.asList("jpg", "jpeg", "png", "gif");
        if (!allowedExtensions.contains(extension)) {
            throw new InvalidFileException("不支持的文件扩展名: " + extension);
        }
    }
    
    private LocalDate validateAndParseBirthday(String birthday) {
        if (birthday == null || birthday.trim().isEmpty()) {
            throw new ValidationException("生日不能为空");
        }
        
        try {
            LocalDate birthDate = LocalDate.parse(birthday.trim());
            
            // 验证日期不能是未来
            if (birthDate.isAfter(LocalDate.now())) {
                throw new ValidationException("生日不能是未来日期");
            }
            
            // 验证年龄合理性（0-150岁）
            int age = Period.between(birthDate, LocalDate.now()).getYears();
            if (age < 0 || age > 150) {
                throw new ValidationException("年龄不合理: " + age);
            }
            
            return birthDate;
            
        } catch (DateTimeParseException e) {
            throw new ValidationException("日期格式错误，请使用YYYY-MM-DD格式: " + birthday);
        }
    }
    
    private UserRole validateAndParseUserRole(String roleName) {
        if (roleName == null || roleName.trim().isEmpty()) {
            throw new ValidationException("角色名称不能为空");
        }
        
        try {
            return UserRole.valueOf(roleName.trim().toUpperCase());
        } catch (IllegalArgumentException e) {
            List<String> validRoles = Arrays.stream(UserRole.values())
                .map(Enum::name)
                .collect(Collectors.toList());
            throw new ValidationException(
                String.format("无效的角色名称: %s, 有效值: %s", roleName, validRoles));
        }
    }
    
    private List<String> validateAndProcessTags(List<String> tags) {
        if (tags == null) {
            return new ArrayList<>();
        }
        
        // 验证标签数量
        if (tags.size() > 10) {
            throw new ValidationException("标签数量不能超过10个");
        }
        
        List<String> processedTags = new ArrayList<>();
        Set<String> uniqueTags = new HashSet<>();
        
        for (String tag : tags) {
            if (tag == null || tag.trim().isEmpty()) {
                continue; // 跳过空标签
            }
            
            String processedTag = tag.trim();
            
            // 验证标签长度
            if (processedTag.length() > 20) {
                throw new ValidationException("标签长度不能超过20个字符: " + processedTag);
            }
            
            // 验证标签内容（只允许字母、数字、中文、下划线、连字符）
            if (!processedTag.matches("^[\\w\\u4e00-\\u9fa5-]+$")) {
                throw new ValidationException("标签包含无效字符: " + processedTag);
            }
            
            // 去重
            if (uniqueTags.add(processedTag.toLowerCase())) {
                processedTags.add(processedTag);
            }
        }
        
        return processedTags;
    }
    
    private int calculateAge(LocalDate birthDate) {
        return Period.between(birthDate, LocalDate.now()).getYears();
    }
    
    // 其他辅助方法省略...
}

// ✅ 完整的实体验证
@Entity
@Table(name = "users")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 50, message = "用户名长度必须在3-50个字符之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    @Column(unique = true, nullable = false)
    private String username;
    
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    @Size(max = 100, message = "邮箱长度不能超过100个字符")
    @Column(unique = true, nullable = false)
    private String email;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 60, max = 60, message = "密码哈希长度必须为60")
    @Column(nullable = false)
    private String password;
    
    @Min(value = 0, message = "年龄不能小于0")
    @Max(value = 150, message = "年龄不能大于150")
    private Integer age;
    
    @DecimalMin(value = "0.00", message = "余额不能为负数")
    @DecimalMax(value = "999999999.99", message = "余额超出允许范围")
    @Digits(integer = 9, fraction = 2, message = "余额格式不正确")
    @Column(precision = 11, scale = 2, nullable = false)
    private BigDecimal balance = BigDecimal.ZERO;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    @Column(unique = true)
    private String phone;
    
    @URL(message = "头像URL格式不正确")
    @Size(max = 500, message = "头像URL长度不能超过500个字符")
    private String avatarUrl;
    
    @Past(message = "生日不能是未来日期")
    private LocalDate birthday;
    
    @NotNull(message = "用户角色不能为空")
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserRole role;
    
    @NotNull(message = "用户状态不能为空")
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserStatus status;
    
    @Size(max = 10, message = "标签数量不能超过10个")
    @ElementCollection
    @CollectionTable(name = "user_tags", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "tag")
    private List<@NotBlank @Size(max = 20) String> tags = new ArrayList<>();
    
    @Min(value = 0, message = "积分不能为负数")
    @Column(nullable = false)
    private Integer points = 0;
    
    @Positive(message = "组ID必须为正数")
    private Long groupId;
    
    @Size(max = 200, message = "删除原因长度不能超过200个字符")
    private String deleteReason;
    
    @PastOrPresent(message = "创建时间不能是未来")
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @PastOrPresent(message = "更新时间不能是未来")
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    private LocalDateTime deletedAt;
    
    private LocalDateTime lastSyncAt;
    
    private String externalSystemId;
    
    @Version
    private Long version;
    
    // 业务方法
    public boolean isActive() {
        return UserStatus.ACTIVE.equals(this.status);
    }
    
    public boolean isDeleted() {
        return UserStatus.DELETED.equals(this.status);
    }
    
    public boolean hasRole(UserRole role) {
        return this.role.equals(role);
    }
    
    public boolean hasTag(String tag) {
        return this.tags != null && this.tags.contains(tag);
    }
}

// ✅ 请求DTO验证
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreateRequest {
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 50, message = "用户名长度必须在3-50个字符之间")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
    private String username;
    
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    @Size(max = 100, message = "邮箱长度不能超过100个字符")
    private String email;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 8, max = 50, message = "密码长度必须在8-50个字符之间")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$", 
             message = "密码必须包含大小写字母、数字和特殊字符")
    private String password;
    
    @Min(value = 0, message = "年龄不能小于0")
    @Max(value = 150, message = "年龄不能大于150")
    private Integer age;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    @Size(max = 10, message = "标签数量不能超过10个")
    private List<@NotBlank @Size(max = 20) String> tags;
}
```

### 4.21.3.3 缓存一致性检查 🟡

**1. 检测目标**

a. 缓存与数据库数据一致性
b. 缓存更新策略的正确性
c. 分布式缓存一致性问题
d. 缓存穿透、击穿、雪崩防护

**2. 检测方法**

1. 缓存监控工具（Redis Monitor、Memcached Stats）
2. 一致性测试（并发读写测试）
3. 性能测试（压力测试、缓存命中率监控）
4. 分布式缓存同步测试

**3. 错误示例**

```java
// ❌ 缓存更新不及时，导致脏读
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void updateUser(User user) {
        // 只更新数据库，忘记更新缓存
        userRepository.save(user);
        // 缓存中仍是旧数据
    }
    
    public User getUser(Long userId) {
        String key = "user:" + userId;
        User user = (User) redisTemplate.opsForValue().get(key);
        if (user == null) {
            user = userRepository.findById(userId).orElse(null);
            redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
        }
        return user;
    }
}

// ❌ 缓存删除失败，数据不一致
public class ProductService {
    public void updateProduct(Product product) {
        productRepository.save(product);
        try {
            redisTemplate.delete("product:" + product.getId());
        } catch (Exception e) {
            // 删除缓存失败，但没有处理
            log.error("Cache delete failed", e);
        }
    }
}

// ❌ 并发更新缓存时的竞态条件
public class CounterService {
    public void incrementCounter(String key) {
        Integer count = (Integer) redisTemplate.opsForValue().get(key);
        if (count == null) {
            count = 0;
        }
        // 竞态条件：多个线程可能同时读取到相同值
        count++;
        redisTemplate.opsForValue().set(key, count);
    }
}

// ❌ 缓存穿透攻击
public class ArticleService {
    public Article getArticle(Long articleId) {
        String key = "article:" + articleId;
        Article article = (Article) redisTemplate.opsForValue().get(key);
        if (article == null) {
            article = articleRepository.findById(articleId).orElse(null);
            // 没有防护措施，恶意请求不存在的ID会直接打到数据库
            if (article != null) {
                redisTemplate.opsForValue().set(key, article, 1, TimeUnit.HOURS);
            }
        }
        return article;
    }
}

// ❌ 缓存雪崩问题
public class CategoryService {
    public List<Category> getAllCategories() {
        String key = "categories:all";
        List<Category> categories = (List<Category>) redisTemplate.opsForValue().get(key);
        if (categories == null) {
            categories = categoryRepository.findAll();
            // 所有缓存都设置相同的过期时间，可能同时失效
            redisTemplate.opsForValue().set(key, categories, 1, TimeUnit.HOURS);
        }
        return categories;
    }
}

// ❌ 分布式环境下缓存同步问题
public class ConfigService {
    private Map<String, String> localCache = new ConcurrentHashMap<>();
    
    public String getConfig(String key) {
        // 只使用本地缓存，多实例间数据不一致
        return localCache.computeIfAbsent(key, k -> {
            return configRepository.findByKey(k).getValue();
        });
    }
    
    public void updateConfig(String key, String value) {
        configRepository.updateByKey(key, value);
        localCache.put(key, value); // 只更新当前实例的缓存
    }
}
```

**4. 正确示例**

```java
// ✅ 正确：使用Cache-Aside模式确保缓存一致性
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private RedissonClient redissonClient;
    
    public User getUser(Long userId) {
        String key = "user:" + userId;
        User user = (User) redisTemplate.opsForValue().get(key);
        if (user == null) {
            // 使用分布式锁防止缓存击穿
            RLock lock = redissonClient.getLock("lock:user:" + userId);
            try {
                if (lock.tryLock(5, 10, TimeUnit.SECONDS)) {
                    // 双重检查
                    user = (User) redisTemplate.opsForValue().get(key);
                    if (user == null) {
                        user = userRepository.findById(userId).orElse(null);
                        if (user != null) {
                            redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
                        } else {
                            // 防止缓存穿透：缓存空值
                            redisTemplate.opsForValue().set(key, new NullUser(), 5, TimeUnit.MINUTES);
                        }
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                if (lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        }
        return user instanceof NullUser ? null : user;
    }
    
    @Transactional
    public void updateUser(User user) {
        userRepository.save(user);
        // 删除缓存而不是更新，避免并发问题
        String key = "user:" + user.getId();
        redisTemplate.delete(key);
        
        // 发送缓存失效通知给其他实例
        redisTemplate.convertAndSend("cache:invalidate", key);
    }
    
    // 空对象模式防止缓存穿透
    private static class NullUser extends User {
        // 标记对象
    }
}

// ✅ 正确：使用原子操作处理并发更新
@Service
public class CounterService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public Long incrementCounter(String key) {
        // 使用Redis原子操作
        return redisTemplate.opsForValue().increment(key);
    }
    
    public Long incrementCounterWithExpire(String key, long timeout, TimeUnit unit) {
        Long result = redisTemplate.opsForValue().increment(key);
        if (result == 1) {
            // 第一次设置时添加过期时间
            redisTemplate.expire(key, timeout, unit);
        }
        return result;
    }
}

// ✅ 正确：使用布隆过滤器防止缓存穿透
@Service
public class ArticleService {
    @Autowired
    private ArticleRepository articleRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private BloomFilter<Long> bloomFilter;
    
    @PostConstruct
    public void init() {
        // 初始化布隆过滤器
        bloomFilter = BloomFilter.create(Funnels.longFunnel(), 1000000, 0.01);
        // 将所有存在的文章ID加入布隆过滤器
        List<Long> existingIds = articleRepository.findAllIds();
        existingIds.forEach(bloomFilter::put);
    }
    
    public Article getArticle(Long articleId) {
        // 先检查布隆过滤器
        if (!bloomFilter.mightContain(articleId)) {
            return null; // 肯定不存在
        }
        
        String key = "article:" + articleId;
        Article article = (Article) redisTemplate.opsForValue().get(key);
        if (article == null) {
            article = articleRepository.findById(articleId).orElse(null);
            if (article != null) {
                // 随机过期时间防止缓存雪崩
                int randomExpire = 3600 + new Random().nextInt(1800); // 1-2.5小时
                redisTemplate.opsForValue().set(key, article, randomExpire, TimeUnit.SECONDS);
            } else {
                // 缓存空值，较短过期时间
                redisTemplate.opsForValue().set(key, new NullArticle(), 300, TimeUnit.SECONDS);
            }
        }
        return article instanceof NullArticle ? null : article;
    }
    
    private static class NullArticle extends Article {
        // 空对象标记
    }
}

// ✅ 正确：实现缓存预热和降级策略
@Service
public class CategoryService {
    @Autowired
    private CategoryRepository categoryRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private RedissonClient redissonClient;
    
    private volatile List<Category> fallbackCache = new ArrayList<>();
    
    @PostConstruct
    public void warmUpCache() {
        // 应用启动时预热缓存
        List<Category> categories = categoryRepository.findAll();
        fallbackCache = new ArrayList<>(categories);
        
        String key = "categories:all";
        // 设置随机过期时间防止雪崩
        int randomExpire = 3600 + new Random().nextInt(1800);
        redisTemplate.opsForValue().set(key, categories, randomExpire, TimeUnit.SECONDS);
    }
    
    public List<Category> getAllCategories() {
        String key = "categories:all";
        try {
            List<Category> categories = (List<Category>) redisTemplate.opsForValue().get(key);
            if (categories == null) {
                // 缓存失效时使用分布式锁
                RLock lock = redissonClient.getLock("lock:categories");
                try {
                    if (lock.tryLock(2, 10, TimeUnit.SECONDS)) {
                        categories = (List<Category>) redisTemplate.opsForValue().get(key);
                        if (categories == null) {
                            categories = categoryRepository.findAll();
                            fallbackCache = new ArrayList<>(categories);
                            
                            int randomExpire = 3600 + new Random().nextInt(1800);
                            redisTemplate.opsForValue().set(key, categories, randomExpire, TimeUnit.SECONDS);
                        }
                    } else {
                        // 获取锁失败，使用降级数据
                        return new ArrayList<>(fallbackCache);
                    }
                } finally {
                    if (lock.isHeldByCurrentThread()) {
                        lock.unlock();
                    }
                }
            }
            return categories;
        } catch (Exception e) {
            log.error("Cache error, using fallback", e);
            // 缓存异常时使用降级数据
            return new ArrayList<>(fallbackCache);
        }
    }
}

// ✅ 正确：分布式缓存同步机制
@Service
public class ConfigService {
    @Autowired
    private ConfigRepository configRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private final Map<String, String> localCache = new ConcurrentHashMap<>();
    
    @EventListener
    public void handleCacheInvalidation(String key) {
        localCache.remove(key);
    }
    
    public String getConfig(String key) {
        // 先查本地缓存
        String value = localCache.get(key);
        if (value != null) {
            return value;
        }
        
        // 再查Redis缓存
        value = (String) redisTemplate.opsForValue().get("config:" + key);
        if (value != null) {
            localCache.put(key, value);
            return value;
        }
        
        // 最后查数据库
        Config config = configRepository.findByKey(key);
        if (config != null) {
            value = config.getValue();
            localCache.put(key, value);
            redisTemplate.opsForValue().set("config:" + key, value, 1, TimeUnit.HOURS);
            return value;
        }
        
        return null;
    }
    
    @Transactional
    public void updateConfig(String key, String value) {
        configRepository.updateByKey(key, value);
        
        // 删除所有层级的缓存
        localCache.remove(key);
        redisTemplate.delete("config:" + key);
        
        // 通知其他实例清除本地缓存
        redisTemplate.convertAndSend("config:invalidate", key);
    }
    
    @RedisMessageListener("config:invalidate")
    public void onConfigInvalidate(String key) {
        localCache.remove(key);
        log.info("Local cache invalidated for key: {}", key);
    }
}

// ✅ 正确：缓存版本控制机制
@Service
public class VersionedCacheService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void setWithVersion(String key, Object value, long version) {
        String versionKey = key + ":version";
        String dataKey = key + ":data";
        
        // 使用Lua脚本保证原子性
        String script = 
            "local currentVersion = redis.call('get', KEYS[1]) " +
            "if currentVersion == false or tonumber(currentVersion) < tonumber(ARGV[1]) then " +
            "  redis.call('set', KEYS[1], ARGV[1]) " +
            "  redis.call('set', KEYS[2], ARGV[2]) " +
            "  return 1 " +
            "else " +
            "  return 0 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(script);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(redisScript, 
            Arrays.asList(versionKey, dataKey), 
            String.valueOf(version), 
            JSON.toJSONString(value));
        
        if (result == 0) {
            log.warn("Version conflict for key: {}, current version is newer", key);
        }
    }
    
    public <T> T getWithVersion(String key, Class<T> clazz) {
        String dataKey = key + ":data";
        String data = (String) redisTemplate.opsForValue().get(dataKey);
        if (data != null) {
            return JSON.parseObject(data, clazz);
        }
        return null;
    }
}
```