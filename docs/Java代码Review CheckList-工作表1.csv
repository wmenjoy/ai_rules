,,,,,,,,,,,
,,,,,,,,,,,
,检查分类,子分类,检查项,检查要求,,,,,,,
,需求与设计,影响分析,控制变更影响范围,"1、变更应该尽可能的影响小
2、应该有备份，回滚方案（严格的流程机制）
3、借助合理的开关、灰度测试机制",,,,,,,
,,设计与需求的匹配,设计的方案应该是在需求匹配、成本、可行性的相对最佳方案,1、对比可能方案，是否有更合理，可行的方案,,,,,,,
,,,代码的所做的变更是否和需求的声明一致,,,,,,,,
,,文档完整性,API文档，需求文档，变更文档，变更计划、用户指南、架构文档等规范，期权，一致,,,,,,,,
,,逻辑完整性,业务逻辑的分支应该尽可能的覆盖正常流程和异常情况的分支,,,,,,,,
,代码结构和组织,代码规范,注释完整性,关键逻辑、边界处理是否有清晰注释	,,,,,,,
,,,代码分层结构合理,代码结构层次清晰，单个文件职责单一,,,,,,,
,,,硬编码,使用配置或常量类,,,,,,,
,,,是否使用了统一格式化工具,"1、统一的强制化代码格式化工具
2、一直的代码风格的Rule（AI工具)",,,,,,,
,,模块化与依赖管理,代码模块和类的划分是否合理,是否符合模块边界/职责划分，耦合度是否合理,,,,,,,
,,,接口和抽象类是否合理使用,分析接口类和抽象类的抽象逻辑是否合理,,,,,,,
,,,第三方组件管理(新增的第三方的依赖Jar包是否明确、安全),"1、新增的第三方依赖jar包，必须经过审核（版权（Licence、稳定性、社区状态等）
2、版本冲突，安全漏洞等需要充分考虑（发版、和代码扫描解决）",,,,,,,
,,,最小化第三方依赖,减少攻击面,,,,,,,
,,,作为SDK提供给别人暴漏给别人的依赖要尽量隔离,"1、暴漏给别人的jar包要经过安全审核,非必要信息不暴漏，机密代码必须混淆、脱敏后才可
2、暴漏给别人的Jar，应该尽量不要把自己的依赖第三方的jar包，带给你的使用者。",,,,,,,
,,架构设计,设计模式恰当性,设计模式应用恰当，不过度设计,,,,,,,
,,其他,默认配置安全合理,"默认账户和密码必须禁用或更改
默认必须启用安全功能（如HTTPS、CSRF保护）
默认必须禁用不必要的功能和服务
配置文件不得包含敏感信息（如凭证、密钥）",,,,,,,
,线程安全与并发处理,线程池,自定义线程池,尽量使用自定义线程池,,,,,,,
,,,线程池配置	,"[严重] 线程池核心线程数、最大线程数、队列容量配置是否合理
[严重] 是否配置了拒绝策略
[重要] 线程池是否有名称，便于监控和调试
[重要] 线程池是否配置了合理的关闭策略",,2,线程安全与并发处理,,,,
,,spring,Spring的@Service类中的线程是否有并发问题,是否存在@Service类中共享变量被多线程访问未加同步	,,,2.1,线程池配置 (,,,
,,,异步执行	@Async 是否正确使用,@Async使用是否配置线程池（默认线程池会带来性能风险）	,,,,,2.1.1 避免使用 Executors.newCachedThreadPool(),P3C/Sonar/AI/扔工,检查啊结果
,,其他,并发集合类是否正确使用,"是否使用了非并发的API
没有使用更有效的接口",,,,,,,
,,,是否考虑了可见性、有序性和原子性问题,,,,,,,,
,,,否避免使用过度同步，导致性能下降,AtomicLong/Volatile， 读写锁的使用等等,,,,,,,
,,并发控制, 是否避免了死锁、活锁和饥饿问题,,,,,,,,
,,,是否合理使用CompletableFuture进行异步操作,,,,,,,,
,,,是否考虑使用不可变对象减少并发问题,,,,,,,,
,数据处理,数据可靠性,数据持久化,考虑数据是否正确的写入,,,,,,,
,,,数据需要验证,所有的输入都需要完整性和有效性验证,,,,,,,
,,,数据完整性校验,数据的所有操作应该尽量使用事务（ACID）来完成,,,,,,,
,,,数据的备份和恢复,关键数据有定期备份机制，能够恢复到特定时间点,,,,,,,
,状态管理,状态管理,状态管理,系统状态转换图完整，所有状态转换都有处理机制，都能走入终态,,,,,,,
,业务正确性,边界条件处理,所有函数的输入边界条件（最小值、最大值、空值等）都有处理机制,,,,,,,,
,,算法正确性,测试正确、逻辑正确,,,,,,,,
,,并发正确性,分析代码算法的逻辑正确性,,,,,,,,
,资源管理,资源使用监控,系统关键资源(CPU、内存、磁盘、连接数)有实时监控和报警,,,,,,,,
,,资源限制策略,系统资源使用有明确上限，并有自动预警机制,,,,,,,,
,,资源泄漏检测,资源监测应该有泄露检测机制,,,,,,,,
,,资源释放保障	,资源获取与释放配对使用,,,,,,,,
,,数据库连接池,数据库连接池配置是否合理(大小、超时、检测),"1、mysql的8小时问题
2、连接池的大小，回收检测问题是否避免",,,,,,,
,,,是否监控连接池状态,,,,,,,,
,,,是否有连接泄漏检测机制,,,,,,,,
,,HTTP客户端连接池配置,HTTP客户端连接池配置是否合理,超时、KeepAlive设置是否合理,,,,,,,
,,,是否有连接泄漏检测机制,,,,,,,,
,,,是否监控连接池状态,,,,,,,,
,,超时配置,所有外部服务调用是否设置了合理的超时时间,,,,,,,,
,,,HTTP请求是否配置了连接超时和读取超时,,,,,,,,
,,,定时任务是否有执行超时控制,,,,,,,,
,,,长事务是否有超时控制,,,,,,,,
,,资源释放,是否使用try-with-resources确保资源关闭,,,,,,,,
,,,自定义的资源是否在finally块中关闭,,,,,,,,
,,,是否避免资源泄漏(文件句柄、数据库连接等),,,,,,,,
,,,是否实现了AutoCloseable接口以便资源自动关闭,,,,,,,,
,,redis,redis的连接池是否设置合理,,,,,,,,
,,,Redis的key是否有合理的过期时间,,,,,,,,
,,,是否使用了非安全的Redis命令操作,,,,,,,,
,,,Redis的操作是否考虑了网络的抖动,,,,,,,,
,,其他,关键资源是否有冗余、限流和故障转移,,,,,,,,
,异常处理,异常设计,异常体系,是否可以区分业务异常和系统异常,,,,,,,
,,,异常处理是否完备,所有可预见的异常都处理了,,,,,,,
,,,上下文信息,是否有足够的上下文（进一步区分业务失败的原因）,,,,,,,
,,,异常分类处理,是否可以不用catch Exception处理过于宽泛的异常,,,,,,,
,,,非业务异常是否有报警和处理机制,空指针等关键异常应该有有一例处理一例,,,,,,,
,,,异常的日志是否打印了多处,建议谁处理谁打印,,,,,,,
,,异常传播,是否实现了全局异常处理机制,,,,,,,,
,,,异常信息是否对用户友好，不暴露敏感信息,,,,,,,,
,,,是否记录了异常的完整堆栈信息,,,,,,,,
,,,是否合理使用受检异常和运行时异常,,,,,,,,
,,重试和降级,异常重试,可重试的操作是否实现的重试机制,,,,,,,
,,,异常降级,是否可以根据异常进行服务降级,,,,,,,
,,,异常熔断,是否使用熔断器模式防止级联失败,,,,,,,
,,,重试参数设置,重试次数和间隔是否可配置,,,,,,,
,日志和监控,日志,日志工具合理,"[严重] 是否避免在生产环境使用System.out或e.printStackTrace()
【重要】使用log4j + logback打印日志

",,,,,,,
,,,日志配置文件的合理设置,"1、buffer的大小
2、日志目录的规范
3、生产关闭console
4、使用异步Appender更新",,,,,,,
,,,上下文充分,"【重要】日志要包含包含请求ID、用户ID等上下文信息
",,,,,,,
,,,日志等级合理, 【重要】是否使用合适的日志级别(ERROR/WARN/INFO/DEBUG),,,,,,,
,,,关闭控制台日志,是否关闭默认console日志输出（如Spring Boot控制台彩色日志）,,,,,,,
,,,敏感信息处理,是否避免记录敏感信息(密码、令牌等),,,,,,,
,,监控,业务集成级别的埋点框架和Tracing框架,,,,,,,,
,,,外部依赖和对外暴漏的接口是否合理集成了埋点,,,,,,,,
,,,关键的业务指标是否接入了监控，并能有效定位问题,,,,,,,,
,,,埋点是否可以用来识别性能问题,,,,,,,,
,,健康检查,是否实现了健康检查接口,,,,,,,,
,,,是否实现了就绪检查接口,,,,,,,,
,,,是否设置了合理的健康检查超时时间,,,,,,,,
,,,所有外部输入必须验证,,,,,,,,
,,,防注入措施,是否存在拼接SQL、未使用预编译语句	,,,,,,,
,,,权限控制,是否对外暴露接口进行权限控制和认证	,,,,,,,
,,,输出编码	,所有输出到客户端的数据必须进行适当的编码，防止XSS攻击。,,,,,,,
,,,特殊字符处理,,,,,,,,
,,,类型安全,,,,,,,,
,,,边界条件处理,,,,,,,,
,安全,认证和授权,认证机制,,,,,,,,
,,,细粒度授权,,,,,,,,
,,,敏感信息处理,"1、 敏感信息的安全存储
2、敏感信息的安全传递（URL，BODY等传递）",,,,,,,
,,密码学的实践,使用标准加密算法,"1. 安全的加密算法、秘钥交换算法、消息摘要算法的使用
2、国密的使用",,,,,,,
,,,秘钥管理,合理的秘钥存储，轮转、传播、生成机制,,,,,,,
,,通信安全,使用安全的通信协议,[严重] 是否使用HTTPS进行通信,,,,,,,
,,,正确使用SSL证书,[严重] 是否正确验证SSL证书,,,,,,,
,,,CSRF防护,[重要] 是否实现了CSRF防护,,,,,,,
,,,安全HTTP头部,[重要] 是否设置了安全HTTP头部,,,,,,,
,性能优化,数据库优化,查询、更新、删除优化,,,,,,,,
,,,表结构优化,索引、冗余,,,,,,,
,,,分页查询是否合理,,,,,,,,
,,,批量处理的逻辑是否合理,,,,,,,,
,,缓存策略,缓存是否考虑,,,,,,,,
,,,缓存是否使用合理,,,,,,,,
,,,更新机制是否安全,,,,,,,,
,,,监控了缓存命中率,,,,,,,,
,,异步处理,非关键耗时操作异步化,,,,,,,,
,,,消息队列的合理使用,,,,,,,,
,,,批量处理,,,,,,,,
,,,是否可以缓存计算结构,,,,,,,,
,微服务,通信,服务间通信是否实现了熔断、超时和重试机制,,,,,,,,
,,,是否实现了服务发现机制,,,,,,,,
,,, API契约是否明确且版本化,,,,,,,,
,,,是否考虑了向后兼容性,,,,,,,,
,,,使用安全的通信协议,,,,,,,,
,,,API安全,,,,,,,,
,故障处理与恢复,故障恢复能力reviews,检查故障恢复所采取的措施,,,,,,,,
,,故障隔离,单点故障不会级联导致整个系统崩溃，故障影响范围应该尽可能的索缩小,,,,,,,,
,可扩展和可维护性,数据一致性,分布式事务,,,,,,,,
,,,补偿事务或最终一致性模式,,,,,,,,
,,,幂等性,,,,,,,,
,,,数据恢复机制,,,,,,,,
,,配置管理,敏感配置是否加密或使用外部配置服务,,,,,,,,
,,,不同环境的配置是否分离,,,,,,,,
,,,是否支持配置热更新,,,,,,,,
,,,配置是否有校验机制（容错和提醒）,,,,,,,,
,,,配置是否有文档说明,,,,,,,,
,,可插拔设计	,是否使用策略模式/模板方法/责任链等提升灵活性,,,,,,,,
,,DTO/Entity分离,是否避免实体直接暴露到接口层	,,,,,,,,
,DevOps与部署,tomcat中间件,非root用户运行,,,,,,,,
,,,内存大小设置合理,,,,,,,,
,,,tomcat 经过安全裁剪,,,,,,,,
,,容器化,非root用户运行,,,,,,,,
,,,暴漏健康和就绪接口,,,,,,,,
,,,合理的资源限制,,,,,,,,
,,优雅停机,优雅关闭机制,,,,,,,,
,,,处理了SIGTERM信号,,,,,,,,
,,,是否正确关闭了连接池和其他资源,,,,,,,,
,,,否等待当前请求处理完成,,,,,,,,
,测试,单元测试,单元测试覆盖,,,,,,,,
,,,边界条件和异常路径,,,,,,,,
,,,测试的独立和可重复性,,,,,,,,
,,集成测试,适当的mock/stub替代外部依赖,,,,,,,,
,,,验证了与外部系统的集成,,,,,,,,
,,,性能测试和负载测试,,,,,,,,
,,,并发场景测试,,,,,,,,
